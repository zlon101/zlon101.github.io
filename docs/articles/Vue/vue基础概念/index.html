<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.22.0"/><style data-href="/styles.f8ed7cdd0b842235ccf7.css" data-identity="gatsby-global-css">@-webkit-keyframes silde{0%{background-color:green}50%{background-color:blue}to{background-color:red}}@keyframes silde{0%{background-color:green}50%{background-color:blue}to{background-color:red}}.p-debug{margin:40px auto 0;outline:1px solid red;overflow:auto;padding:16px;position:relative;width:70vw}.p-debug .animation{background-color:red;height:200px;width:200px}.p-debug .animation.active{-webkit-animation:silde 10s infinite;animation:silde 10s infinite}.c-header{align-items:center;background-color:#fff;border-bottom:2px solid #eaecef;display:flex;height:48px;left:0;padding:8px 16px;position:fixed;top:0;width:100%;z-index:1000}.c-header>*{cursor:pointer;font-size:18px;font-weight:600;margin-right:18px}.c-header>:last-child{margin-left:auto;margin-right:0}.c-nav{min-height:calc(100vh - 48px);overflow:auto;padding:16px 16px 16px 0;position:-webkit-sticky;position:sticky;top:48px}.c-nav .file-item{display:block;margin:8px 0;white-space:nowrap}.c-nav .file-item.fold>.file-name:after{border-color:transparent transparent transparent #ccc;border-style:solid;border-width:6px 0 6px 9px;content:"";display:inline-block;height:0;margin-left:8px;transition:all .2s ease-out;width:0}.c-nav .file-item.fold.expand>.file-name:after{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.c-nav .file-item.fold.expand>.child-list{display:block}.c-nav .file-name{border-left:4px solid transparent;color:#2c3e50;cursor:pointer;display:block;font-size:16px;font-weight:700;margin-bottom:12px;padding-left:16px;position:relative}.c-nav .file-name.light{color:#3eaf7c;font-size:18px}.c-nav .child-list{display:none;margin:0;padding-left:16px;transition:all .2s ease-out}.c-layout-sidebar-content{display:flex;position:relative}.c-layout-sidebar-content .article-wrap{flex:1 1 auto}.c-layout-nav{border-right:2px solid #eaecef;max-width:300px;min-width:200px}

/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{-webkit-text-size-adjust:100%;line-height:1.15}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;margin:0;outline:0;padding:0}body,html{font-family:Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}p{line-height:1.5}a{color:#2c3e50;text-decoration:none}a:hover{text-decoration:underline}.page{padding-top:48px}.g-desc{color:#7f8fa4;font-size:14px}.icon-arrow{border-color:transparent transparent transparent blue;border-style:solid;border-width:44.5px 0 44.5px 118px;height:0;width:0}.icon-font{fill:currentColor;overflow:hidden;vertical-align:-.15em}.page-home-excerpt{background-color:#9cc;border:1px solid transparent;border-radius:6px;margin-bottom:24px;padding:16px}.page-home-excerpt-header{margin-bottom:4px}.page-home-excerpt-header-title{font-size:18px;font-weight:700}.page-home-excerpt-header-desc{color:#7f8fa4;font-size:14px;margin-left:8px}.page-home-excerpt-text{font-size:16px}.page-article-template .article-title-wrap{border-left:2px solid #eaecef;min-width:10%}.page-article-template .article-title-wrap .item{font-size:14px;font-weight:500}.page-article-template .article-title-wrap .item a{pointer-events:none}.page-article-template .article-title-list{padding:8px;position:-webkit-sticky;position:sticky;top:48px}.page-article-template .article-title-list .item{cursor:pointer;list-style:none;margin-bottom:12px}.page-article-template .article-title-list .item:hover{color:#3eaf7c;text-decoration:underline}.article-wrap{padding:0 8px 0 24px}.article-wrap h1{border-bottom:2px solid blue;font-size:16px;margin:36px 0}.article-wrap h2,.article-wrap h3,.article-wrap h4,.article-wrap h5,.article-wrap h6{border-bottom:2px solid blue;font-size:18px;margin:24px 0}.article-wrap div,.article-wrap p{margin:8px 0}.article-wrap a{color:#0969da}.article-wrap>:not(ul){margin-left:-14px}.article-wrap li{margin:8px 0}.article-wrap li ol,.article-wrap li ul{margin-left:12px}.article-wrap ol{margin-left:3px}.article-wrap blockquote{background-color:#fff5e3;border-left:.25em solid #ffb11b;color:#57606a;padding-left:24px}.article-wrap blockquote>p{margin-left:-16px}.article-wrap code{background-color:#fff5e3;border-radius:2px;color:#9b6e23;margin:0 2px;padding:3px 5px;white-space:nowrap}.article-wrap img{box-shadow:0 0 80px -30px rgba(0,0,0,.5)!important}.article-wrap table{border-collapse:collapse;border-spacing:0}.article-wrap table td,.article-wrap table th{background-color:#1f2329;border-bottom:1px solid rgba(220,223,230,.3);border-right:1px solid rgba(220,223,230,.3);color:#fff;padding:8px 16px;text-align:left}.article-title-wrap,.article-wrap{counter-reset:h1}.article-title-wrap h1,.article-wrap h1{counter-reset:h2}.article-title-wrap h1:before,.article-wrap h1:before{content:counter(h1) ". ";counter-increment:h1}.article-title-wrap h2,.article-wrap h2{counter-reset:h3}.article-title-wrap h2:before,.article-wrap h2:before{content:counter(h1) "." counter(h2) ". ";counter-increment:h2}.article-title-wrap h3,.article-wrap h3{counter-reset:h4}.article-title-wrap h3:before,.article-wrap h3:before{content:counter(h1) "." counter(h2) "." counter(h3) ". ";counter-increment:h3}.article-title-wrap h4,.article-wrap h4{counter-reset:h5}.article-title-wrap h4:before,.article-wrap h4:before{content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) ". ";counter-increment:h4}.article-title-wrap h5,.article-wrap h5{counter-reset:h6}.article-title-wrap h5:before,.article-wrap h5:before{content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) ". ";counter-increment:h5}.article-title-wrap h6:before,.article-wrap h6:before{content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) "." counter(h6) ". ";counter-increment:h6}</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="c-layout-wrap  page page-article-template"><header class="c-header"><a href="/">首页</a><a href="/">博客</a><a href="https://zlong1010.github.io/vue-components/#/" target="_blank" rel="noreferrer noopener">vue组件指令</a><a href="/debug/">Debug</a><a href="https://github.com/zlong1010" target="_blank" rel="noreferrer noopener"><svg class="icon-font" width="24px" height="24px" aria-hidden="true"><use href="#icon-font-github1"></use></svg></a></header><div class="c-layout-sidebar-content "><div class="c-layout-nav "><div class="c-nav"><div class="file-item fold false"><div class="file-name" role="button">Vue</div><ul class="child-list"><a class="file-name false" href="/articles/Vue/vue2源码/">vue2源码</a><a class="file-name false" href="/articles/Vue/vue基础概念/">vue基础概念</a><a class="file-name false" href="/articles/Vue/PWA/">PWA</a><a class="file-name false" href="/articles/Vue/Vue技术栈/">Vue技术栈</a><a class="file-name false" href="/articles/Vue/总结/">总结</a><a class="file-name false" href="/articles/Vue/Vue视频资料/">Vue视频资料</a><a class="file-name false" href="/articles/Vue/服务端渲染/">服务端渲染</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">博客</div><ul class="child-list"><a class="file-name false" href="/articles/博客/Gatsby建站/">Gatsby建站</a><a class="file-name false" href="/articles/博客/指南/">指南</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">React</div><ul class="child-list"><a class="file-name false" href="/articles/React/React基础/">React基础</a><a class="file-name false" href="/articles/React/React总结/">React总结</a><a class="file-name false" href="/articles/React/React技术栈/">React技术栈</a><a class="file-name false" href="/articles/React/TODO/">TODO</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">服务端</div><ul class="child-list"><a class="file-name false" href="/articles/服务端/基础/">基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">网络</div><ul class="child-list"><a class="file-name false" href="/articles/网络/HTTP/">HTTP</a><a class="file-name false" href="/articles/网络/代理/">代理</a><a class="file-name false" href="/articles/网络/服务端/">服务端</a><a class="file-name false" href="/articles/网络/网络基础/">网络基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">数据算法</div><ul class="child-list"><a class="file-name false" href="/articles/数据算法/数据结构基础/">数据结构基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">前端</div><ul class="child-list"><div class="file-item fold false"><div class="file-name" role="button">JS</div><ul class="child-list"><a class="file-name false" href="/articles/前端/JS/ES6/">ES6</a><a class="file-name false" href="/articles/前端/JS/总结/">总结</a><a class="file-name false" href="/articles/前端/JS/JS基础/">JS基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">HTML-CSS</div><ul class="child-list"><a class="file-name false" href="/articles/前端/HTML-CSS/HTML基础/">HTML基础</a><a class="file-name false" href="/articles/前端/HTML-CSS/CSS基础/">CSS基础</a><a class="file-name false" href="/articles/前端/HTML-CSS/总结/">总结</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">前端工程化</div><ul class="child-list"><a class="file-name false" href="/articles/前端/前端工程化/Babel/">Babel</a><a class="file-name false" href="/articles/前端/前端工程化/Gulp/">Gulp</a><a class="file-name false" href="/articles/前端/前端工程化/Webpack/">Webpack</a><a class="file-name false" href="/articles/前端/前端工程化/npm/">npm</a><a class="file-name false" href="/articles/前端/前端工程化/图标/">图标</a><a class="file-name false" href="/articles/前端/前端工程化/打包工具/">打包工具</a><a class="file-name false" href="/articles/前端/前端工程化/模块/">模块</a><a class="file-name false" href="/articles/前端/前端工程化/私有源/">私有源</a></ul></div><a class="file-name false" href="/articles/前端/前端调试/">前端调试</a><a class="file-name false" href="/articles/前端/webView/">webView</a><a class="file-name false" href="/articles/前端/总结/">总结</a><a class="file-name false" href="/articles/前端/前端资源整理/">前端资源整理</a><a class="file-name false" href="/articles/前端/浏览器/">浏览器</a><a class="file-name false" href="/articles/前端/练题/">练题</a><a class="file-name false" href="/articles/前端/规范/">规范</a><a class="file-name false" href="/articles/前端/设计模式/">设计模式</a></ul></div><a class="file-name false" href="/articles/Git/">Git</a><a class="file-name false" href="/articles/Linux命令/">Linux命令</a><a class="file-name false" href="/articles/TS基础/">TS基础</a><a class="file-name false" href="/articles/vue3/">vue3</a><a class="file-name false" href="/articles/微前端/">微前端</a><a class="file-name false" href="/articles/WebRTC/">WebRTC</a><a class="file-name false" href="/articles/爬虫/">爬虫</a></div></div><article class="article-wrap"><blockquote>
<ul>
<li>
<p>什么是字符串模板：单文件中的template 和 实例化vue对象时的template 属性。</p>
</li>
<li>
<p>DOM 模板：在 html 文件中编写的html标签(包含自定义标签)，直接在DOM中使用组件。</p>
</li>
<li>
<p>html 属性名和属性值</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>vue 实例属性：<code>data、computed、methods、props</code> 中的属性都挂载到 vue 实例的一级属性上。</p>
</li>
<li>
<p><code>computed</code> 可以依赖多个vue 实例属性，并根据依赖进行缓存。</p>
</li>
<li>
<p>指令：指令可以带参数和修饰符，指令绑定的表达式。指令的值是多少？</p>
</li>
<li>
<p>Vue 推荐在绝大多数情况下使用<strong>模板</strong>来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用<strong>渲染函数</strong>，它比模板更接近编译器。</p>
</li>
<li>
<p>Vue 的模板实际上被编译成了渲染函数</p>
</li>
</ul>
<h1 id="t-0" >组件</h1>
<blockquote>
<p>组件是可复用的 Vue 实例</p>
<p>根实例特有选项: el</p>
</blockquote>
<p>创建组件的方式有哪些？</p>
<ul>
<li>
<p>使用 Vue.component 或 Vue.extend 定义组件</p>
</li>
<li>
<p>全局注册</p>
<deckgo-highlight-code language="vue" terminal="carbon" theme="blackboard"  >
          <code slot="code">Vue.component(&#39;my-component-name&#39;, {
  // ... options ...
})</code>
        </deckgo-highlight-code>
</li>
</ul>
<p>函数式组件和类组件：函数式组件只是函数，所以渲染开销也低很多</p>
<p>vue-class-component 和 vue-property-decorator</p>
<p>vm 表示实例，h 表示 createElement</p>
<p>组件的选项对象</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">var app = new Vue({
  el: &#39;#app&#39;,
  data: {
    message: &#39;Hello Vue!&#39;
  }
})</code>
        </deckgo-highlight-code>
<p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。</p>
<p>// 定义一个名为 button-counter 的新组件</p>
<p>// 全局注册：全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生</p>
<p>html 的属性名不区分大小写，都是小写</p>
<p>html 属性值只能是字符串？</p>
<deckgo-highlight-code language="vue" terminal="carbon" theme="blackboard"  >
          <code slot="code">Vue.component(&#39;button-counter&#39;, {
  data() {
    return {
      count: 0
    }
  },
  props: [&#39;title&#39;],
  template: &lt;button v-on:click=&quot;count++&quot;&gt;You clicked me {{ count }} times.&lt;/button&gt;
})
// ***********************************************************
props: [&#39;initialCounter&#39;],
data(){
  return {
    counter: this.initialCounter
  }
}</code>
        </deckgo-highlight-code>
<h2 id="t-1" ><a href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6">动态组件</a></h2>
<deckgo-highlight-code language="html" terminal="carbon" theme="blackboard"  >
          <code slot="code">&lt;tbody is=&quot;my-cmp&quot;&gt;&lt;/tbody&gt;</code>
        </deckgo-highlight-code>
<p><code>tbody</code> 在渲染时被替换为<code>my-cmp</code> 组件</p>
<p>$emit ==> $event</p>
<p>自定义事件(非click)</p>
<ul>
<li>$emit：触发一个事件</li>
<li>$event：</li>
</ul>
<hr>
<h1 id="t-2" >vue组件三大核心概念</h1>
<img src="assets/vue%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/vue%E7%BB%84%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.jpeg" alt="vue组件核心概念" style="zoom: 67%;" />    
<ul>
<li>
<p>原生组件(也叫 HTML 元素)的构成：<code>&#x3C;div id='app' style='width:70%'>内容&#x3C;/div></code>，开始标签、内容、结束标签、属性(特性)、属性值；自定义组件也由这些部分构成。</p>
<deckgo-highlight-code language="html" terminal="carbon" theme="blackboard"  >
          <code slot="code">&lt;!--使用自定义组件--&gt;
&lt;my-component name=&#39;czl&#39;&gt;
    &lt;!-- 此处为组件内容，通过slot插槽传递 --&gt;
    &lt;p&gt;&lt;/p&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/my-component&gt;</code>
        </deckgo-highlight-code>
</li>
</ul>
<blockquote>
<ul>
<li>一个 Vue 应用由一个通过 new Vue 创建的<strong>根 Vue 实例</strong>，以及可选组件树组成；</li>
<li>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 <strong>Vue 实例</strong>，每个组件都会各自独立维护它的 data对象。因为你每用一次组件，就会有一个它的新<strong>实例</strong>被创建，所以data对象是通过函数返回；</li>
<li>在组件上使用<strong>v-for</strong>时，<strong>key</strong> 是必须提供的；</li>
<li><strong>组件有自己独立的作用域，<strong>数据不会传递到组件内 ，因此使用</strong>props</strong>向组件内部传递数据；</li>
<li>不要在选项属性或回调上使用箭头函数；</li>
<li>Vue 将模板编译成虚拟 DOM 渲染函数；</li>
</ul>
</blockquote>
<p>Vue最核心的功能：数据的双向绑定，实时同步数据，数据驱动DOM。</p>
<ul>
<li>
<p>Q:数据双向绑定是哪两方数据?</p>
<ul>
<li>A:HTML元素数据(表单元素)--Vue实例中的data将元素的属性与属性值分离，其值存放在Vue实例中；用v-model、v-bind将元素属性与其属性值相互绑定。</li>
</ul>
</li>
<li>
<p>Vue创建的实例代理了data和method属性，所以可以直接通过实例（this.**）访问；</p>
</li>
<li>
<p>实例属性与方法用$开头来访问，如vueApp.$el可以访问元素；</p>
</li>
</ul>
<h2 id="t-3" >Vue构成</h2>
<ol>
<li>组件化</li>
<li>数据驱动 &#x26; 状态管理(vuex)</li>
<li>指令</li>
</ol>
<h2 id="t-4" >计算属性 &#x26; watch</h2>
<ol>
<li>计算属性只能执行同步代码，计算属性根据响应式依赖进行缓存，当依赖的数据没有更新时，多次访问计算属性直接取缓存的值；</li>
<li>watch 可以执行异步操作；</li>
</ol>
<h2 id="t-5" >1. 属性</h2>
<p><strong>1.1 分类</strong></p>
<ul>
<li>自定义属性props</li>
<li>原生属性attrs</li>
<li>插槽props</li>
<li>特殊属性class、style</li>
</ul>
<p>data与props的区别？</p>
<p>单向数据流？</p>
<h3 id="t-6" >Vue为什么禁止修改父组件传递进来的props， 又是如何监控到子组件修改了props?</h3>
<ul>
<li>因为Vue遵循单向数据流，模型(比如props数据)渲染视图，如果允许子组件修改父组件传递的值，那么同一父组件的其他子组件就会受影响，导致数据流向很混乱，所以禁止子组件修改props。可以通过父组件传递一个回调函数实现。Vue通过 <code>defineProperty</code>  定义属性的属性描述符中的<code>get</code>和<code>set</code>，当修改属性时判断是否是父组件触发的修改。</li>
</ul>
<h3 id="t-7" >组件内部修改 props 的方法</h3>
<ol>
<li>拷贝至 data 或 计算属性，结合 emit 实现父组件更新；</li>
<li><code>sync</code> 修饰符；</li>
<li>将 props 包装为对象，因为 props 传递是引用；</li>
</ol>
<h2 id="t-8" >2. 事件</h2>
<ul>
<li>事件驱动 &#x26; 数据驱动</li>
<li>普通事件 &#x26; 修饰符事件</li>
</ul>
<p>在自定义组件上注册监听原生事件(如click)，使用 native 事件修饰符 <code>&#x3C;my-componenet @click.native="handle">&#x3C;/my-component></code>；因为 my-component 不在DOM树上，添加的是组件内模板的代码(组件模板默认会继承非props特性)，如果没有 native 修饰，则原生的监听器(click)没有作用；注意自定义事件this.$emit不需要native修饰。</p>
<h2 id="t-9" >3. 插槽</h2>
<ul>
<li>普通插槽</li>
<li>作用域插槽</li>
</ul>
<p>参考链接: <a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&#x26;mid=2247483942&#x26;idx=1&#x26;sn=bb123cb4d34f94f79881f0fa226da26b&#x26;chksm=c06683b0f7110aa6baf6e8ab59870a10fbf9a07083910054a25e67e50d306985103570d88ca2&#x26;mpshare=1&#x26;scene=1&#x26;srcid=&#x26;key=3e64675c4af2e8c1cb87133eea4dc87d7279f068d389ab5644397f9f2d0c1e1cd7e62cc0d356a7eed5b35b508b65ab0ee65bab9587ba98854bfbffa1c964800fab1fc979d082faa5ab76ece9c4c63431&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060739&#x26;lang=zh_CN&#x26;pass_ticket=S8Ujki2fz5qcjOi%2B1GEFSYgOxjQ%2BmiRmgp17ybRU2kbGBIyFXc%2FGjUjxA3p23gkD">详解vue组件三大核心概念</a></p>
<h1 id="t-10" >组件构成</h1>
<h2 id="t-11" >props</h2>
<blockquote>
<p><code>props</code>  的 key &#x26; value，类型、默认值、验证</p>
</blockquote>
<ul>
<li>
<p>props属性：定义组件时，在组件实例的props选项上声明的属性；可以通过<code>this.$props</code>获取该属性，直接使用<code>v-bind=$props</code>在<code>&#x3C;template></code>中的元素上进行绑定。</p>
</li>
<li>
<p>非props属性：使用组件时，定义了未在props选项上声明的属性；<code>$attrs</code> 可以访问非 <code>props</code> 属性。默认情况下，所有的非props属性被组件&#x3C;template>的根元素继承；通过<code>inheritAttrs</code>设置根元素是否继承非<code>props</code>属性</p>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">&lt;my-component name=&quot;czl&quot; age=&quot;22&quot;&gt;&lt;/my-component&gt;
局部注册
new Vue({
  el:&quot;#app&quot;,
  components:{
      myComponent:{
          inheritAttrs:false,	默认为true            
          template: &#39;&lt;div id=&quot;root&quot;&gt;&lt;input v-bind=$attrs&gt;&lt;/div&gt;&#39;
      }
  }
})</code>
        </deckgo-highlight-code>
</li>
</ul>
<h2 id="t-12" >无参bind</h2>
<ul>
<li>
<p>v-bind:参数='表达式'</p>
</li>
<li>
<p>使用无参的bind指令可以一次动态绑定多个值，等价于将属性名作为参数</p>
<deckgo-highlight-code language="html" terminal="carbon" theme="blackboard"  >
          <code slot="code">&lt;MyCom v-bind=&quot;obj&quot;/&gt;
obj: {
	name: &#39;czl&#39;,
	age: 22
} 
// 等价于 &lt;MyCom v-bind:name=&quot;obj.name&quot; :age=&quot;obj.age&quot;&gt;</code>
        </deckgo-highlight-code>
</li>
</ul>
<h2 id="t-13" >slot</h2>
<ul>
<li>slot：分发__内容__(元素由开始标签、结束标签和<strong>内容</strong>构成)，当有多个内容需要分发时，通过指定slot.name即具名slot实现。</li>
<li>插槽prop: 绑定在<code>&#x3C;slot></code>上的特性</li>
</ul>
<h2 id="t-14" >watch监听引用数据</h2>
<ul>
<li>
<p>监听复杂数据(object、array)</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">watch: {
obj: {
      deep: true,
      handle: function(newValue, oldValue){
           ...
      }        
  }
}</code>
        </deckgo-highlight-code>
</li>
</ul>
<h2 id="t-15" >keep-alive</h2>
<ul>
<li>
<p>将组件&#x3C;my-component>进行缓存，避免每次重新渲染组件(create, mounte等)，用于路由及组件切换(动态组件&#x3C;component v-bind:is="cmp">)。</p>
<deckgo-highlight-code language="html" terminal="carbon" theme="blackboard"  >
          <code slot="code">&lt;keep-alive&gt;
 &lt;my-component&gt;&lt;/my-component&gt;
&lt;/keep-alive&gt;</code>
        </deckgo-highlight-code>
</li>
</ul>
<h2 id="t-16" >native</h2>
<ul>
<li>
<p>若没有修饰符native，那下面的@click就是自定义事件click而非原生click</p>
<deckgo-highlight-code language="html" terminal="carbon" theme="blackboard"  >
          <code slot="code">&lt;mycomponent @click.native=&#39;handleClick&#39;&gt;&lt;/mycomponent&gt;</code>
        </deckgo-highlight-code>
</li>
</ul>
<h1 id="t-17" >key</h1>
<p>vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：</p>
<ol>
<li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。</li>
<li>同一层级的一组节点，他们可以通过唯一的id进行区分。</li>
</ol>
<p>基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。</p>
<ul>
<li><code>key</code> 的作用是给予一个节点唯一的身份识别，有相同父元素的子元素必须有独特的 <code>key</code>，特别是列表渲染时的节点，因为相同的组件产生类似的DOM结构 。这样在使用Diff算法对新旧虚拟DOM进行比较时，计算出哪些节点是可以<strong>就地复用或者调整顺序</strong>，可以更高效的重用排序现有的元素；比较时，依次对比两个节点的类型、属性、子节点。</li>
<li>key的作用主要是为了高效的更新虚拟DOM。</li>
</ul>
<h1 id="t-18" >组件通信</h1>
<ol>
<li>props &#x26; emit：自定义属性和自定义事件</li>
<li>$refs、$parent、$children</li>
<li>provide &#x26; inject</li>
<li>$attrs &#x26; $listeners</li>
<li>Event Bus</li>
<li>vuex</li>
</ol>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&#x26;mid=2650215866&#x26;idx=1&#x26;sn=c4cc189d145d5c358db61697ca70a82e&#x26;chksm=befe159b89899c8d4ae785b5f63063434dc1279830c020d8b60985e8e6a36a2e55f93a2ac6d4&#x26;scene=0&#x26;key=2bb12b254a1b99044f1b54db34647d49c8c06f37b302512cea302a011df276cdf11973e6bbdd41b9ebfa174ff119d5b271bd567f7bbc5eb6a01718c24400c75602ee6810ea48253930f85fd15310ff25&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060739&#x26;lang=zh_CN&#x26;pass_ticket=Ssclv0EjFV5vOJWuvp4F%2F2EaOid5lYknyYjfJDT8vOG1egweHVyv%2ByaE%2BGO8rIc8">SegmentFault参考</a></li>
</ul>
<h1 id="t-19" >Virtual DOM</h1>
<h2 id="t-20" >Diff 算法</h2>
<p>Diff 算法将时间复杂度从O(n3)减少到O(n)；</p>
<p>diff 算法包括几个步骤：</p>
<ol>
<li>用 JS 对象表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中；</li>
<li>当状态变更的时候，重新构造一棵新的对象树，然后用新的树和旧的树进行比较(同层比较)，记录两棵树差异；</li>
<li>把所记录的差异应用到所构建的真正的DOM树上，视图就更新了；</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&#x26;mid=2247484031&#x26;idx=1&#x26;sn=ece0d952f7192b3d408da5fc68a880a4&#x26;chksm=c06683e9f7110aff8b0b9f0cbbd5de34754c28c1176189964564ed5cd28a459e6f9e09be54d5&#x26;mpshare=1&#x26;scene=1&#x26;srcid=&#x26;key=3e64675c4af2e8c1434a938098a616e5abdb665d9e84903be474c86d977e282af3b8878d3952b0c28b6c2d63d63a00ed7195b0d74798baf1d7c34bd3d2ead3a110f204c293a0583dab0b48772f18fb87&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060833&#x26;lang=zh_CN&#x26;pass_ticket=WoiLyjX22pgkcex3J0Zr4C7XhoDMUgwrJ0I8gXuNREhi9k%2F0J3OO2IhX87FJPVXU">揭秘Vue中的Virtual Dom</a></li>
</ul>
<h1 id="t-21" >render &#x26; JSX &#x26; 函数组件</h1>
<p>如何描述组件的UI和状态信息？</p>
<ol>
<li>字符串模板</li>
<li><strong><code>&#x3C;template></code></strong></li>
<li>render 函数</li>
</ol>
<p>这三中方法的作用都是一样的(可以相互替换)</p>
<h2 id="t-22" >1.render</h2>
<p><u>render 函数</u></p>
<ul>
<li>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">new Vue({
  render(h){
    h(&#39;p&#39;, 子节点);
    // h 即 createElemnet
  }
})</code>
        </deckgo-highlight-code>
</li>
<li></li>
</ul>
<p><a href="https://cn.vuejs.org/v2/api/#render">Vue官网API</a></p>
<ul>
<li><strong>createElement</strong> 的返回值是什么?
createElement的返回的不是一个实际的  DOM 元素。它更准确的名字可能是 <code>createNodeDescription</code>，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“<strong>VNode</strong>”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</li>
</ul>
<p><a href="#">render 和 template 的关联</a></p>
<ul>
<li>template 模板的来源？
当 Vue 选项对象中有 render 渲染函数时，Vue 构造函数将直接使用渲染函数渲染 DOM 树，当选项对象中没有 render 渲染函数时，Vue 构造函数首先通过将 template 模板编译生成渲染函数，然后再渲染 DOM 树，而当 Vue 选项对象中既没有 render 渲染函数，也没有 template 模板时，会通过 el 属性获取挂载元素的 outerHTML 来作为模板，并编译生成渲染函数。</li>
</ul>
<h2 id="t-23" >2.函数式组件</h2>
<p>特点：</p>
<ol>
<li>声明了functional: true;</li>
<li>render(h, context);     // 由第二个参数提供状态数据, h-->createElement</li>
</ol>
<h2 id="t-24" >3.JSX</h2>
<p><strong>JSX只是JS的语法扩展，在JS文件中使用。</strong></p>
<p><strong>插件</strong>：@vue/babel-preset-jsx @vue/babel-helper-vue-jsx-merge-props</p>
<p><a href="https://github.com/vuejs/jsx#installation">https://github.com/vuejs/jsx#installation</a></p>
<p><strong>Demo：</strong></p>
<ul>
<li>
<p>render(h, ctx)中第一个参数在某些版本下只能用名称h，详细见**<a href="%5Bhttps://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%5D(https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6)">Vue-函数式组件</a>**</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">&lt;template&gt;
	&lt;VNode :vnodes=&quot;getJSXSpan()&quot; info=&quot;info&quot;/&gt;&lt;hr&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
components: {    
    // 函数组件
    VNode: {
        functional: true,
        
        // 第一种使用方法
        render: (h, ctx) =&gt; {
            return h(&#39;div&#39;, {
                style: {
                    color: &#39;blue&#39;
                },
                attrs: {
                    id: &quot;funCom&quot;
                }
            }, [ctx.props.vnodes])
        }
        
        // 第二种使用方法
        render: (h, ctx) =&gt; ctx.props.vnodes
        
        // 第三种使用方法
        render: (h, ctx) =&gt; {            
            let {type, info} = ctx.props;
            // return h(type, ctx.data, ctx.children);

            return FC();
            
            function FC(){
                info = info || &#39;未定义&#39;;
                return (
                    &lt;type class=&quot;func-comp&quot; {...ctx.data}&gt;
                        &lt;span&gt;{ ctx.children }&lt;/span&gt;
                    &lt;/type&gt;
                )                
            }
        }
    }
},

methods: {
    getJSXSpan() {
    	return &lt;span&gt;Message: {this.msg}&lt;/span&gt;;
    },
}
&lt;/script&gt;</code>
        </deckgo-highlight-code>
</li>
</ul>
<h2 id="t-25" >参考</h2>
<h3 id="t-26" ><a href="https://zhuanlan.zhihu.com/p/25486761">render 函数与模板编译：运行时构建 &#x26; 独立构建</a></h3>
<hr>
<p>当使用 <code>vue-loader</code> 或 <code>vueify</code> 的时候，<code>*.vue</code> 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。</p>
<h1 id="t-27" >vue实例</h1>
<p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的属性加入到 Vue 的<strong>响应式系统</strong>中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的属性才是<strong>响应式</strong>的。也就是说如果你添加一个新的属性，</p>
<h2 id="t-28" >模板</h2>
<ul>
<li>
<p>绑定的数据对象不必内联定义在模板里</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code>
        </deckgo-highlight-code>
</li>
<li>
<p>注意这里的 <code>is="todo-item"</code> 属性。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>&#x3C;ul></code> 元素内只有 <code>&#x3C;li></code> 元素会被看作有效内容。这样做实现的效果与 <code>&#x3C;todo-item></code> 相同，但是可以避开一些潜在的浏览器解析错误。查看 <a href="https://cn.vuejs.org/v2/guide/components.html#%E8%A7%A3%E6%9E%90-DOM-%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">DOM 模板解析说明</a> 来了解更多信息。</p>
</li>
</ul>
<p>需要注意的是<strong>如果我们从以下来源使用模板的话，这条限制是不存在的</strong>：</p>
<ul>
<li>
<p>字符串 (例如：<code>template: '...'</code>)</p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件 (<code>.vue</code>)</a></p>
</li>
<li>
<script type="text/x-template">


</li>
</ul>
<p>当直接在 DOM 中使用一个组件 (而不是在字符串模板或<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>) 的时候，我们强烈推荐遵循 <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">W3C 规范</a>中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。</p>
<ul>
<li>
<p>不要在选项属性或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，比如 <code>created: () => console.log(this.a)</code> 或 <code>vm.$watch('a', newValue => this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止；</p>
</li>
<li>
<p>计算属性：基于响应式依赖进行缓存，当依赖的数据没有更新时，不会执行函数；
计算属性默认只有getter</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + &#39; &#39; + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(&#39; &#39;)
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}</code>
        </deckgo-highlight-code>
</li>
</ul>
<h1 id="t-29" >vue 响应式原理</h1>
<img src="assets/vue%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9B%B4%E6%96%B0.png" alt="vue响应式更新" style="zoom: 50%;" />   
<p>创建一个vue 实例时，vue 遍历data 对象的属性，并使用 defineProperty 将属性转换为 getter\setter (vue3.0 使用 Proxy)，当属性被访问或修改时触发更新(使用了发布订阅模式)。</p>
<p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<h2 id="t-30" >异步更新队列</h2>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97">vue官网</a></p>
</blockquote>
<h2 id="t-31" >参考</h2>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/reactivity.html">深入响应式原理-vue官网</a></li>
</ul></article><div class="article-title-wrap"><div class="article-title-list"><h1 data-id="0" class="item">组件</h1><h2 data-id="1" class="item"><a href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6">动态组件</a></h2><h1 data-id="2" class="item">vue组件三大核心概念</h1><h2 data-id="3" class="item">Vue构成</h2><h2 data-id="4" class="item">计算属性 &#x26; watch</h2><h2 data-id="5" class="item">1. 属性</h2><h3 data-id="6" class="item">Vue为什么禁止修改父组件传递进来的props， 又是如何监控到子组件修改了props?</h3><h3 data-id="7" class="item">组件内部修改 props 的方法</h3><h2 data-id="8" class="item">2. 事件</h2><h2 data-id="9" class="item">3. 插槽</h2><h1 data-id="10" class="item">组件构成</h1><h2 data-id="11" class="item">props</h2><h2 data-id="12" class="item">无参bind</h2><h2 data-id="13" class="item">slot</h2><h2 data-id="14" class="item">watch监听引用数据</h2><h2 data-id="15" class="item">keep-alive</h2><h2 data-id="16" class="item">native</h2><h1 data-id="17" class="item">key</h1><h1 data-id="18" class="item">组件通信</h1><h1 data-id="19" class="item">Virtual DOM</h1><h2 data-id="20" class="item">Diff 算法</h2><h1 data-id="21" class="item">render &#x26; JSX &#x26; 函数组件</h1><h2 data-id="22" class="item">1.render</h2><h2 data-id="23" class="item">2.函数式组件</h2><h2 data-id="24" class="item">3.JSX</h2><h2 data-id="25" class="item">参考</h2><h3 data-id="26" class="item"><a href="https://zhuanlan.zhihu.com/p/25486761">render 函数与模板编译：运行时构建 &#x26; 独立构建</a></h3><h1 data-id="27" class="item">vue实例</h1><h2 data-id="28" class="item">模板</h2><h1 data-id="29" class="item">vue 响应式原理</h1><h2 data-id="30" class="item">异步更新队列</h2><h2 data-id="31" class="item">参考</h2></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/articles/Vue/vue基础概念/";window.___webpackCompilationHash="5207d3255268461d308d";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-38bff700e245e8493772.js"],"app":["/app-10896d9b1e770b1c82d9.js"],"component---src-pages-404-js":["/component---src-pages-404-js-a1cb840e6fe8c403c00b.js"],"component---src-pages-debug-jsx":["/component---src-pages-debug-jsx-19f27fb8a0713cec9f30.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-392a422209c4ea736eb4.js"],"component---src-pages-other-js":["/component---src-pages-other-js-9c6c2b81a35ac0392fee.js"],"component---src-pages-repos-jsx":["/component---src-pages-repos-jsx-26466ebc98dbcc9c1590.js"],"component---src-templates-post-js":["/component---src-templates-post-js-3b0ec7b578ab953404c3.js"]};/*]]>*/</script><script src="/polyfill-38bff700e245e8493772.js" nomodule=""></script><script src="/app-10896d9b1e770b1c82d9.js" async=""></script><script src="/framework-00aa2f30c053856ae873.js" async=""></script><script src="/webpack-runtime-2ac7a3f3baa60b4ab834.js" async=""></script></body></html>