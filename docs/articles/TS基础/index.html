<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.22.0"/><style data-href="/styles.f8ed7cdd0b842235ccf7.css" data-identity="gatsby-global-css">@-webkit-keyframes silde{0%{background-color:green}50%{background-color:blue}to{background-color:red}}@keyframes silde{0%{background-color:green}50%{background-color:blue}to{background-color:red}}.p-debug{margin:40px auto 0;outline:1px solid red;overflow:auto;padding:16px;position:relative;width:70vw}.p-debug .animation{background-color:red;height:200px;width:200px}.p-debug .animation.active{-webkit-animation:silde 10s infinite;animation:silde 10s infinite}.c-header{align-items:center;background-color:#fff;border-bottom:2px solid #eaecef;display:flex;height:48px;left:0;padding:8px 16px;position:fixed;top:0;width:100%;z-index:1000}.c-header>*{cursor:pointer;font-size:18px;font-weight:600;margin-right:18px}.c-header>:last-child{margin-left:auto;margin-right:0}.c-nav{min-height:calc(100vh - 48px);overflow:auto;padding:16px 16px 16px 0;position:-webkit-sticky;position:sticky;top:48px}.c-nav .file-item{display:block;margin:8px 0;white-space:nowrap}.c-nav .file-item.fold>.file-name:after{border-color:transparent transparent transparent #ccc;border-style:solid;border-width:6px 0 6px 9px;content:"";display:inline-block;height:0;margin-left:8px;transition:all .2s ease-out;width:0}.c-nav .file-item.fold.expand>.file-name:after{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.c-nav .file-item.fold.expand>.child-list{display:block}.c-nav .file-name{border-left:4px solid transparent;color:#2c3e50;cursor:pointer;display:block;font-size:16px;font-weight:700;margin-bottom:12px;padding-left:16px;position:relative}.c-nav .file-name.light{color:#3eaf7c;font-size:18px}.c-nav .child-list{display:none;margin:0;padding-left:16px;transition:all .2s ease-out}.c-layout-sidebar-content{display:flex;position:relative}.c-layout-sidebar-content .article-wrap{flex:1 1 auto}.c-layout-nav{border-right:2px solid #eaecef;max-width:300px;min-width:200px}

/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{-webkit-text-size-adjust:100%;line-height:1.15}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;margin:0;outline:0;padding:0}body,html{font-family:Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}p{line-height:1.5}a{color:#2c3e50;text-decoration:none}a:hover{text-decoration:underline}.page{padding-top:48px}.g-desc{color:#7f8fa4;font-size:14px}.icon-arrow{border-color:transparent transparent transparent blue;border-style:solid;border-width:44.5px 0 44.5px 118px;height:0;width:0}.icon-font{fill:currentColor;overflow:hidden;vertical-align:-.15em}.page-home-excerpt{background-color:#9cc;border:1px solid transparent;border-radius:6px;margin-bottom:24px;padding:16px}.page-home-excerpt-header{margin-bottom:4px}.page-home-excerpt-header-title{font-size:18px;font-weight:700}.page-home-excerpt-header-desc{color:#7f8fa4;font-size:14px;margin-left:8px}.page-home-excerpt-text{font-size:16px}.page-article-template .article-title-wrap{border-left:2px solid #eaecef;min-width:10%}.page-article-template .article-title-wrap .item{font-size:14px;font-weight:500}.page-article-template .article-title-wrap .item a{pointer-events:none}.page-article-template .article-title-list{padding:8px;position:-webkit-sticky;position:sticky;top:48px}.page-article-template .article-title-list .item{cursor:pointer;list-style:none;margin-bottom:12px}.page-article-template .article-title-list .item:hover{color:#3eaf7c;text-decoration:underline}.article-wrap{padding:0 8px 0 24px}.article-wrap h1{border-bottom:2px solid blue;font-size:16px;margin:36px 0}.article-wrap h2,.article-wrap h3,.article-wrap h4,.article-wrap h5,.article-wrap h6{border-bottom:2px solid blue;font-size:18px;margin:24px 0}.article-wrap div,.article-wrap p{margin:8px 0}.article-wrap a{color:#0969da}.article-wrap>:not(ul){margin-left:-14px}.article-wrap li{margin:8px 0}.article-wrap li ol,.article-wrap li ul{margin-left:12px}.article-wrap ol{margin-left:3px}.article-wrap blockquote{background-color:#fff5e3;border-left:.25em solid #ffb11b;color:#57606a;padding-left:24px}.article-wrap blockquote>p{margin-left:-16px}.article-wrap code{background-color:#fff5e3;border-radius:2px;color:#9b6e23;margin:0 2px;padding:3px 5px;white-space:nowrap}.article-wrap img{box-shadow:0 0 80px -30px rgba(0,0,0,.5)!important}.article-wrap table{border-collapse:collapse;border-spacing:0}.article-wrap table td,.article-wrap table th{background-color:#1f2329;border-bottom:1px solid rgba(220,223,230,.3);border-right:1px solid rgba(220,223,230,.3);color:#fff;padding:8px 16px;text-align:left}.article-title-wrap,.article-wrap{counter-reset:h1}.article-title-wrap h1,.article-wrap h1{counter-reset:h2}.article-title-wrap h1:before,.article-wrap h1:before{content:counter(h1) ". ";counter-increment:h1}.article-title-wrap h2,.article-wrap h2{counter-reset:h3}.article-title-wrap h2:before,.article-wrap h2:before{content:counter(h1) "." counter(h2) ". ";counter-increment:h2}.article-title-wrap h3,.article-wrap h3{counter-reset:h4}.article-title-wrap h3:before,.article-wrap h3:before{content:counter(h1) "." counter(h2) "." counter(h3) ". ";counter-increment:h3}.article-title-wrap h4,.article-wrap h4{counter-reset:h5}.article-title-wrap h4:before,.article-wrap h4:before{content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) ". ";counter-increment:h4}.article-title-wrap h5,.article-wrap h5{counter-reset:h6}.article-title-wrap h5:before,.article-wrap h5:before{content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) ". ";counter-increment:h5}.article-title-wrap h6:before,.article-wrap h6:before{content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) "." counter(h6) ". ";counter-increment:h6}</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="c-layout-wrap  page page-article-template"><header class="c-header"><a href="/">首页</a><a href="/">博客</a><a href="https://zlong1010.github.io/vue-components/#/" target="_blank" rel="noreferrer noopener">vue组件指令</a><a href="/debug/">Debug</a><a href="https://github.com/zlong1010" target="_blank" rel="noreferrer noopener"><svg class="icon-font" width="24px" height="24px" aria-hidden="true"><use href="#icon-font-github1"></use></svg></a></header><div class="c-layout-sidebar-content "><div class="c-layout-nav "><div class="c-nav"><div class="file-item fold false"><div class="file-name" role="button">Vue</div><ul class="child-list"><a class="file-name false" href="/articles/Vue/vue2源码/">vue2源码</a><a class="file-name false" href="/articles/Vue/vue基础概念/">vue基础概念</a><a class="file-name false" href="/articles/Vue/PWA/">PWA</a><a class="file-name false" href="/articles/Vue/Vue技术栈/">Vue技术栈</a><a class="file-name false" href="/articles/Vue/总结/">总结</a><a class="file-name false" href="/articles/Vue/Vue视频资料/">Vue视频资料</a><a class="file-name false" href="/articles/Vue/服务端渲染/">服务端渲染</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">博客</div><ul class="child-list"><a class="file-name false" href="/articles/博客/Gatsby建站/">Gatsby建站</a><a class="file-name false" href="/articles/博客/指南/">指南</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">React</div><ul class="child-list"><a class="file-name false" href="/articles/React/React基础/">React基础</a><a class="file-name false" href="/articles/React/React总结/">React总结</a><a class="file-name false" href="/articles/React/React技术栈/">React技术栈</a><a class="file-name false" href="/articles/React/TODO/">TODO</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">服务端</div><ul class="child-list"><a class="file-name false" href="/articles/服务端/基础/">基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">网络</div><ul class="child-list"><a class="file-name false" href="/articles/网络/HTTP/">HTTP</a><a class="file-name false" href="/articles/网络/代理/">代理</a><a class="file-name false" href="/articles/网络/服务端/">服务端</a><a class="file-name false" href="/articles/网络/网络基础/">网络基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">数据算法</div><ul class="child-list"><a class="file-name false" href="/articles/数据算法/数据结构基础/">数据结构基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">前端</div><ul class="child-list"><div class="file-item fold false"><div class="file-name" role="button">JS</div><ul class="child-list"><a class="file-name false" href="/articles/前端/JS/ES6/">ES6</a><a class="file-name false" href="/articles/前端/JS/总结/">总结</a><a class="file-name false" href="/articles/前端/JS/JS基础/">JS基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">HTML-CSS</div><ul class="child-list"><a class="file-name false" href="/articles/前端/HTML-CSS/HTML基础/">HTML基础</a><a class="file-name false" href="/articles/前端/HTML-CSS/CSS基础/">CSS基础</a><a class="file-name false" href="/articles/前端/HTML-CSS/总结/">总结</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">前端工程化</div><ul class="child-list"><a class="file-name false" href="/articles/前端/前端工程化/Babel/">Babel</a><a class="file-name false" href="/articles/前端/前端工程化/Gulp/">Gulp</a><a class="file-name false" href="/articles/前端/前端工程化/Webpack/">Webpack</a><a class="file-name false" href="/articles/前端/前端工程化/npm/">npm</a><a class="file-name false" href="/articles/前端/前端工程化/图标/">图标</a><a class="file-name false" href="/articles/前端/前端工程化/打包工具/">打包工具</a><a class="file-name false" href="/articles/前端/前端工程化/模块/">模块</a><a class="file-name false" href="/articles/前端/前端工程化/私有源/">私有源</a></ul></div><a class="file-name false" href="/articles/前端/前端调试/">前端调试</a><a class="file-name false" href="/articles/前端/webView/">webView</a><a class="file-name false" href="/articles/前端/总结/">总结</a><a class="file-name false" href="/articles/前端/前端资源整理/">前端资源整理</a><a class="file-name false" href="/articles/前端/浏览器/">浏览器</a><a class="file-name false" href="/articles/前端/练题/">练题</a><a class="file-name false" href="/articles/前端/规范/">规范</a><a class="file-name false" href="/articles/前端/设计模式/">设计模式</a></ul></div><a class="file-name false" href="/articles/Git/">Git</a><a class="file-name false" href="/articles/Linux命令/">Linux命令</a><a class="file-name false" href="/articles/TS基础/">TS基础</a><a class="file-name false" href="/articles/vue3/">vue3</a><a class="file-name false" href="/articles/微前端/">微前端</a><a class="file-name false" href="/articles/WebRTC/">WebRTC</a><a class="file-name false" href="/articles/爬虫/">爬虫</a></div></div><article class="article-wrap"><h2 id="t-0" >如何定义一个类型，或得到一个类型？</h2>
<ul>
<li>
<p><code>keyof</code> 后面跟一个类型，获取该类型的所有 key，产生联合类型。
<code>typeof</code> 后面跟一个变量，获取变量的类型。</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">type State = Readonly&lt;typeof initialState&gt;;</code>
        </deckgo-highlight-code>
</li>
<li>
<p>类型别名</p>
<deckgo-highlight-code language="tsx" terminal="carbon" theme="blackboard"  >
          <code slot="code">type Props = { 
 onClick(e: MouseEvent&lt;HTMLElement&gt;): void
 children?: ReactNode 
}
 
type RenderCallback = (args: ToggleableComponentProps) =&gt; JSX.Element;</code>
        </deckgo-highlight-code>
<p><strong><code>type</code> 和 <code>interface</code> 的区别？</strong></p>
</li>
<li>
<p><strong>类型断言</strong></p>
<deckgo-highlight-code language="tsx" terminal="carbon" theme="blackboard"  >
          <code slot="code">const initialState = {name: &#39;&#39;}
type State = Readonly&lt;typeof initialState&gt;</code>
        </deckgo-highlight-code>
</li>
<li>
<p>查找类型
从已有的类型中查找</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">const initialState = {
  show: false,
};
type State = Readonly&lt;typeof initialState&gt;;
type ToggleableComponentProps = {
  show: State[&#39;show&#39;];
};</code>
        </deckgo-highlight-code>
</li>
<li>
<p>从实现中推断类型</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">type ToggleableComponentProps = {
  toggle: Toggleable[&#39;toggle&#39;];
  // Toggleable 本来就是类型，不能是变量
};

export class Toggleable extends Component&lt;Props, State&gt; {
  readonly state: State = initialState;
  render() {
    // 
  }
  private toggle = (event: MouseEvent&lt;HTMLElement&gt;) =&gt; this.setState(updateShowState);
}</code>
        </deckgo-highlight-code>
</li>
</ul>
<h2 id="t-1" ><code>ReactNode</code> 、 <code>ReactElement</code> 和 <code>JSX.Element</code> 的区别？</h2>
<ul>
<li><code>children?: React.ReactNode </code></li>
</ul>
<h1 id="t-2" >概况</h1>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 621px; ">
      <a class="gatsby-resp-image-link" href="/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png" style="display: block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom: 71.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACuklEQVQ4y32Ta28aRxSG94/3W9Xf0KpS+6FN3TpWjO0a2/iixCEOEDCYa2RDzYKXhV32fr/xVKwhcqq2M3q0Z45m33nnzIxwdnrG4cEhpbMSxeMT9t8UeL27R7VaQ5JmyDMZeTZnMVdQ5grqQmWpLFmqGpqmoWs6ur7GQDdMhKVhYDjOFyzPw/Y9TNdBty10287z67HpulhrPBfb8/D8AD/YEuYIURyzbiv48t3GL9t/5f6JEIZRHmSrVU66ev51PFcp1Ttc3nbRLDvPbef8H0IYRV+tmm0ExcWSwrsqB+8qGI77r4IvjWy7ICtLdq4q/FG6ZiROeF1u8r7e4n4qc1DpclRpIz5JHFda/Fm5I96UKNuIPYu+3HIQcNcb0Oj0kGcSzW6f4eMjk8mE6l2Hym0TWZboD0e0e30c28L1XNI4zIXTLPvKpdAYPHBcrpGkCcUPddoPj5iOw+7FNZqh0/trTPGmjh/4nNeaVDt95KXG7mWZhW5s3G7LkCHU2gP2L8s4nsvJxwbvb9vIqsovxQskRaE7GnN0XcFybE4+fuJTt49mWfx2esVwLJKlCUHowyrLxQVFUbl/GG7uQUIYeCRpTOg/H4S8mDOeiHn8KI5RliphHNHq9ZirKtVmi6EoUu90mc4XCDvnZb75eQ/DMonTJHcSRCGa+bydN+U63746ZDKT+G7niF9P3yIpKj8USlzVGvxYOONV8YLvD875/fQK4WH8RLU9IE3TvAZxtLaf4m8cjqYS9f5nojiiMbhnOJmiOw77b29QTRN/fUBpgm2bxHGEkIQRrmWTJglP8oxyq0ft84hGt0eSxFiWiWObpFmKbZlEoc9YkvmpcMJQnGAYOrbrYJhGPkcI1u/QCwgCn6k8o3DTZK98y4dmJ3dpr9+3Y+P5HrZj5/iBl9c6DIN87LgOQRjk1+ZvAk4QuOg/yRkAAAAASUVORK5CYII='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="image-20200820171028681" title="image-20200820171028681" src="/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png" srcset="/static/2d5d45cf184dbee81bfeca5b3846a42f/772e8/image-20200820171028681.png 200w,
/static/2d5d45cf184dbee81bfeca5b3846a42f/e17e5/image-20200820171028681.png 400w,
/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png 621w" sizes="(max-width: 621px) 100vw, 621px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy" decoding="async">
  </a>
    </span>  
<img src="assets/TS%E5%9F%BA%E7%A1%80/image-20201114122155270.png" alt="image-20201114122155270" style="zoom:50%;" />  
<p>上面的是父级，下面是子级，子级类型可以赋值给父级。</p>
<p><strong>TypeScript体系</strong></p>
<p><strong>值 、变量 和 类型</strong></p>
<ul>
<li>类型的标注/推导确定</li>
<li>类型的检查，检查数据类型是否安全</li>
</ul>
<h1 id="t-3" >TS资源</h1>
<ul>
<li><a href="https://www.typescriptlang.org/docs/home.html">官网</a>  <a href="https://www.tslang.cn/">中文</a></li>
<li><a href="https://ts.xcatliu.com/">TS入门教程-阮一峰</a></li>
<li><a href="https://zhongsp.gitbook.io/typescript-handbook/">非官方中文版</a></li>
<li><a href="https://jkchao.github.io/typescript-book-chinese/#why">深入理解TS</a></li>
</ul>
<h1 id="t-4" >泛型参数组件</h1>
<ul>
<li>
<p>类组件定义及使用</p>
<deckgo-highlight-code language="tsx" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 定义泛型参数的组件
class GenericComponent&lt;P&gt; extends React.Component&lt;P&gt; {
  internalProp: P;
  constructor(props: P) {
    super(props);
    this.internalProp = props;
  }
  render() {
    return null;
  }
}

type Props = { a: number; b: string };

&lt;GenericComponent&lt;Props&gt; a={10} b=&quot;hi&quot; /&gt;; // OK
&lt;GenericComponent&lt;Props&gt; a={10} b={20} /&gt;; // Error</code>
        </deckgo-highlight-code>
</li>
<li>
<p>函数式组件</p>
<deckgo-highlight-code language="tsx" terminal="carbon" theme="blackboard"  >
          <code slot="code">function GenericComponent&lt;P&gt;(props: P) {
  const internalProp = useRef(props)
  return null;
}</code>
        </deckgo-highlight-code>
</li>
<li>
<p>箭头函数</p>
<deckgo-highlight-code language="tsx" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 这样会解析错误
const GenericComponent = &lt;P&gt;(props: P) =&gt;{
  const internalProp = useRef(props);
  return null;
}

// 泛型必须使用extends关键字才能解析
const GenericComponent = &lt;P extends any&gt;(props: P) =&gt;{
  const internalProp = useRef(props);
  return null;
}</code>
        </deckgo-highlight-code>
</li>
</ul>
<h1 id="t-5" >关键字</h1>
<p>extends ：ts 中的 extends 理解为扩展更合适，用 <code>&#x26; </code> 可以实现和 <code>extends</code> 类似的效果。</p>
<p>implements：在 TypeScript 中，<code>implements</code>操作只是为<code>class</code>提供一种类型约束。</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">interface Alarm {
  alert(): void;
}
class Door {
}

class SecurityDoor extends Door implements Alarm,接口B {
  alert() {
    console.log(&#39;SecurityDoor alert&#39;);
  }
}

class Car implements Alarm {
  alert() {
    console.log(&#39;Car alert&#39;);
  }
}</code>
        </deckgo-highlight-code>
<ul>
<li>
<p>example</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">(&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];  // 类型断言


interface Padder {
    getPaddingString(): string
}
class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
        return Array(this.numSpaces + 1).join(&quot; &quot;);
    }
}</code>
        </deckgo-highlight-code>
</li>
<li>
<p>使用类型断言手动去除某个类型中的<code>null</code>和<code>undefined</code></p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">name!.charAt(0)  // name为undefined 时会报错,!的意思是显式告诉编译器name不会为undefined

name?.charAt(0) // name为undefined 时不会报错</code>
        </deckgo-highlight-code>
</li>
<li>
<p>函数类型</p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">export interface ThemeContextValue {
  theme: Theme;
  onThemeChange: (theme: Theme) =&gt; void;
  handleClick?(e: React.MouseEvent&lt;HTMLElement&gt;):void;
}</code>
        </deckgo-highlight-code>
</li>
</ul>
<h2 id="t-6" >extends</h2>
<p>使用 extends 给泛型添加约束</p>
<p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">interface ILengthwise {
  length: number;
}
function loggingIdentity&lt;T extends ILengthwise&gt;(arg: T): T {
  console.log(arg.length);
  return arg;
}

// 这时我们需要传入符合约束类型的值，必须包含必须的属性：
loggingIdentity(3);  // Error, number doesn&#39;t have a .length property
loggingIdentity({length: 10, value: 3});</code>
        </deckgo-highlight-code>
<h1 id="t-7" >参考</h1>
<ul>
<li><a href="https://ts.xcatliu.com/basics/primitive-data-types.html">原始数据类型</a></li>
<li><a href="https://ts.xcatliu.com/basics/any.html">任意值</a></li>
<li><a href="https://ts.xcatliu.com/basics/type-inference.html">类型推论</a></li>
<li><a href="https://ts.xcatliu.com/basics/union-types.html">联合类型</a></li>
<li><a href="https://ts.xcatliu.com/basics/type-of-object-interfaces.html">对象的类型——接口</a></li>
<li><a href="https://ts.xcatliu.com/basics/type-of-array.html">数组的类型</a></li>
<li><a href="https://ts.xcatliu.com/basics/type-of-function.html">函数的类型</a></li>
<li><a href="https://ts.xcatliu.com/basics/type-assertion.html">类型断言</a></li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html">声明文件</a></li>
<li><a href="https://ts.xcatliu.com/basics/built-in-objects.html">内置对象</a></li>
</ul>
<h1 id="t-8" >数据类型</h1>
<blockquote>
<p>类型是值的集合</p>
<p>Undefined  只有<code>undefined</code>一个元素的集合</p>
<p>Null  只有<code>null</code>一个元素的集合</p>
<p>Boolean  有两个元素<code>false</code>和<code>true</code>的集合</p>
<p>...</p>
</blockquote>
<p><strong>指定变量的类型</strong></p>
<ul>
<li>
<p>使用接口（Interfaces）来定义对象的类型</p>
</li>
<li>
<p>指定变量为函数</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">interface Cat {
  name: string;
  run(): void;
  onBlur?: (value: string, e?: React.FocusEvent&lt;HTMLInputElement&gt;) =&gt; void;
}

listener: (ev: MouseEvent) =&gt; any  // 指定listener 是一个函数，同时指定该函数的输入输出类型

let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {
    return x + y;
};</code>
        </deckgo-highlight-code>
</li>
</ul>
<p>TS简单的说就是为JS中的变量指定了类型，JS中的变量本身是没有类型的，比如：</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">let x = 1;
x = &#39;anc&#39;;
x = [1,2,3];</code>
        </deckgo-highlight-code>
<p>上述中变量<code>x</code>既可以存储数字也可以存储字符串，JS中的某一个变量可以存储任意类型的值。有了TS就可以为变量指定一个类型，这样在编译阶段就可以检查变量是否赋予了正确的类型，提前发现错误，配合编辑器的语法提示能有效提高开发效率。</p>
<p>TS中描述类型的方法有：</p>
<ol>
<li>
<p>原始类型: numble  string   Boolean</p>
</li>
<li>
<p>字面量类型：123  'abc'</p>
</li>
<li>
<p>接口：描述一类对象的类型，例如：</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">interface IPerson{
  name: string;
  age: number
}

let me: IPerson = {
  name: &#39;abc&#39;,
  aeg: 10
}
let you: IPerson = {
  name: 12,  // 报错：name必须是string
}
// 报错 you 必须同时包含 name 和 age 两个属性</code>
        </deckgo-highlight-code>
<p>上述代码定义了一个名为<code>IPerson</code>的接口来表示'人'这一类对象的类型，如果某个对象被指定为<code>IPerson</code>这种类型，那这个对象就必须符合<code>IPerson</code>描述的特征，即包含<code>name</code>和<code>age </code>两个属性。</p>
</li>
<li>
<p>别名
与接口不同，接口定义了一种新的类型，别名只是对现有的类型声明了新的名字，别名通常与字面量类型、联合类型、交叉类型、泛型使用，例如：</p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 为string起一个别名Name，
type Name = string;
let myName:Name = &#39;abc&#39;;

// 等号右边是字符串字面量类型，Easing是这个字面量类型的别名
type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;
let easing: Easing = &#39;ease-in&#39;;
let easing: Easing = &#39;other&#39;; // 报错
// easing这个变量只能被赋值为&quot;ease-in&quot; 或 &quot;ease-out&quot; 或 &quot;ease-in-out&quot;这三个字符串中的一个，赋值为其他值就会报错</code>
        </deckgo-highlight-code>
</li>
<li>
<p><code>never</code>  <code>undefined</code>   <code>null</code>
<code>never</code>  <code>undefined</code>   <code>null</code> 是TS中三中特殊的类型</p>
<ul>
<li><code>never</code> 表示永远不存在的值的类型，即这个类型没有对应的值</li>
<li><code>undefined</code>这个类型只有一个值，就是<code>undefined</code></li>
<li><code>null</code>与<code>undefined</code>同理</li>
</ul>
</li>
<li>
<p>联合类型
多个类型的或运算，逆 <code>extends</code> ，生成的类型是参与运算的类型的父类型。</p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 声明了NumOrStr为一个联合类型
type NumOrStr = sting | number;

let x: NumOrStr = 1; // success
x = &#39;abc&#39;; // success
x = [1]; // error</code>
        </deckgo-highlight-code>
</li>
<li>
<p>交叉类型
和并多个类型</p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">type Parent1 = {
  name: string;
}
type Parent2 = {
  age: number;
}
type Child = Parent1 &amp; Parent2;

// 子级类型可以赋值给父类型(属性只能多不能少)
let my: Parent1 = {
  age: 2,
  name: &#39;&#39;
}</code>
        </deckgo-highlight-code>
</li>
<li>
<p>泛型：对类型的进一步抽象，与模板的概念相似，例如：</p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 定义一个泛型函数
function logging&lt;T&gt;(arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}

// 分别使用number 和 string 指定泛型的类型
logging&lt;number&gt;([1,2,3]); // ok
loggin&lt;string&gt;([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]); // ok</code>
        </deckgo-highlight-code>
</li>
</ol>
<h1 id="t-9" >接口</h1>
<blockquote>
<p>使用接口（Interfaces）来定义对象的类型，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。除了可用于<a href="https://ts.xcatliu.com/advanced/class-and-interfaces.html#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p>
</blockquote>
<ul>
<li>
<p>demo</p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: &#39;Tom&#39;,
    age: 25
};

// 有时候我们希望一个接口允许有任意的属性，可以使用如下方式
interface Person {
    name: string;
    age?: number; // 可选
    [propName: string]: string | number; // 任意属性，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集。 
}

let tom: Person = {
    name: &#39;Tom&#39;,
    gender: &#39;male&#39;
};
</code>
        </deckgo-highlight-code>
</li>
<li>
<p>使用接口定义类数组数据</p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">function sum() {
    let args: {
        [index: number]: number;
        length: number;
        callee: Function;
    } = arguments;
}</code>
        </deckgo-highlight-code>
</li>
</ul>
<h2 id="t-10" >接口继承</h2>
<p>接口是一个类型，接口可以继承类和其他interface(包括自定义类)。
接口继承类的时候，只会继承它的实例属性和实例方法。</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">interface ApiError extends Error {
  code: number;
}</code>
        </deckgo-highlight-code>
<p><a href="https://ts.xcatliu.com/advanced/class-and-interfaces.html">https://ts.xcatliu.com/advanced/class-and-interfaces.html</a></p>
<h2 id="t-11" >interface 和 type 的区别</h2>
<p>​    1)  interface 可以用于 extends 和 implements，type 不能；</p>
<p>​    2)  <code>type</code> 可以声明联合、交叉类型，interface 不能；</p>
<p>​    3)  <code>type</code> 可以与 <code>typeof </code> 联用，从变量值推断类型；</p>
<p>​    4)  interface 存在声明合并的情况，可以用来重在函数，详解：<a href="https://www.tslang.cn/docs/handbook/declaration-merging.html">https://www.tslang.cn/docs/handbook/declaration-merging.html</a></p>
<h1 id="t-12" >泛型</h1>
<blockquote>
<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
</blockquote>
<ul>
<li>
<p>demo</p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {
    let result: T[] = [];
    for (let i = 0; i &lt; length; i++) {
        result[i] = value;
    }
    return result;
}

createArray&lt;string&gt;(3, &#39;x&#39;);</code>
        </deckgo-highlight-code>
</li>
<li>
<p>数组泛型</p>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code>
        </deckgo-highlight-code>
</li>
</ul>
<h1 id="t-13" >内置高级泛型</h1>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">// extends 表示类型约束
function copy&lt;T extends BaseType&gt;(arg: T): T {
  return arg;
}
// 条件类型
type Extract&lt;T, U&gt; = T extends U ? T : never;</code>
        </deckgo-highlight-code>
<ul>
<li>
<p>内置高级类型泛型： <code>Partial Required Pick Exclude Omit</code></p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 将所有接口变为可选
type Partial&lt;T&gt; = { [P in keyof T]?: T[P] };

// 将所有接口变为必选
type Required&lt;T&gt; = { [P in keyof T]-?: T[P] };

// 从 T 中取出 一系列 K 的属性
type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P] };

type Readonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
};

/**
 * Exclude from T those types that are assignable to U
 * T 是联合类型？
 */
type Exclude&lt;T, U&gt; = T extends U ? never : T;

/**
 * Extract from T those types that are assignable to U
 */
type Extract&lt;T, U&gt; = T extends U ? T : never;

/**
 * Construct a type with the properties of T except for those in type K.
 */
type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code>
        </deckgo-highlight-code>
</li>
<li>
<p><code>Record</code> :  <code>Record&#x3C;K extends keyof any, T></code> 的作用是将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型。</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">type Record&lt;K extends keyof any, T&gt; = {
    [P in K]: T;
};


interface PageInfo {
  title: string;
}
type Page = &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;;

const x: Record&lt;Page, PageInfo&gt; = {
  about: { title: &quot;about&quot; },
  contact: { title: &quot;contact&quot; },
  home: { title: &quot;home&quot; }
};</code>
        </deckgo-highlight-code>
</li>
<li>
<p>Pick：从类型 T 中选中部分，得到选中的类型</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">type Pick&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P];
};</code>
        </deckgo-highlight-code>
</li>
<li>
<p>Exclude：从类型 T 中剔除部分类型，得到剩余的类型</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">type Exclude&lt;T, U&gt; = T extends U ? never : T;</code>
        </deckgo-highlight-code>
</li>
<li>
<p>Extract：从类型 T 中提取部分，得到提取的</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">type Extract&lt;T, U&gt; = T extends U ? T : never;</code>
        </deckgo-highlight-code>
</li>
<li>
<p>ReturnType：用于获取函数 <code>T</code> 的返回类型。</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</code>
        </deckgo-highlight-code>
</li>
</ul>
<p>参考：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&#x26;mid=2247484142&#x26;idx=1&#x26;sn=946ba90d10e2625513f09e60a462b3a7&#x26;scene=19#wechat_redirect">TS内置高级泛型</a></p>
<h1 id="t-14" >声明文件</h1>
<ul>
<li>
<p>demo.d.ts</p>
<deckgo-highlight-code language="tsx" terminal="carbon" theme="blackboard"  >
          <code slot="code">export declare enum ButtonsPopoverConfigIconType {
    XiaoSen = &quot;XiaoSen&quot;,
    Scan = &quot;Scan&quot;,
    AppStore = &quot;AppStore&quot;,
    Setting = &quot;Setting&quot;
}
export interface ButtonsPopoverConfig {
    positionX: number;
    buttons: Array&lt;{
        iconType: ButtonsPopoverConfigIconType;
        title: string;
    }&gt;;
}

export declare function openButtonsPopover(cfg: ButtonsPopoverConfig): Promise&lt;ButtonsPopoverResult&gt;;

// 暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 namespace 下
declare namespace jQuery {
  interface AjaxSettings {
    method?: &#39;GET&#39; | &#39;POST&#39;
    data?: any;
  }
  function ajax(url: string, settings?: AjaxSettings): void;
}</code>
        </deckgo-highlight-code>
</li>
<li>
<p>声明合并：当一个变量有多种类型时(如：jQuery 既可以作为函数被调用也可以作为对象)
可以组合多个声明语句，它们会合并起来。</p>
<deckgo-highlight-code language="tsx" terminal="carbon" theme="blackboard"  >
          <code slot="code">declare function jQuery(selector: string): any;
declare namespace jQuery {
    function ajax(url: string, settings?: any): void;
}  </code>
        </deckgo-highlight-code>
</li>
</ul>
<h1 id="t-15" >TS &#x26; React</h1>
<h2 id="t-16" >内置类型</h2>
<p>React源码</p>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">type ComponentType&lt;P = {}&gt; = ComponentClass&lt;P&gt; | FunctionComponent&lt;P&gt;;</code>
        </deckgo-highlight-code>
<deckgo-highlight-code language="ts" terminal="carbon" theme="blackboard"  >
          <code slot="code">interface ReactDOM extends ReactHTML, ReactSVG { }

interface ReactElement&lt;P = any, T extends string | JSXElementConstructor&lt;any&gt; = string | JSXElementConstructor&lt;any&gt;&gt; {
type: T;
props: P;
key: Key | null;
}

type ReactElement = ReactComponentElement | ReactDOMElement;

interface ReactComponentElement&lt;
T extends keyof JSX.IntrinsicElements | JSXElementConstructor&lt;any&gt;,
P = Pick&lt;ComponentProps&lt;T&gt;, Exclude&lt;keyof ComponentProps&lt;T&gt;, &#39;key&#39; | &#39;ref&#39;&gt;&gt;
&gt; extends ReactElement&lt;P, Exclude&lt;T, number&gt;&gt; { }


type ReactText = string | number;
type ReactChild = ReactElement | ReactText;

type ReactFragment = {} | ReactNodeArray;

type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;

interface ReactNodeArray extends Array&lt;ReactNode&gt; {}

//------------------------------------------------------
interface ReactDOM extends ReactHTML, ReactSVG { }
// ReactHIML:  a\h\div等

type ReactNode = ReactElement | ReactFragment | ReactText;

// type ReactElement = ReactComponentElement | ReactDOMElement;

interface ReactDOM extends ReactHTML, ReactSVG { }

type ReactDOMElement = {
type : string,
props : {
  children : ReactNodeList,
  className : string,
  etc.
},
key : string | boolean | number | null,
ref : string | null
};

type ReactComponentElement&lt;TProps&gt; = {
type : ReactClass&lt;TProps&gt;,
props : TProps,
key : string | boolean | number | null,
ref : string | null
};

type ReactFragment = Array&lt;ReactNode | ReactEmpty&gt;;

type ReactNodeList = ReactNode | ReactEmpty;

type ReactText = string | number;

type ReactEmpty = null | undefined | boolean;</code>
        </deckgo-highlight-code>
<p><strong><a href="https://gist.github.com/sebmarkbage/fcb1b6ab493b0c77d589">React Virtual DOM 术语</a></strong></p>
<ul>
<li>ReactElement</li>
<li>ReactNode</li>
</ul>
<p>一些<code>React</code>的内置类型</p>
<ul>
<li><code>React.ReactElement</code> —— 使用<code>React.createElement</code>创建的，可以简单理解为<code>React</code>中的<code>JSX</code>的元素</li>
<li><code>React.ReactNode</code> —— <code>&#x3C;div>xxx&#x3C;/div></code> xxx的合法类型</li>
<li><code>React.ReactDOM</code></li>
<li></li>
<li><code>React.CSSProperties</code> —— 组件内联的<code>style</code>对象的类型</li>
<li><code>React.RefObject</code> —— <code>React.createRef</code>创建的类型，只读不可改</li>
<li><code>React.MutableRefObject</code> —— <code>useRef</code>创建的类型，可以修改</li>
</ul>
<p><strong>内置事件类型</strong></p>
<ul>
<li>
<p><code>React.MouseEventHandler&#x3C;HEMLInputElement></code></p>
</li>
<li>
<p><code>React.ChangeEventHandler&#x3C;HTMLInputElement></code></p>
</li>
<li>
<p><code>React.FocusEventHandler&#x3C;HTMLInputElement></code></p>
</li>
<li>
<p>无状态组件</p>
<deckgo-highlight-code  terminal="carbon" theme="blackboard"  >
          <code slot="code">
import { SFC } from &#39;react&#39;
import { MouseEvent } from &#39;react&#39;
import * as React from &#39;react&#39;
interface IProps {
  onClick (event: MouseEvent&lt;HTMLDivElement&gt;): void,
}
const Button: SFC&lt;IProps&gt; = ({onClick, children}) =&gt; {
  return (
    &lt;div onClick={onClick}&gt;
      { children }
    &lt;/div&gt;
  )
}
export default Button</code>
        </deckgo-highlight-code>
</li>
<li>
<p>函数组件
函数组件定义的方式有两种：</p>
<ol>
<li>使用<code>React.FC</code></li>
</ol>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">interface IProps {
  value: string;
  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void
  // 使用React.FC定义函数式组件时不用声明children
}
const App: React.FC&lt;IProps&gt; = (props)=&gt;{
  return &lt;div&gt;{children}&lt;/div&gt;
}</code>
        </deckgo-highlight-code>
<ol start="2">
<li>使用接口定义<code>props</code></li>
</ol>
<deckgo-highlight-code language="typescript" terminal="carbon" theme="blackboard"  >
          <code slot="code">interface IProps{
  value: string;
  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void
  children?: React.ReactNode; // 需要自己定义children的类型
}
function App(props:IProps){
  return &lt;div&gt;{children}&lt;/div&gt;
}</code>
        </deckgo-highlight-code>
</li>
</ul></article><div class="article-title-wrap"><div class="article-title-list"><h2 data-id="0" class="item">如何定义一个类型，或得到一个类型？</h2><h2 data-id="1" class="item"><code>ReactNode</code> 、 <code>ReactElement</code> 和 <code>JSX.Element</code> 的区别？</h2><h1 data-id="2" class="item">概况</h1><h1 data-id="3" class="item">TS资源</h1><h1 data-id="4" class="item">泛型参数组件</h1><h1 data-id="5" class="item">关键字</h1><h2 data-id="6" class="item">extends</h2><h1 data-id="7" class="item">参考</h1><h1 data-id="8" class="item">数据类型</h1><h1 data-id="9" class="item">接口</h1><h2 data-id="10" class="item">接口继承</h2><h2 data-id="11" class="item">interface 和 type 的区别</h2><h1 data-id="12" class="item">泛型</h1><h1 data-id="13" class="item">内置高级泛型</h1><h1 data-id="14" class="item">声明文件</h1><h1 data-id="15" class="item">TS &#x26; React</h1><h2 data-id="16" class="item">内置类型</h2></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/articles/TS基础/";window.___webpackCompilationHash="5207d3255268461d308d";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-38bff700e245e8493772.js"],"app":["/app-10896d9b1e770b1c82d9.js"],"component---src-pages-404-js":["/component---src-pages-404-js-a1cb840e6fe8c403c00b.js"],"component---src-pages-debug-jsx":["/component---src-pages-debug-jsx-19f27fb8a0713cec9f30.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-392a422209c4ea736eb4.js"],"component---src-pages-other-js":["/component---src-pages-other-js-9c6c2b81a35ac0392fee.js"],"component---src-pages-repos-jsx":["/component---src-pages-repos-jsx-26466ebc98dbcc9c1590.js"],"component---src-templates-post-js":["/component---src-templates-post-js-3b0ec7b578ab953404c3.js"]};/*]]>*/</script><script src="/polyfill-38bff700e245e8493772.js" nomodule=""></script><script src="/app-10896d9b1e770b1c82d9.js" async=""></script><script src="/framework-00aa2f30c053856ae873.js" async=""></script><script src="/webpack-runtime-2ac7a3f3baa60b4ab834.js" async=""></script></body></html>