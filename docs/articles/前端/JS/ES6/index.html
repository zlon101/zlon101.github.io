<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.22.0"/><style data-href="/styles.91e060046c9149377d22.css" data-identity="gatsby-global-css">@-webkit-keyframes silde{0%{background-color:green}50%{background-color:blue}to{background-color:red}}@keyframes silde{0%{background-color:green}50%{background-color:blue}to{background-color:red}}.p-debug{margin:40px auto 0;outline:1px solid red;overflow:auto;padding:16px;position:relative;width:70vw}.p-debug .animation{background-color:red;height:200px;width:200px}.p-debug .animation.active{-webkit-animation:silde 10s infinite;animation:silde 10s infinite}.c-header{align-items:center;background-color:#fff;border-bottom:2px solid #eaecef;display:flex;height:48px;left:0;padding:8px 16px;position:fixed;top:0;width:100%;z-index:1000}.c-header>*{cursor:pointer;font-size:18px;font-weight:600;margin-right:18px}.c-header>:last-child{margin-left:auto;margin-right:0}.c-nav{max-height:calc(100vh - 48px);overflow:auto;padding:16px 16px 16px 0;position:-webkit-sticky;position:sticky;top:48px}.c-nav .file-item{display:block;margin:8px 0;white-space:nowrap}.c-nav .file-item.fold>.file-name:after{border-color:transparent transparent transparent #ccc;border-style:solid;border-width:6px 0 6px 9px;content:"";display:inline-block;height:0;margin-left:8px;transition:all .2s ease-out;width:0}.c-nav .file-item.fold.expand>.file-name:after{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.c-nav .file-item.fold.expand>.child-list{display:block}.c-nav .file-name{border-left:4px solid transparent;color:#2c3e50;cursor:pointer;display:block;font-size:16px;font-weight:700;margin-bottom:12px;padding-left:16px;position:relative}.c-nav .file-name.light{color:#3eaf7c;font-size:18px}.c-nav .child-list{display:none;margin:0;padding-left:16px;transition:all .2s ease-out}.c-layout-sidebar-content{display:flex;position:relative}.c-layout-sidebar-content .article-wrap{flex:1 1 auto}.c-layout-nav{border-right:2px solid #eaecef;max-width:300px;min-width:200px}

/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{-webkit-text-size-adjust:100%;line-height:1.15}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;margin:0;outline:0;padding:0}body,html{font-family:Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}p{line-height:1.5}a{color:#2c3e50;text-decoration:none}a:hover{text-decoration:underline}.page{padding-top:48px}.g-desc{color:#7f8fa4;font-size:14px}.icon-arrow{border-color:transparent transparent transparent blue;border-style:solid;border-width:44.5px 0 44.5px 118px;height:0;width:0}.icon-font{fill:currentColor;overflow:hidden;vertical-align:-.15em}.page-home-excerpt{background-color:#9cc;border:1px solid transparent;border-radius:6px;margin-bottom:24px;padding:16px}.page-home-excerpt-header{margin-bottom:4px}.page-home-excerpt-header-title{font-size:18px;font-weight:700}.page-home-excerpt-header-desc{color:#7f8fa4;font-size:14px;margin-left:8px}.page-home-excerpt-text{font-size:16px}.page-article-template .article-title-wrap{border-left:2px solid #eaecef;min-width:10%}.page-article-template .article-title-wrap .item{font-size:14px;font-weight:500}.page-article-template .article-title-wrap .item a{pointer-events:none}.page-article-template .article-title-list{max-height:calc(100vh - 48px);overflow:auto;padding:8px;position:-webkit-sticky;position:sticky;top:48px}.page-article-template .article-title-list .item{cursor:pointer;list-style:none;margin-bottom:12px}.page-article-template .article-title-list .item:hover{color:#3eaf7c;text-decoration:underline}.article-wrap{padding:0 8px 0 24px}.article-wrap h1{border-bottom:2px solid blue;font-size:16px;margin:36px 0}.article-wrap h2,.article-wrap h3,.article-wrap h4,.article-wrap h5,.article-wrap h6{border-bottom:2px solid blue;font-size:18px;margin:24px 0}.article-wrap div,.article-wrap p{margin:8px 0}.article-wrap a{color:#0969da}.article-wrap>:not(ul){margin-left:-14px}.article-wrap li{margin:8px 0}.article-wrap li ol,.article-wrap li ul{margin-left:12px}.article-wrap ol{margin-left:3px}.article-wrap blockquote{background-color:#fff5e3;border-left:.25em solid #ffb11b;color:#57606a;padding-left:24px}.article-wrap blockquote>p{margin-left:-16px}.article-wrap code{background-color:#fff5e3;border-radius:2px;color:#9b6e23;margin:0 2px;padding:3px 5px;white-space:nowrap}.article-wrap img{box-shadow:0 0 80px -30px rgba(0,0,0,.5)!important}.article-wrap table{border-collapse:collapse;border-spacing:0}.article-wrap table td,.article-wrap table th{background-color:#1f2329;border-bottom:1px solid rgba(220,223,230,.3);border-right:1px solid rgba(220,223,230,.3);color:#fff;padding:8px 16px;text-align:left}.article-title-wrap,.article-wrap{counter-reset:h1}.article-title-wrap h1,.article-wrap h1{counter-reset:h2}.article-title-wrap h1:before,.article-wrap h1:before{content:counter(h1) ". ";counter-increment:h1}.article-title-wrap h2,.article-wrap h2{counter-reset:h3}.article-title-wrap h2:before,.article-wrap h2:before{content:counter(h1) "." counter(h2) ". ";counter-increment:h2}.article-title-wrap h3,.article-wrap h3{counter-reset:h4}.article-title-wrap h3:before,.article-wrap h3:before{content:counter(h1) "." counter(h2) "." counter(h3) ". ";counter-increment:h3}.article-title-wrap h4,.article-wrap h4{counter-reset:h5}.article-title-wrap h4:before,.article-wrap h4:before{content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) ". ";counter-increment:h4}.article-title-wrap h5,.article-wrap h5{counter-reset:h6}.article-title-wrap h5:before,.article-wrap h5:before{content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) ". ";counter-increment:h5}.article-title-wrap h6:before,.article-wrap h6:before{content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) "." counter(h6) ". ";counter-increment:h6}</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="c-layout-wrap  page page-article-template"><header class="c-header"><a href="/">首页</a><a href="/">博客</a><a href="https://zlon101.github.io/npm-lib/#/" target="_blank" rel="noreferrer noopener">vue组件库</a><a href="/debug/">Debug</a><a href="https://github.com/zlon101" target="_blank" rel="noreferrer noopener"><svg class="icon-font" width="24px" height="24px" aria-hidden="true"><use href="#icon-font-github1"></use></svg></a></header><div class="c-layout-sidebar-content "><div class="c-layout-nav "><div class="c-nav"><div class="file-item fold false"><div class="file-name" role="button">React</div><ul class="child-list"><a class="file-name false" href="/articles/React/React基础/">React基础</a><a class="file-name false" href="/articles/React/开发环境配置/">开发环境配置</a><a class="file-name false" href="/articles/React/React总结/">React总结</a><a class="file-name false" href="/articles/React/TODO/">TODO</a><a class="file-name false" href="/articles/React/React技术栈/">React技术栈</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">Vue</div><ul class="child-list"><a class="file-name false" href="/articles/Vue/PWA/">PWA</a><a class="file-name false" href="/articles/Vue/vue2源码/">vue2源码</a><a class="file-name false" href="/articles/Vue/vue基础概念/">vue基础概念</a><a class="file-name false" href="/articles/Vue/Vue技术栈/">Vue技术栈</a><a class="file-name false" href="/articles/Vue/Vue视频资料/">Vue视频资料</a><a class="file-name false" href="/articles/Vue/总结/">总结</a><a class="file-name false" href="/articles/Vue/服务端渲染/">服务端渲染</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">前端</div><ul class="child-list"><div class="file-item fold false"><div class="file-name" role="button">HTML-CSS</div><ul class="child-list"><a class="file-name false" href="/articles/前端/HTML-CSS/CSS基础/">CSS基础</a><a class="file-name false" href="/articles/前端/HTML-CSS/HTML基础/">HTML基础</a><a class="file-name false" href="/articles/前端/HTML-CSS/总结/">总结</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">JS</div><ul class="child-list"><a class="file-name false" href="/articles/前端/JS/ES6/">ES6</a><a class="file-name false" href="/articles/前端/JS/总结/">总结</a><a class="file-name false" href="/articles/前端/JS/JS基础/">JS基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">前端工程化</div><ul class="child-list"><a class="file-name false" href="/articles/前端/前端工程化/Babel/">Babel</a><a class="file-name false" href="/articles/前端/前端工程化/Gulp/">Gulp</a><a class="file-name false" href="/articles/前端/前端工程化/npm/">npm</a><a class="file-name false" href="/articles/前端/前端工程化/Webpack/">Webpack</a><a class="file-name false" href="/articles/前端/前端工程化/图标/">图标</a><a class="file-name false" href="/articles/前端/前端工程化/打包工具/">打包工具</a><a class="file-name false" href="/articles/前端/前端工程化/模块/">模块</a><a class="file-name false" href="/articles/前端/前端工程化/私有源/">私有源</a></ul></div><a class="file-name false" href="/articles/前端/前端调试/">前端调试</a><a class="file-name false" href="/articles/前端/webView/">webView</a><a class="file-name false" href="/articles/前端/前端资源整理/">前端资源整理</a><a class="file-name false" href="/articles/前端/微前端/">微前端</a><a class="file-name false" href="/articles/前端/总结/">总结</a><a class="file-name false" href="/articles/前端/练题/">练题</a><a class="file-name false" href="/articles/前端/浏览器/">浏览器</a><a class="file-name false" href="/articles/前端/规范/">规范</a><a class="file-name false" href="/articles/前端/设计模式/">设计模式</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">前端工程化</div><ul class="child-list"><a class="file-name false" href="/articles/前端工程化/Babel/">Babel</a><a class="file-name false" href="/articles/前端工程化/Gulp/">Gulp</a><a class="file-name false" href="/articles/前端工程化/npm/">npm</a><a class="file-name false" href="/articles/前端工程化/Monorepo/">Monorepo</a><a class="file-name false" href="/articles/前端工程化/Webpack/">Webpack</a><a class="file-name false" href="/articles/前端工程化/打包工具/">打包工具</a><a class="file-name false" href="/articles/前端工程化/图标/">图标</a><a class="file-name false" href="/articles/前端工程化/模块/">模块</a><a class="file-name false" href="/articles/前端工程化/私有源/">私有源</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">博客</div><ul class="child-list"><a class="file-name false" href="/articles/博客/Gatsby建站/">Gatsby建站</a><a class="file-name false" href="/articles/博客/指南/">指南</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">数据算法</div><ul class="child-list"><a class="file-name false" href="/articles/数据算法/数据结构基础/">数据结构基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">服务端</div><ul class="child-list"><a class="file-name false" href="/articles/服务端/基础/">基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">网络</div><ul class="child-list"><a class="file-name false" href="/articles/网络/HTTP/">HTTP</a><a class="file-name false" href="/articles/网络/代理/">代理</a><a class="file-name false" href="/articles/网络/数据安全/">数据安全</a><a class="file-name false" href="/articles/网络/服务端/">服务端</a><a class="file-name false" href="/articles/网络/爬虫/">爬虫</a><a class="file-name false" href="/articles/网络/网络基础/">网络基础</a></ul></div><a class="file-name false" href="/articles/Git/">Git</a><a class="file-name false" href="/articles/Linux命令/">Linux命令</a><a class="file-name false" href="/articles/TS基础/">TS基础</a><a class="file-name false" href="/articles/vue3/">vue3</a><a class="file-name false" href="/articles/小程序/">小程序</a><a class="file-name false" href="/articles/微前端/">微前端</a><a class="file-name false" href="/articles/爬虫/">爬虫</a><a class="file-name false" href="/articles/跨平台开发/">跨平台开发</a></div></div><article class="article-wrap"><blockquote>
<p><a href="https://es6.ruanyifeng.com/#docs/class">ES6入门-阮一峰</a></p>
</blockquote>
<h1 id="t-0" >变量声明</h1>
<blockquote>
<p>var 特点</p>
</blockquote>
<p>声明函数作用域或全局作用域变量</p>
<p>可以重复声明</p>
<p>存在声明提升</p>
<blockquote>
<p><a href="https://github.com/febobo/web-interview/issues/34">const let 特点</a></p>
</blockquote>
<ol>
<li>const 和 let 都不存在变量提升，都存在暂时性死区</li>
</ol>
<p><strong>暂时性死区</strong>：let 和 const 声明的变量从进入块级作用域就绑定了，不能在 let 或 const 声明语句之前使用 var 或者 没有 var 声明及使用该变量。因此在 let 和 const 声明语句之前(死区)不能以任何形式出现该变量，并且 typeof 也不是一定安全的操作(在没有 let 和 const 之前，typeof 一定不会产生错误)。</p>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<ol start="2">
<li>
<p>不能重复声明</p>
</li>
<li>
<p>var 声明的全局变量作为顶层对象( window\global )的属性，let 和 const 声明的变量不会；</p>
</li>
<li>
<p>块级作用域中的函数声明</p>
</li>
</ol>
<p>ES5 规定函数声明只能在全局或函数作用域中，不能在块级作用域(ES5 没有块级作用域)，但浏览器没有遵守该规定，ES5 环境下，在块级作用域中声明的函数存在声明提升，等同于函数表达式(声明提升，值为 undefined)；</p>
<p>ES6 引入块级作用域，允许在块级作用域中声明函数；</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// ES6严格模式
&#39;use strict&#39;;
if (true) {
 function f() {}
}
// 不报错</code>
        </deckgo-highlight-code>
<p>ES6 规定块级作用域中的函数声明语句的行为类似于 let，在块级作用域之外不可引用；</p>
<p>为了减少兼容性问题，浏览器可以不遵守 ES6 的规定，在 ES6 环境下的浏览器中的行为方式：</p>
<p>可以在块级作用域中声明函数，但会像对待 var 语句一样(而不是 let)，将函数的声明提升至函数作用域的顶部(只是声明，尚未赋值)；在块级作用域中该函数都是可用的。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// ES6的浏览器环境, 此处为全局作用域
function f() { 
 console.log(&#39;I am outside!&#39;);
}
(function () {
 // 此处为函数作用域
 // var f = undefined; 该语句是块级作用域中的函数声明部分提升至此;
 typeof f;           // undefined
 if (true) {
   // 此处为块级作用域, 在该作用域中函数是可以访问的;
   f();             // 输出 xx indide
   function f() { console.log(&#39;I am inside!&#39;); }
 }
 f();               // 输出 inside
}());</code>
        </deckgo-highlight-code>
<p><strong>总结：</strong></p>
<ul>
<li>避免在块级作用域中声明函数，如果要声明也建议使用函数表达式而不是函数声明语句；</li>
<li>ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</li>
</ul>
<ol start="4">
<li>const 声明复杂数据类型</li>
</ol>
<p>const 声明复合类型的变量，变量名指向数据的地址，因此 const 只保证该地址不会改变，但地址中的数据可以被改变；</p>
<p>使用 Object.freeze(obj) 冻结 obj 对象；</p>
<h1 id="t-1" >全局对象 &#x26; 顶层对象</h1>
<blockquote>
<p>获取全局对象的三种方式：window、global、self</p>
</blockquote>
<ol>
<li>global 只在 node 中才支持；</li>
<li>window 只在浏览器环境中支持；</li>
<li>self 在浏览器和 web worker 中支持；</li>
</ol>
<blockquote>
<p>不同环境中 this 的指向：</p>
</blockquote>
<ol>
<li>全局环境 this 指向全局对象，</li>
<li>node 模块和 ES6 模块中，this 指向当前模块；</li>
<li>函数中，指向调用对象或顶层对象、undefined(严格模式)；</li>
</ol>
<blockquote>
<p>勉强能获取不同环境中的 全局对象</p>
</blockquote>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function getGlobal() {
  return global || self;
}</code>
        </deckgo-highlight-code>
<p>在语言标准层面引入 global 作为顶层对象，即在所有环境中都存在 global 对象，垫片库<a href="https://github.com/ljharb/System.global"><code>system.global</code></a>模拟了该方法，可以在所有环境拿到 <code>global</code>。</p>
<h1 id="t-2" >变量的解构赋值</h1>
<ul>
<li>从引用类型变量中提取部分数据(数组元素、对象属性值)赋值给新的变量；</li>
<li>变量：复杂数据类型的变量(数组、对象)，要求是可遍历的结构，具有 Iterator 接口；</li>
<li>赋值遵守模式匹配；</li>
</ul>
<p>数组和对象的解构赋值是一种<strong>模式匹配</strong>，要求等号两边的模式相匹配。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">let {bar: bar, foo: foo} = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
// 简写为
let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
import {xx} from &#39;xxx&#39;;
let { log, sin, cos } = Math;

let foo;
({foo} = {foo: 1});     // 成功, 必须用()包裹, 否则将被解析为代码块而不是赋值语句;只有不将大括号写在行首，避免JavaScript将其解释为代码块

var obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};
var { p: [x, { y }] } = obj;  // x: &quot;Hello&quot;, y: &quot;World&quot;</code>
        </deckgo-highlight-code>
<blockquote>
<p>应用</p>
</blockquote>
<ol>
<li>交换变量的值</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">[x, y] = [y, x];</code>
        </deckgo-highlight-code>
<ol start="2">
<li>函数返回多个值</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function example() {
 return [1, 2, 3];
}
var [a, b, c] = example();</code>
        </deckgo-highlight-code>
<ol start="3">
<li>函数参数</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});

function ({mapState, content}){
   // ...
}</code>
        </deckgo-highlight-code>
<ol start="4">
<li>函数默认参数</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};</code>
        </deckgo-highlight-code>
<ol start="5">
<li>导入模块的指定方法</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code>
        </deckgo-highlight-code>
<h1 id="t-3" >扩展运算符</h1>
<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组；</p>
<ul>
<li>数组合并</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">let arr1 = [1,2];
let arr2 = [3,4];
let arr3 = [...arr1, ...arr2];
// arr3 = [1,2,3,4]</code>
        </deckgo-highlight-code>
<ul>
<li>和解构赋值同时使用</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">let arr = [1,2,3];
let [first, ...rest] = arr;
// first = 1; rest = [2,3]</code>
        </deckgo-highlight-code>
<h1 id="t-4" >标签模板</h1>
<p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为【标签模板】功能（tagged template）。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">alert`123`;  // 调用alert 处理后面的字符串; 弹出 123;

// styled-components
styled.dic`
	margin: 0 auto;
`;</code>
        </deckgo-highlight-code>
<h1 id="t-5" >数组扩展</h1>
<p><strong>类数组对象</strong>：本质特征就是要有 length 属性；</p>
<ul>
<li>将类数组对象和可遍历对象转换为数组</li>
</ul>
<ol>
<li>
<p>Array.from：可以转换类数组对象和可遍历对象；</p>
</li>
<li>
<p><strong>扩展运算符</strong>：将数组转换为逗号分隔的列表，背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换；<code>[...arguments]</code>，扩展运算符后面跟的一定是数组(或类数组)；</p>
</li>
<li>
<p>像 <code>{length: 2}</code> 这个对象就只能使用 <code>Array.from</code> 转换；</p>
</li>
</ol>
<ul>
<li>得到初始化的数组</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">Array.from({length: 5}, (v, i) =&gt; i);   // [0,1,2,3,4]
Array.from({length: 3}, ele=&gt;0);        // [0,0,0]
new Array(3).fill(0);  // // [0,0,0]</code>
        </deckgo-highlight-code>
<blockquote>
<p>数组扩展的内容</p>
</blockquote>
<ol>
<li>Array.from</li>
<li>Array.of</li>
<li>实例的 copyWithin</li>
<li>实例的 find() 、 findIndex() 和 fill();</li>
<li>实例的 keys()、values() 和 entries()；返回遍历器对象；</li>
<li>实例的 includes()</li>
<li>数组的空位</li>
</ol>
<p>参考：<a href="http://caibaojian.com/es6/array.html">数组扩展</a></p>
<h1 id="t-6" >函数的扩展</h1>
<ol>
<li>参数的默认值</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
// 推荐第一种
m1({x: 1});  // [1, 0]
m2({x: 1});  // [1, undefined]</code>
        </deckgo-highlight-code>
<ol start="2">
<li>length 属性：默认参数之前的参数的个数(预期传入的参数的个数)</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function fn(a, b=0, c){
    //...
}
// fn.length: 1</code>
        </deckgo-highlight-code>
<ol start="3">
<li>剩余参数：必须位于参数列表的最后</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function fn(...args){
  // args 是一个数组    
}</code>
        </deckgo-highlight-code>
<ol start="4">
<li>箭头函数</li>
</ol>
<p>部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">const pipeline = (...funcs) =&gt; initVal =&gt; funcs.reduce((acc, cur) =&gt; cur(acc), initVal);

const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;
const addThenMult = pipeline(plus1, mult2);

console.log( addThenMult(2) ); // 6</code>
        </deckgo-highlight-code>
<ol start="5">
<li>函数绑定运算符(::)</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);
// 运算符左侧是指定的 this 对象, 右侧是函数</code>
        </deckgo-highlight-code>
<ol start="6">
<li>严格模式</li>
</ol>
<p>《ECMAScript 2016标准》规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。严格模式下也不能使用 arguments 和 callers</p>
<ol start="7">
<li>尾调用优化</li>
</ol>
<p>ES6 下的<strong>尾调用优化</strong>只在严格模式下才有效；</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 将调用函数的操作放到当前函数执行的最后一步
function fn(){
    &quot;use strict&quot;
    return g();
}
function fn(){
    // 当前函数满足尾调用
    if(xx){
        return g();
    }
    else  return w();
}

// 下式不是尾调用优化, 因为函数默认 return undefined;
function fn(){
    g();
    // return undefined;
}</code>
        </deckgo-highlight-code>
<p>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行【尾调用优化】。下面的函数无法实现尾调用优化。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}</code>
        </deckgo-highlight-code>
<p><strong>尾递归优化示例</strong></p>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 1. 阶乘
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}
// 优化后
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

// 2. fibonacci 
function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}
// 优化后
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}</code>
        </deckgo-highlight-code>
<p><a href="http://caibaojian.com/es6/function.html">函数扩展</a></p>
<h1 id="t-7" >Class</h1>
<blockquote>
<p>例子</p>
</blockquote>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">class Person{
  static staticProA = &#39;xxx&#39;;
  static staticMethodA() {
    // this 指向 Person，而不是实例
  }
  constructor(name, age){
    this.name = name;
    this.age = age;
  }
  getName(){
    return this.name;
  }
}
/*
* this 指向实例对象,
* 类的方法(getName)定义在类的prototype(Person.prototype)上, 并且不可枚举;
* 方法之间不需要逗号,
*/</code>
        </deckgo-highlight-code>
<blockquote>
<p>constructor</p>
</blockquote>
<p>类必须有一个 constructor 方法，若没有显示定义，默认的 constructor 为 <code>constructor(){}</code></p>
<blockquote>
<p>super</p>
</blockquote>
<ol>
<li>在super方法调用前，不能使用this，因为 ES6 是先创建父类实例；</li>
<li>作为函数调用，super 代表父类的构造函数，此时父类构造函数中的 <code>new.target</code> 为子类构造函数，并且作为函数调用时只能出现在子类的构造函数中；</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">class A {}

class B extends A {
  constructor() {
    super();
    // 相当于 A.prototype.constructor.call(this);
  }
 }</code>
        </deckgo-highlight-code>
<ol start="3">
<li>作为对象时，super 指向父类的原型，ES6 规定通过 <code>super</code> 调用父类的方法时，<code>super</code> 会绑定子类的<code>this</code>。</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    this.name = &#39;czl&#39;;
    console.log(super.p()); // 调用 A的 方法, 该方法中的this 指向子类的实例,可以访问 this.name
  }
  p(){
 		return 100;
  }
}</code>
        </deckgo-highlight-code>
<blockquote>
<p>静态属性和静态方法</p>
</blockquote>
<p>父类中的静态属性和静态方法可以被子类继承</p>
<blockquote>
<p>私有属性</p>
</blockquote>
<p>私有属性不能被继承</p>
<p>私有属性名必须在类实例和类本身上是唯一标识</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields</a></p>
<p><a href="https://zh.javascript.info/private-protected-properties-methods">https://zh.javascript.info/private-protected-properties-methods</a></p>
<blockquote>
<p>ES6 中Class 与 ES5 的区别</p>
</blockquote>
<ul>
<li>函数存在声明提升，Class 不会；</li>
<li>类内部默认开启严格模式；</li>
<li>ES5 继承先创建子类实例，再调用父类构造函数，将属性和方法添加到子类实例上；ES6 是先创建父类实例，再通过子类的构造函数修改 this；</li>
<li>Class 定义在原型上的方法是不可枚举的；</li>
<li>Class 实现了子类的构造函数继承父类的构造函数（继承静态属性和方法）</li>
</ul>
<h1 id="t-8" >Proxy</h1>
<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种<strong>元编程</strong>，即对编程语言进行编程。<strong>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</strong>。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<ol>
<li>get(target, propKey, receiver)
拦截对象属性的读取；</li>
<li>set(target, propKey, value, receiver)
拦截对象属性的赋值操作；</li>
<li>has(target, propKey)
拦截<code>propKey in proxy</code>的操作；</li>
<li>apply(target, object, args)
<code>apply</code>方法拦截函数的调用、call和apply操作；</li>
</ol>
<blockquote>
<p>this 指向</p>
</blockquote>
<p>使用 Proxy 代理的情况下，目标对象内部的 <code>this</code> 关键字会指向 Proxy 代理。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">const target = {
  m: function () {
    console.log(this === proxy);
  }
};
const handler = {};
const proxy = new Proxy(target, handler);

target.m() // false
proxy.m()  // true</code>
        </deckgo-highlight-code>
<blockquote>
<p>使用 Proxy 实现观察者模式</p>
</blockquote>
<p>观察者模式（Observer mode）指的是观察者(函数)自动观察被观察者(数据对象)，一旦对象有变化，函数就会自动执行。</p>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">const person = observable({
  name: &#39;张三&#39;,
  age: 20
});
function print() {
  console.log(`${person.name}, ${person.age}`)
}

observe(print);
person.name = &#39;李四&#39;;  // // 李四, 20

/*
* observable 和 observe 实现;
* observable 注册被观察者(数据对象);
* obsere 注册观察者(数据更新时执行的函数);
*/ 

// 观察者(函数)
const queuedObservers = new Set();

const observe = fn =&gt; queuedObservers.add(fn);
const observable = obj =&gt; new Proxy(obj, {set});

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  return result;
}</code>
        </deckgo-highlight-code>
<blockquote>
<p><a href="https://github.com/GoogleChrome/proxy-polyfill">proxy-polyfill</a></p>
</blockquote>
<h1 id="t-9" >Reflect</h1>
<blockquote>
<p>使用 Reflect 来将操作转发给原始对象</p>
</blockquote>
<p><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code> 怎么修改默认行为，你总可以在 <code>Reflect</code> 上获取默认行为。</p>
<p><strong>对于每个可被 <code>Proxy</code> 捕获的内部方法，在 <code>Reflect</code> 中都有一个对应的方法，其名称和参数与 <code>Proxy</code> 捕捉器相同。</strong></p>
<h1 id="t-10" >Iterator &#x26; 遍历器</h1>
<p>遍历器生成函数接收一个可选的数据结构(如数组)，返回一个遍历器对象，该对象必须要有 <code>next</code> 方法，调用该函数会返回指定的数据结构中的下一个元素。for...of 根据遍历器对象依次访问元素。</p>
<ul>
<li>
<p><strong>可遍历数据</strong>：部署了 iterator 接口，原生的数组、部分类数组对象、Set、Map的 <code>Symbol.iterator</code> 属性就是遍历器生成函数，最简单的实现方式就是 generator 函数。</p>
</li>
<li>
<p>for...of、扩展运算符、解构赋值。</p>
</li>
</ul>
<h1 id="t-11" >Promise</h1>
<ul>
<li>
<p>Promise是异步编程的一种解决方案，比传统的解决方案—<strong>回调函数和事件</strong>更合理和更强大；</p>
</li>
<li>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。Promise提供then方法加载回调函数，使用then方法以后，异步任务的两段执行看得更清楚了；</p>
</li>
<li>
<p>Promise就是为了解决回调地狱而提出的，它不是新的语法功能，而是一种<strong>新的写法</strong>，允许将回调函数的嵌套，改成链式调用；</p>
</li>
<li>
<p>Promise 创建后会立即执行</p>
</li>
</ul>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">let promise = new Promise(function(resolve, reject) {
  // 需要执行的异步操作, 立即执行
  // 异步操作失败时执行 reject, 成功执行 resolve,
  // resolve 和 reject 会将数据以实参的形式传递出去;
  console.log(&#39;Promise&#39;);
  setTimeout(resolve, ms, &#39;done&#39;);  
});</code>
        </deckgo-highlight-code>
<ul>
<li><code>then</code> 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</li>
</ul>
<h2 id="t-12" >Promise 读取文件</h2>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">let read = require(&#39;read-file&#39;);
function readFile(name) {
  return new Promise((resolve, reject) =&gt; {
    // 1. 第1步
    read(name, &#39;utf-8&#39;, (error, data) =&gt; {
      if (error) reject(error);
      else resolve(data);
    });
  });
}

readFile(&#39;name2.txt&#39;)
	// 2. 第2步
  .then(data =&gt; readFile(data))
	// 3. 第3步
  .then(data =&gt; {  		
      console.log(`1-s: ${data}`);
      return 123;
    },
    error =&gt; {
      console.log(`1-e: ${error}`);
      return 0;
    })	
  .then(data =&gt; console.log(`2-s: ${data}`),
    error =&gt; console.log(`2-e: ${error}`))
  .then(data =&gt; console.log(`3-s: ${data}`),
    error =&gt; console.log(`3-e: ${error}`));
/*
 执行流程
 1. 执行第一步, 通过 resolve(data) 或 reject(error) 传递数据, 并且返回一个 promise 实例;
 2. 执行第二步, 根据上一步是成功或失败, 执行 then 的成功回调或失败回调; 如果上一步返回的是 promise 实例,
    则回调函数的参数来自于 resolve(data) 或 reject(error) 的实参;
    如果上一步返回的不是 promise 实例, 则回调函数的参数来自于上一步 return 的值。 
*/</code>
        </deckgo-highlight-code>
<h2 id="t-13" >参考</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&#x26;mid=2247484260&#x26;idx=1&#x26;sn=0bc8a7aed8b15d3cc7e75c76394b648a&#x26;chksm=c06682f2f7110be41b29ce0eabc441fba11e1ab306ca40e4e7d81d338b4af7e35721573d1cca&#x26;mpshare=1&#x26;scene=1&#x26;srcid=&#x26;sharer_sharetime=1566171898757&#x26;sharer_shareid=c0fa4bb765d12545f4439ab827814978&#x26;key=56eb82a42460d979c3afc63a4f31177e13db16329cf4763c707bf96642e8906b81d68c0b03fa52eaabde20326b79c31368a9de23b389122e084df4a3c4aa327001973a319a1020fe8e99f6a26930b5b9&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060833&#x26;lang=zh_CN&#x26;pass_ticket=D8igzih7KnA8%2F5LHQdRG6th5IVXvvQD7ukUD5HSt%2FLcfZ7gOforYJWqBjo9rYF%2FC">你了解Promise吗-segmentfault</a></li>
<li><a href="https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4">Promse A+ 规范</a></li>
<li><a href="https://juejin.im/post/5b83cb5ae51d4538cc3ec354">Promise 实现原理-掘金</a></li>
</ul>
<h1 id="t-14" >Generator</h1>
<p>Generator函数是ES6提供的一种异步编程解决方案，执行Generator函数会返回一个<strong>遍历器对象</strong>，即 Generator 是迭代器生成函数。</p>
<p>从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>
<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>
<p>Generator函数有多种理解角度：</p>
<ul>
<li>
<p>Generator函数是一个状态机，封装了多个内部状态。</p>
</li>
<li>
<p>形式上，Generator函数是一个普通函数，但是有两个特征。</p>
<ol>
<li><code>function</code> 关键字与函数名之间有一个星号；</li>
<li>函数体内部使用 <strong>yield</strong> 语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。</li>
</ol>
</li>
<li>
<p>例如</p>
</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function* foo(x) {
  log(&#39;start&#39;);
  var y = 2 * (yield (x + 1));
  var z = yield (y);
  return (x + y + z);
}
var hw = foo(1);  // 执行该行不会输出 start
hw.next();   // { value: 2, done: false }
hw.next(3);  // { value: 6, done: false }</code>
        </deckgo-highlight-code>
<blockquote>
<p>yield</p>
</blockquote>
<ul>
<li>遇到 <code>yield</code> 语句，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值。</li>
<li>yield 表达式(如：yield(x+1)) 的返回值是 undefined，通过 hw.next(val)可以设置上次 yield 表达式的返回值；</li>
</ul>
<p style="color:red;font-weight:bold">核心：yield 暂停执行，next 继续执行</p>
<blockquote>
<p>返回值: iterator 遍历器对象</p>
</blockquote>
<p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的<code>prototype</code>对象上的方法。</p>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">function* g() {};
g.prototype.hello = function () {
  return &#39;hi!&#39;;
};

let iter = g();

iter instanceof g // true
iter.hello()      // &#39;hi!&#39;
// 生成器函数g()返回的迭代器对象 iter 是 g 的实例，并且继承了 g.prototype 上的方法;
// g() 类似于构造函数, 但又不是，g() 返回的不是 this, this === global;</code>
        </deckgo-highlight-code>
<blockquote>
<p>将 Generator 封装为构造函数并 在 Generator 中使用 this</p>
</blockquote>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">function* gen() {
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
}

function F() {
  return gen.call(gen.prototype);
}

var f = new F();

f.next();  // Object {value: 2, done: false}
f.next();  // Object {value: 3, done: false}
f.next();  // Object {value: undefined, done: true}</code>
        </deckgo-highlight-code>
<blockquote>
<p><code>yield*</code></p>
</blockquote>
<p><code>yield*</code> 遍历遍历器对象，任何有 Iterator 接口的数据结构都可以被 <code>yield*</code> 遍历</p>
<p>用来在一个Generator函数里面执行另一个Generator函数。</p>
<h2 id="t-15" >异步 Generator</h2>
<p>异步 Generator 生成 异步的 Iterator ，异步 Iterator 的 next() 方法返回的是一个 Promise</p>
<p>异步 Generator 的 yield 产出的是 Promise 对象或 Thunk ，即异步生成器创建的迭代器的 next() 方法返回的是 Promise</p>
<h2 id="t-16" >应用</h2>
<ol>
<li>异步操作的同步表达；</li>
<li>控制流管理；</li>
<li>部署 Iterator 接口；</li>
<li>作为数据结构：类数组结构</li>
</ol>
<blockquote>
<p>遍历二叉树</p>
</blockquote>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 下面是二叉树的构造函数，
// 三个参数分别是左树、当前节点和右树
function Tree(left, label, right) {
  this.left = left;
  this.label = label;
  this.right = right;
}

// 下面是中序（inorder）遍历函数。
// 由于返回的是一个遍历器，所以要用generator函数。
// 函数体内采用递归算法，所以左树和右树要用yield*遍历
function* inorder(t) {
  if (t) {
    yield* inorder(t.left);
    yield t.label;
    yield* inorder(t.right);
  }
}

// 下面生成二叉树
function make(array) {
  // 判断是否为叶节点
  if (array.length == 1) return new Tree(null, array[0], null);
  return new Tree(make(array[0]), array[1], make(array[2]));
}
let tree = make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]);

// 遍历二叉树
var result = [];
for (let node of inorder(tree)) {
  result.push(node);
}</code>
        </deckgo-highlight-code>
<blockquote>
<p>参考</p>
</blockquote>
<p><a href="http://caibaojian.com/es6/generator.html">Generatot函数</a></p>
<h1 id="t-17" >async &#x26; await</h1>
<p><strong>async 函数就是 Generator 函数的语法糖</strong>。用 <code>async</code> 替换 Generator 函数声明中的 <code>*</code>，用 <code>await</code> 替换 <code>yield</code></p>
<p>await 命令只能出现在 async 函数中，await 表达式会暂停当前 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function"><code>async function</code></a> 的执行，等待其后面表达式的结果，像 Generateor 函数一样将执行权转让给其他程序；</p>
<ul>
<li>async 定义一个通过事件循环异步执行的异步函数，该函数隐式返回一个 Promise 对象，可以用<code>then</code>方法指定下一步的操作。</li>
<li><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数；</li>
<li><code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</li>
<li><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，才会执行<code>then</code>方法指定的回调函数，除非遇到<code>return</code>语句或者抛出错误。</li>
</ul>
<blockquote>
<p>result = await 表达式</p>
</blockquote>
<p>When an <code>await</code> is encountered in code (either in an async function or in a module), the awaited expression is executed, while all code that depends on the expression's value is paused and pushed into the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">microtask queue</a>. The main thread is then freed for the next task in the event loop. This happens even if the awaited value is an already-resolved promise or not a promise.</p>
<p>当在 async 函数或 module 顶层中遇到 await 运算符，await 后面的表达式立即执行，await 语句后面的语句加入到【微任务】队列中，即使 await 表达式是 already-resolved promise or not a promise。</p>
<ul>
<li>
<p>await 等待一个Promise对象，await 表达式的值就是 Promise 处理的结果，若表达式不是 Promise，</p>
</li>
<li>
<p>则返回表达式本身的值；</p>
</li>
<li>
<p>await 会暂停异步函数(async 函数)的执行（无论表示的是否是 Promise-like），调用async函数的上层函数会继续执行(收到异步函数返回的隐式Promise)</p>
</li>
<li>
<p>若 await 后面的表达式的值不是 Promise 或 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables">thneables</a> ，则用 Promise.resolve() 包装
If the value is not a <code>Promise</code>, <code>await</code> converts the value to a resolved <code>Promise</code>, and waits for it.</p>
</li>
<li>
<p>若 await 后面的表达式的值是Promise，且 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function"><code>async function</code></a>。</p>
</li>
<li>
<p>若 await 后面的表达式的值是Promise，且  Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。所以最好将await命令放在<code>try catch</code>中</p>
</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">async function myFunction() {
  try {
    await somethingThatReturnsAPromise();
  } catch (err) {
    console.log(err);
  }
}</code>
        </deckgo-highlight-code>
<blockquote>
<p>async 实现</p>
</blockquote>
<p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function spawn(genF) {
  return new Promise(function (resolve, reject) {
    const gen = genF();
    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch (e) {
        return reject(e);
      }
      if (next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(
        function (v) {
          step(function () {
            return gen.next(v);
          });
        },
        function (e) {
          step(function () {
            return gen.throw(e);
          });
        }
      );
    }
    
    step(function () {
      return gen.next(undefined);
    });
  });
}</code>
        </deckgo-highlight-code>
<blockquote>
<p>参考</p>
</blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">MDN-aync</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">MDN-await</a></li>
<li><a href="https://segmentfault.com/a/1190000007535316">理解 JavaScript 的 async/await</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&#x26;mid=2650215577&#x26;idx=1&#x26;sn=0edb4be37430e17ba1029ab3b1a36a57&#x26;chksm=befe14b889899daea69684da9ac22613cfef5e534f920a194a640f21ab5ec839d498642ed455&#x26;scene=0&#x26;key=6deb43fc298651d2935752bd2c9f8fa907d71cfcf410807341a1a420ced46efe20f453fa8f835874ef05bec5deefb1be9a1a136a7027e798b32030bded88d257b46b8f1442a2b56ac165cfaa80db49f5&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060720&#x26;lang=zh_CN&#x26;pass_ticket=Pn9cJyIWK2xt%2BmQltkMddf4S5oGoplFdiJ%2B16Yj6gD8L9Zd0WMlQ1u32%2FRJtZE1p">async &#x26; await 面试题</a></li>
<li><a href="https://gongchenghuigch.github.io/2019/09/14/awat/">setTimeout promise async</a></li>
</ul>
<h1 id="t-18" >异步编程</h1>
<p>ES6诞生以前，异步编程的方法，大概有下面四种：回调、事件监听、Promise对象</p>
<p><a href="http://caibaojian.com/es6/async.html">异步编程</a></p>
<h1 id="t-19" >模块</h1>
<ul>
<li>import 命令具有提升效果，import 是在编译阶段执行的，在代码运行之前。</li>
<li><code>import</code>语句会执行所加载的模块</li>
<li><code>import</code>语句是 Singleton 模式，多次import 同一个模块只会导入一次，也只会执行一次模块中的全局代码</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">import {A} from &#39;mode&#39;
import {A} from &#39;mode&#39;

// 等价于 
import {A, B} from &#39;mode&#39;</code>
        </deckgo-highlight-code></article><div class="article-title-wrap"><div class="article-title-list"><h1 data-id="0" class="item">变量声明</h1><h1 data-id="1" class="item">全局对象 &#x26; 顶层对象</h1><h1 data-id="2" class="item">变量的解构赋值</h1><h1 data-id="3" class="item">扩展运算符</h1><h1 data-id="4" class="item">标签模板</h1><h1 data-id="5" class="item">数组扩展</h1><h1 data-id="6" class="item">函数的扩展</h1><h1 data-id="7" class="item">Class</h1><h1 data-id="8" class="item">Proxy</h1><h1 data-id="9" class="item">Reflect</h1><h1 data-id="10" class="item">Iterator &#x26; 遍历器</h1><h1 data-id="11" class="item">Promise</h1><h2 data-id="12" class="item">Promise 读取文件</h2><h2 data-id="13" class="item">参考</h2><h1 data-id="14" class="item">Generator</h1><h2 data-id="15" class="item">异步 Generator</h2><h2 data-id="16" class="item">应用</h2><h1 data-id="17" class="item">async &#x26; await</h1><h1 data-id="18" class="item">异步编程</h1><h1 data-id="19" class="item">模块</h1></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/articles/前端/JS/ES6/";window.___webpackCompilationHash="c883488adf3f372ea0a2";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-1c82c9b017e64ba4eb20.js"],"app":["/app-fae9f38663d1f603e486.js"],"component---src-pages-404-js":["/component---src-pages-404-js-104fdd48e6deefb0b055.js"],"component---src-pages-debug-jsx":["/component---src-pages-debug-jsx-6d68ed8816a03321c33d.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-59cf54365f6a97668d01.js"],"component---src-pages-other-js":["/component---src-pages-other-js-48e569e636e8d0ecf927.js"],"component---src-pages-repos-jsx":["/component---src-pages-repos-jsx-aafc15aef56b320b5240.js"],"component---src-templates-post-js":["/component---src-templates-post-js-90384a4e905582211ec0.js"]};/*]]>*/</script><script src="/polyfill-1c82c9b017e64ba4eb20.js" nomodule=""></script><script src="/app-fae9f38663d1f603e486.js" async=""></script><script src="/framework-31fcd97794ac9b085877.js" async=""></script><script src="/webpack-runtime-561bce53e847aceb651a.js" async=""></script></body></html>