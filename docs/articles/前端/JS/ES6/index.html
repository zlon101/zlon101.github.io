<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.fe2da1a9872594f85ba8.css" id="gatsby-global-css">@-webkit-keyframes silde{0%{background-color:green}50%{background-color:#00f}to{background-color:red}}@keyframes silde{0%{background-color:green}50%{background-color:#00f}to{background-color:red}}.p-debug{outline:1px solid red;width:70vw;padding:16px;margin:40px auto 0;overflow:auto;position:relative}.p-debug .animation{width:200px;height:200px;background-color:red}.p-debug .animation.active{-webkit-animation:silde 10s infinite;animation:silde 10s infinite}.c-header{height:48px;width:100%;display:flex;padding:8px 16px;position:fixed;align-items:center;left:0;top:0;border-bottom:2px solid #eaecef;background-color:#fff;z-index:1000}.c-header>*{margin-right:18px;cursor:pointer;font-weight:600;font-size:18px}.c-header>:last-child{margin-left:auto;margin-right:0}.c-nav{max-width:300px;min-height:calc(100vh - 48px);padding:16px 16px 16px 0;overflow:auto;position:sticky;top:48px}.c-nav .file-item{display:block;margin:8px 0;white-space:nowrap}.c-nav .file-item.fold>.file-name:after{content:"";display:inline-block;width:0;height:0;margin-left:8px;border-color:transparent transparent transparent #ccc;border-style:solid;border-width:6px 0 6px 9px;transition:all .2s ease-out}.c-nav .file-item.fold.expand>.file-name:after{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.c-nav .file-item.fold.expand>.child-list{display:block}.c-nav .file-name{margin-bottom:12px;padding-left:16px;color:#2c3e50;font-size:18px;font-weight:700;display:block;position:relative;cursor:pointer;border-left:4px solid transparent}.c-nav .file-name.light{color:#3eaf7c;font-size:20px}.c-nav .child-list{padding-left:16px;margin:0;display:none;transition:all .2s ease-out}.c-layout-sidebar-content{position:relative;display:flex}.c-layout-nav{flex:1 0 auto;border-right:2px solid #eaecef}

/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}*{margin:0;padding:0;outline:0;box-sizing:border-box;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}body,html{font-family:Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}p{line-height:1.5}a{text-decoration:none;color:#2c3e50}a:hover{text-decoration:underline}.page{padding-top:48px}.g-desc{color:#7f8fa4;font-size:14px}.icon-arrow{width:0;height:0;border-color:transparent transparent transparent #00f;border-style:solid;border-width:44.5px 0 44.5px 118px}.icon-font{vertical-align:-.15em;fill:currentColor;overflow:hidden}.page-home-excerpt{margin-bottom:24px;padding:16px;border:1px solid transparent;border-radius:6px;background-color:#9cc}.page-home-excerpt-header{margin-bottom:4px}.page-home-excerpt-header-title{font-size:18px;font-weight:700}.page-home-excerpt-header-desc{margin-left:8px;color:#7f8fa4;font-size:14px}.page-home-excerpt-text{font-size:16px}.page-article-template .article-title-wrap{min-width:10%;border-left:2px solid #eaecef}.page-article-template .article-title-list{padding:16px;position:sticky;top:48px}.page-article-template .article-title-list li{margin-bottom:12px;list-style:none;cursor:pointer}.page-article-template .article-title-list li:hover{color:#3eaf7c;text-decoration:underline}.article-wrap{padding:0 32px 0 64px}.article-wrap h1{font-size:16px}.article-wrap h2,.article-wrap h3,.article-wrap h4,.article-wrap h5,.article-wrap h6{font-size:18px;margin:16px 0}.article-wrap h2:before,.article-wrap h3:before,.article-wrap h4:before,.article-wrap h5:before,.article-wrap h6:before{content:"#";color:#00f}.article-wrap div,.article-wrap p{margin:8px 0}.article-wrap a{color:#0969da}.article-wrap>:not(ul){margin-left:-14px}.article-wrap li{margin:8px 0}.article-wrap li ol,.article-wrap li ul,.article-wrap ol{margin-left:12px}.article-wrap blockquote{padding-left:1.5em;color:#57606a;border-left:.25em solid #d0d7de}.article-wrap code{padding:3px 5px;margin:0 2px;border-radius:2px;white-space:nowrap;color:#5b5b66;background-color:#f0f0f4}.article-wrap .gatsby-resp-image-wrapper{margin-left:0!important}</style><meta name="generator" content="Gatsby 2.32.13"/><link as="script" rel="preload" href="/webpack-runtime-d557a9f2c8da8c87174e.js"/><link as="script" rel="preload" href="/framework-671e2a16129b80fb7370.js"/><link as="script" rel="preload" href="/app-f4e8fefb92197832af63.js"/><link as="script" rel="preload" href="/styles-407fe62976dc5310c43e.js"/><link as="script" rel="preload" href="/component---src-templates-post-js-840351838ca4d9a352eb.js"/><link as="fetch" rel="preload" href="/page-data/articles/前端/JS/ES6/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/3957182205.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="c-layout-wrap  page page-article-template"><header class="c-header"><a href="/">首页</a><a href="/">博客</a><a href="https://zlong1010.github.io/vue-components/#/">vue组件指令</a><a href="/debug">Debug</a><a href="https://github.com/zlong1010"><svg class="icon-font" width="24px" height="24px" aria-hidden="true"><use href="#icon-font-github1"></use></svg></a></header><div class="c-layout-sidebar-content "><div class="c-layout-nav "><div class="c-nav"><div class="file-item fold false"><div class="file-name" role="button">网络基础</div><ul class="child-list"><a class="file-name false" href="/articles/网络基础/服务端/">服务端</a><a class="file-name false" href="/articles/网络基础/HTTP/">HTTP</a><a class="file-name false" href="/articles/网络基础/代理-nginx/">代理-nginx</a><a class="file-name false" href="/articles/网络基础/网络基础/">网络基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">数据结构与算法</div><ul class="child-list"><a class="file-name false" href="/articles/数据结构与算法/数据结构基础/">数据结构基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">前端</div><ul class="child-list"><a class="file-name false" href="/articles/前端/webView/">webView</a><a class="file-name false" href="/articles/前端/前端调试/">前端调试</a><a class="file-name false" href="/articles/前端/前端资源整理/">前端资源整理</a><a class="file-name false" href="/articles/前端/总结/">总结</a><a class="file-name false" href="/articles/前端/浏览器/">浏览器</a><a class="file-name false" href="/articles/前端/规范/">规范</a><a class="file-name false" href="/articles/前端/练题/">练题</a><a class="file-name false" href="/articles/前端/设计模式/">设计模式</a><div class="file-item fold false"><div class="file-name" role="button">前端工程化</div><ul class="child-list"><a class="file-name false" href="/articles/前端/前端工程化/Babel/">Babel</a><a class="file-name false" href="/articles/前端/前端工程化/Gulp/">Gulp</a><a class="file-name false" href="/articles/前端/前端工程化/Webpack/">Webpack</a><a class="file-name false" href="/articles/前端/前端工程化/模块化/">模块化</a><a class="file-name false" href="/articles/前端/前端工程化/npm/">npm</a><a class="file-name false" href="/articles/前端/前端工程化/部署/">部署</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">Node</div><ul class="child-list"><a class="file-name false" href="/articles/前端/Node/客户端-服务端/">客户端-服务端</a><a class="file-name false" href="/articles/前端/Node/服务端编程/">服务端编程</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">JS</div><ul class="child-list"><a class="file-name false" href="/articles/前端/JS/ES6/">ES6</a><a class="file-name false" href="/articles/前端/JS/总结/">总结</a><a class="file-name false" href="/articles/前端/JS/模块/">模块</a><a class="file-name false" href="/articles/前端/JS/Ajax请求/">Ajax请求</a><a class="file-name false" href="/articles/前端/JS/JS基础/">JS基础</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">HTML-CSS</div><ul class="child-list"><a class="file-name false" href="/articles/前端/HTML-CSS/CSS基础/">CSS基础</a><a class="file-name false" href="/articles/前端/HTML-CSS/HTML基础/">HTML基础</a><a class="file-name false" href="/articles/前端/HTML-CSS/总结/">总结</a></ul></div></ul></div><div class="file-item fold false"><div class="file-name" role="button">Vue</div><ul class="child-list"><a class="file-name false" href="/articles/Vue/Nuxt/">Nuxt</a><a class="file-name false" href="/articles/Vue/Vue原码解读/">Vue原码解读</a><a class="file-name false" href="/articles/Vue/PWA/">PWA</a><a class="file-name false" href="/articles/Vue/Vue技术栈/">Vue技术栈</a><a class="file-name false" href="/articles/Vue/Vue视频资料/">Vue视频资料</a><a class="file-name false" href="/articles/Vue/vue基础概念/">vue基础概念</a><a class="file-name false" href="/articles/Vue/总结/">总结</a></ul></div><div class="file-item fold false"><div class="file-name" role="button">React</div><ul class="child-list"><a class="file-name false" href="/articles/React/React总结/">React总结</a><a class="file-name false" href="/articles/React/TODO/">TODO</a><a class="file-name false" href="/articles/React/React基础/">React基础</a><a class="file-name false" href="/articles/React/React技术栈/">React技术栈</a></ul></div><a class="file-name false" href="/articles/Gatsby建站/">Gatsby建站</a><a class="file-name false" href="/articles/Linux命令/">Linux命令</a><a class="file-name false" href="/articles/Git/">Git</a><a class="file-name false" href="/articles/图标/">图标</a><a class="file-name false" href="/articles/微前端/">微前端</a><a class="file-name false" href="/articles/TS基础/">TS基础</a></div></div><article class="article-wrap"><h5 id="t-0" ><a href="https://es6.ruanyifeng.com/#docs/class">ES6入门-阮一峰</a></h5>
<h5 id="t-1" >const let</h5>
<ol>
<li>
<p>const 和 let 都不存在变量提升；都存在暂时性死区；</p>
<ul>
<li>暂时性死区：在块级作用域中被 let 和 const 声明的变量从进入块级作用域就绑定了，不能在 let 或 const 声明语句之前使用 var 或者 没有 var 声明及使用该变量；因此在 let 和 const 声明语句之前(死区)不能以任何形式出现该变量，并且 typeof 也不是一定安全的操作(在没有 let 和 const 之前，typeof 一定不会产生错误)。</li>
<li>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</li>
</ul>
</li>
<li>不能重复声明；</li>
<li>var 声明的全局变量作为顶层对象( window\global )的属性，let 和 const 声明的变量不会；</li>
<li>
<p>块级作用域中的函数声明</p>
<ul>
<li>ES5 规定函数声明只能在全局或函数作用域中，不能在块级作用域(ES5 没有块级作用域)；但浏览器没有遵守该规定，ES5 环境下，在块级作用域中声明的函数存在声明提升，等同于函数表达式(声明提升，值为 undefined)；</li>
<li>ES6 引入块级作用域，允许在块级作用域中声明函数；</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// ES6严格模式
&#39;use strict&#39;;
if (true) {
  function f() {}
}
// 不报错</code>
        </deckgo-highlight-code>
<p> ES6 规定块级作用域中的函数声明语句的行为类似于 let，在块级作用域之外不可引用；</p>
<ul>
<li>为了减少兼容性问题，浏览器可以不遵守 ES6 的规定，在 ES6 环境下的浏览器中的行为方式：</li>
<li>可以在块级作用域中声明函数，但会像对待 var 语句一样(而不是 let)，将函数的声明提升至函数作用域的顶部(只是声明，尚未赋值)；在块级作用域中该函数都是可用的。</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// ES6的浏览器环境, 此处为全局作用域
function f() { 
  console.log(&#39;I am outside!&#39;); 
}
(function () {
  // 此处为函数作用域  
  // var f = undefined; 该语句是块级作用域中的函数声明部分提升至此;
  typeof f;           // undefined 
  if (true) {
    // 此处为块级作用域, 在该作用域中函数是可以访问的;
    f();             // 输出 xx indide  
    function f() { console.log(&#39;I am inside!&#39;); }
  }
  f();               // 输出 inside
}());</code>
        </deckgo-highlight-code>
<ul>
<li>总结：</li>
<li>避免在块级作用域中声明函数，如果要声明也建议使用函数表达式而不是函数声明语句；</li>
<li>ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</li>
</ul>
</li>
<li>
<p>const 声明复杂数据类型</p>
<ul>
<li>const 声明复合类型的变量，变量名指向数据的地址，因此 const 只保证该地址不会改变，但地址中的数据可以被改变；</li>
<li>使用 Object.freeze(obj) 冻结 obj 对象；</li>
</ul>
</li>
</ol>
<h5 id="t-2" >全局对象 &#x26; 顶层对象</h5>
<ul>
<li>
<p>获取全局对象的三种方式：window、global、self</p>
<ol>
<li>global 也只在 node 中才支持；</li>
<li>window 只在浏览器环境中支持；</li>
<li>self 在浏览器和 web worker 中支持；</li>
</ol>
</li>
<li>
<p>不同环境中 this 的指向：</p>
<ol>
<li>全局环境 this 指向全局对象，</li>
<li>node 模块和 ES6 模块中，this 指向当前模块；</li>
<li>函数中，指向调用对象或顶层对象、undefined(严格模式)；</li>
</ol>
</li>
<li>
<p>勉强能获取不同环境中的 全局对象</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 方法1
(typeof window !== &#39;undefined&#39;
 ? window
 : (typeof process === &#39;object&#39; &amp;&amp;
    typeof require === &#39;function&#39; &amp;&amp;
    typeof global === &#39;object&#39;)
   ? global
   : this);
// 方法2
var getGlobal = function () {
if (typeof self !== &#39;undefined&#39;) { return self; }
if (typeof window !== &#39;undefined&#39;) { return window; }
if (typeof global !== &#39;undefined&#39;) { return global; }
throw new Error(&#39;unable to locate global object&#39;);
};</code>
        </deckgo-highlight-code>
<ul>
<li>在语言标准层面引入 global 作为顶层对象，即在所有环境中都存在 global 对象，垫片库<a href="https://github.com/ljharb/System.global"><code>system.global</code></a>模拟了该方法，可以在所有环境拿到 <code>global</code>。</li>
</ul>
</li>
</ul>
<h5 id="t-3" >变量的解构赋值</h5>
<ul>
<li>从复杂数据变量中提取部分数据(数组元素、对象属性值)赋值给新的变量；</li>
<li>变量：复杂数据类型的变量(数组、对象)，要求是可遍历的结构，具有 Iterator 接口；</li>
<li>赋值遵守模式匹配；</li>
</ul>
<p>数组和对象的解构赋值是一种<strong>模式匹配</strong>，要求等号两边的模式相匹配。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">let {bar: bar, foo: foo} = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
// 简写为
let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
import {xx} from &#39;xxx&#39;;
let { log, sin, cos } = Math;

let foo;
({foo} = {foo: 1});     // 成功, 必须用()包裹, 否则将被解析为代码块而不是赋值语句;只有不将大括号写在行首，避免JavaScript将其解释为代码块

var obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};
var { p: [x, { y }] } = obj;  // x: &quot;Hello&quot;, y: &quot;World&quot;</code>
        </deckgo-highlight-code>
<p><strong>用途</strong>：</p>
<ol>
<li>
<p>交换变量的值</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">[x, y] = [y, x];</code>
        </deckgo-highlight-code>
</li>
<li>
<p>函数返回多个值</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function example() {
 return [1, 2, 3];
}
var [a, b, c] = example();</code>
        </deckgo-highlight-code>
</li>
<li>
<p>函数参数</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});

function ({mapState, content}){
   // ...
}</code>
        </deckgo-highlight-code>
</li>
<li>
<p>函数默认参数</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">jQuery.ajax = function (url, {
 async = true,
 beforeSend = function () {},
 cache = true,
 complete = function () {},
 crossDomain = false,
 global = true,
 // ... more config
}) {
 // ... do stuff
};</code>
        </deckgo-highlight-code>
</li>
<li>
<p>导入模块的指定方法</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code>
        </deckgo-highlight-code>
</li>
</ol>
<h5 id="t-4" >扩展运算符</h5>
<blockquote>
<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组；</p>
</blockquote>
<ul>
<li>
<p>demo
数组合并</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">let arr1 = [1,2];
let arr2 = [3,4];
let arr3 = [...arr1, ...arr2];
// arr3 = [1,2,3,4]</code>
        </deckgo-highlight-code>
<p>和解构赋值同时使用</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">let arr = [1,2,3];
let [first, ...rest] = arr;
// first = 1; rest = [2,3]</code>
        </deckgo-highlight-code>
</li>
</ul>
<h5 id="t-5" >字符串扩展</h5>
<h6 id="t-6" >标签模板</h6>
<p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">alert`123`;  // 调用alert 处理后面的字符串; 弹出 123;

// styled-components
styled.dic`
	margin: 0 auto;
`;</code>
        </deckgo-highlight-code>
<h5 id="t-7" >数组扩展</h5>
<p><strong>类数组对象</strong>：本质特征就是要有 length 属性；</p>
<ul>
<li>
<p>将类数组对象和可遍历对象转换为数组</p>
<ol>
<li>Array.from：可以转换类数组对象和可遍历对象；</li>
<li><strong>扩展运算符</strong>：将数组转换为逗号分隔的列表，背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换；<code>[...arguments]</code>，扩展运算符后面跟的一定是数组(或类数组)；</li>
<li>像 <code>{length: 2}</code> 这个对象就只能使用 <code>Array.from</code> 转换；</li>
</ol>
</li>
<li>
<p>得到初始化的数组</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">Array.from({length: 5}, (v, i) =&gt; i);   // [0,1,2,3,4]
Array.from({length: 3}, ele=&gt;0);        // [0,0,0]
new Array(3).fill(0);  // // [0,0,0]</code>
        </deckgo-highlight-code>
</li>
</ul>
<p><strong>数组扩展的内容：</strong></p>
<ol>
<li>Array.from</li>
<li>Array.of</li>
<li>实例的 copyWithin</li>
<li>实例的 find() 、 findIndex() 和 fill();</li>
<li>实例的 keys()、values() 和 entries()；返回遍历器对象；</li>
<li>实例的 includes()</li>
<li>数组的空位</li>
</ol>
<p>参考：<a href="http://caibaojian.com/es6/array.html">数组扩展</a></p>
<h5 id="t-8" >函数的扩展</h5>
<ol>
<li>
<p>参数的默认值</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 写法一
function m1({x = 0, y = 0} = {}) {
 return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
 return [x, y];
}
// 推荐第一种
m1({x: 1});  // [1, 0]
m2({x: 1});  // [1, undefined]</code>
        </deckgo-highlight-code>
</li>
<li>
<p>length 属性：默认参数之前的参数的个数(预期传入的参数的个数)</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function fn(a, b=0, c){
   //...
}
// fn.length: 1</code>
        </deckgo-highlight-code>
</li>
<li>
<p>剩余参数：必须位于参数列表的最后</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function fn(...args){
   // args 是一个数组    
}</code>
        </deckgo-highlight-code>
</li>
<li>
<p>箭头函数
部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">const pipeline = (...funcs) =&gt;
   initVal =&gt; funcs.reduce((a, b) =&gt; b(a), initVal);

const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;
const addThenMult = pipeline(plus1, mult2);

console.log( addThenMult() );  // 12</code>
        </deckgo-highlight-code>
</li>
<li>
<p>函数绑定运算符(::)</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);
// 运算符左侧是指定的 this 对象, 右侧是函数</code>
        </deckgo-highlight-code>
</li>
<li>严格模式
《ECMAScript 2016标准》规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。严格模式下也不能使用 arguments 和 callers</li>
<li>
<p>尾调用优化</p>
<p>ES6 下的<strong>尾调用优化</strong>只在严格模式下才有效；</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 将调用函数的操作放到当前函数执行的最后一步
function fn(){
   &quot;use strict&quot;
   return g();
}
function fn(){
   // 当前函数满足尾调用
   if(xx){
       return g();
   }
   else  return w();
}

// 下式不是尾调用优化, 因为函数默认 return undefined;
function fn(){
   g();
   // return undefined;
}</code>
        </deckgo-highlight-code>
<p>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行 “尾调用优化”。下面的函数无法实现尾调用优化。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function addOne(a){
 var one = 1;
 function inner(b){
   return b + one;
 }
 return inner(a);
}</code>
        </deckgo-highlight-code>
<ul>
<li>尾递归优化示例
尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 1. 阶乘
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}
// 优化后
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

// 2. fibonacci 
function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}
// 优化后
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}</code>
        </deckgo-highlight-code>
<p>参考：<a href="http://caibaojian.com/es6/function.html">函数扩展</a></p>
</li>
</ol>
<h5 id="t-9" >Class</h5>
<ul>
<li>
<p>例子</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">class Person{
constructor(name, age){
  this.name = name;
  this.age = age;
}
getName(){
  return this.name;
}
}
/*
* this 指向实例对象,
* 类的方法(getName)定义在类的prototype(Person.prototype)上, 并且不可枚举;
* 方法之间不需要逗号,
*/</code>
        </deckgo-highlight-code>
</li>
<li>constructor
类必须有一个 constructor 方法，若没有显示定义，默认的 constructor 为 <code>constructor(){}</code></li>
<li>
<p>super</p>
<ol>
<li>在super方法调用前，不能使用this，因为 ES6 是先创建父类实例；</li>
<li>作为函数调用，super 指向父类的构造函数，并且作为函数调用时只能出现在子类的构造函数中；</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">class A {}

class B extends A {
  constructor() {
    super();
    // 相当于 A.prototype.constructor.call(this);
  }
}</code>
        </deckgo-highlight-code>
<ol start="3">
<li>作为对象时，super 指向父类的原型；ES6 规定，通过 <code>super</code> 调用父类的方法时，<code>super</code> 会绑定子类的<code>this</code>。</li>
</ol>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    this.name = &#39;czl&#39;;
    console.log(super.p()); // 调用 A的 方法, 该方法中的this 指向子类的实例,可以访问 this.name
  }
  p(){
 		return 100;
  }
}</code>
        </deckgo-highlight-code>
</li>
<li>
<p>ES6 中Class 与 ES5 的区别</p>
<ul>
<li>函数存在声明提升，Class 不会；</li>
<li>类内部默认开启严格模式；</li>
<li>ES5 继承先创建子类实例，再调用父类构造函数，将属性和方法添加到子类实例上；ES6 是先创建父类实例，再通过子类的构造函数修改 this；</li>
<li>Class 定义在原型上的方法是不可枚举的；</li>
<li>Class 实现了子类的构造函数继承父类的构造函数；</li>
</ul>
</li>
</ul>
<h5 id="t-10" >Proxy &#x26; Reflect</h5>
<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种<strong>元编程</strong>，即对编程语言进行编程。<strong>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</strong>Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<ol>
<li>get(target, propKey, receiver)
拦截对象属性的读取；</li>
<li>set(target, propKey, value, receiver)
拦截对象属性的赋值操作；</li>
<li>has(target, propKey)
拦截<code>propKey in proxy</code>的操作；</li>
<li>apply(target, object, args)
<code>apply</code>方法拦截函数的调用、call和apply操作；</li>
</ol>
<p><strong>this 指向</strong>：</p>
<ul>
<li>
<p>使用 Proxy 代理的情况下，目标对象内部的 <code>this</code> 关键字会指向 Proxy 代理。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">const target = {
m: function () {
  console.log(this === proxy);
}
};
const handler = {};
const proxy = new Proxy(target, handler);

target.m() // false
proxy.m()  // true</code>
        </deckgo-highlight-code>
</li>
</ul>
<h6 id="t-11" >Reflect</h6>
<p><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code> 怎么修改默认行为，你总可以在 <code>Reflect</code> 上获取默认行为。</p>
<h5 id="t-12" >使用 Proxy 实现观察者模式</h5>
<p>观察者模式（Observer mode）指的是观察者(函数)自动观察被观察者(数据对象)，一旦对象有变化，函数就会自动执行。</p>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">const person = observable({
  name: &#39;张三&#39;,
  age: 20
});
function print() {
  console.log(`${person.name}, ${person.age}`)
}

observe(print);
person.name = &#39;李四&#39;;  // // 李四, 20

/*
* observable 和 observe 实现;
* observable 注册被观察者(数据对象);
* obsere 注册观察者(数据更新时执行的函数);
*/ 

// 观察者(函数)
const queuedObservers = new Set();

const observe = fn =&gt; queuedObservers.add(fn);
const observable = obj =&gt; new Proxy(obj, {set});

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  return result;
}</code>
        </deckgo-highlight-code>
<h5 id="t-13" >Iterator &#x26; 遍历器</h5>
<p>遍历器生成函数接收一个可选的数据结构(如数组)，返回一个遍历器对象，该对象必须要有 <code>next</code> 方法，且 <code>next</code> 属性的值是一个函数，调用该函数会返回指定的数据结构中的下一个元素。for...of 根据遍历器对象依次访问元素。</p>
<ul>
<li><strong>可遍历数据</strong>：部署了 iterator 接口，原生的数组、部分类数组对象、Set、Map的 <code>Symbol.iterator</code> 属性就是遍历器生成函数，最简单的实现方式就是 generator 函数。</li>
<li>for...of、扩展运算符、解构赋值；</li>
</ul>
<h5 id="t-14" >Generator</h5>
<p>Generator函数是ES6提供的一种异步编程解决方案，执行Generator函数会返回一个<strong>遍历器对象</strong>；</p>
<p>Generator函数有多种理解角度：</p>
<ul>
<li>Generator函数是一个状态机，封装了多个内部状态。</li>
<li>
<p>形式上，Generator函数是一个普通函数，但是有两个特征。</p>
<ol>
<li><code>function</code> 关键字与函数名之间有一个星号；</li>
<li>函数体内部使用 <strong>yield</strong> 语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。</li>
</ol>
</li>
<li>
<p>例如</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function* foo(x) {
var y = 2 * (yield (x + 1));
var z = yield (y);
return (x + y + z);
}
var hw = foo(1);
hw.next();   // { value: 2, done: false }
hw.next(3);  // { value: 6, done: false }</code>
        </deckgo-highlight-code>
</li>
</ul>
<p><strong>yield：</strong></p>
<ul>
<li>遇到 <code>yield</code> 语句，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值。</li>
<li>yield 表达式(如：yield(x+1)) 的返回值是 undefined，通过 hw.next(val)可以设置上次 yield 表达式的返回值；</li>
</ul>
<p><strong>this &#x26; 原型对象：</strong></p>
<ul>
<li>
<p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的<code>prototype</code>对象上的方法。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function* g() {}
g.prototype.hello = function () {
return &#39;hi!&#39;;
};

let iter = g();

iter instanceof g // true
iter.hello()      // &#39;hi!&#39;
// 生成器函数g()生成的迭代器对象 iter 是 g 的实例，并且继承了 g.prototype 上的方法;
// g() 类似于构造函数, 但又不是;g() 返回的不是 this, this === global;</code>
        </deckgo-highlight-code>
</li>
</ul>
<h6 id="t-15" >异步Generator</h6>
<blockquote>
<p>异步 Generator 生成 异步的 Iterator ，异步 Iterator 的 next() 方法返回的是一个 Promise；</p>
<p>异步 Generator 的 yield 产出的是 Promise 对象或 Thunk ，即异步生成器创建的迭代器的 next() 方法返回的是 Promise；</p>
</blockquote>
<h6 id="t-16" >应用</h6>
<ol>
<li>异步操作的同步表达；</li>
<li>控制流管理；</li>
<li>部署 Iterator 接口；</li>
<li>作为数据结构； </li>
</ol>
<h6 id="t-17" >参考：</h6>
<ul>
<li><a href="http://caibaojian.com/es6/generator.html">Generatot函数</a></li>
</ul>
<h5 id="t-18" >Promise</h5>
<ul>
<li>Promise是异步编程的一种解决方案，比传统的解决方案—<strong>回调函数和事件</strong>更合理和更强大；</li>
<li>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。Promise提供then方法加载回调函数，使用then方法以后，异步任务的两段执行看得更清楚了；</li>
<li>Promise就是为了解决回调地狱而提出的，它不是新的语法功能，而是一种<strong>新的写法</strong>，允许将回调函数的嵌套，改成链式调用；</li>
<li>
<p>Promise 创建后会立即执行</p>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">let promise = new Promise(function(resolve, reject) {
// 需要执行的异步操作, 立即执行
// 异步操作失败时执行 reject, 成功执行 resolve,
// resolve 和 reject 会将数据以实参的形式传递出去;
console.log(&#39;Promise&#39;);
setTimeout(resolve, ms, &#39;done&#39;);  
});</code>
        </deckgo-highlight-code>
</li>
<li><code>then</code> 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</li>
</ul>
<h6 id="t-19" >Promise 读取文件</h6>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">let read = require(&#39;read-file&#39;);
function readFile(name) {
  return new Promise((resolve, reject) =&gt; {
    // 1. 第1步
    read(name, &#39;utf-8&#39;, (error, data) =&gt; {
      if (error) reject(error);
      else resolve(data);
    });
  });
}

readFile(&#39;name2.txt&#39;)
	// 2. 第2步
  .then(data =&gt; readFile(data))
	// 3. 第3步
  .then(data =&gt; {  		
      console.log(`1-s: ${data}`);
      return 123;
    },
    error =&gt; {
      console.log(`1-e: ${error}`);
      return 0;
    })	
  .then(data =&gt; console.log(`2-s: ${data}`),
    error =&gt; console.log(`2-e: ${error}`))
  .then(data =&gt; console.log(`3-s: ${data}`),
    error =&gt; console.log(`3-e: ${error}`));
/*
 执行流程
 1. 执行第一步, 通过 resolve(data) 或 reject(error) 传递数据, 并且返回一个 promise 实例;
 2. 执行第二步, 根据上一步是成功或失败, 执行 then 的成功回调或失败回调; 如果上一步返回的是 promise 实例,
    则回调函数的参数来自于 resolve(data) 或 reject(error) 的实参;
    如果上一步返回的不是 promise 实例, 则回调函数的参数来自于上一步 return 的值。 
 */</code>
        </deckgo-highlight-code>
<h6 id="t-20" >Promise 实现 Ajax请求</h6>
<deckgo-highlight-code language="javascript" terminal="carbon" theme="blackboard"  >
          <code slot="code">var getJSON = function(url) {
  var promise = new Promise(function(resolve, reject){
    var client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();

    function handler() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
  });

  return promise;
};

getJSON(&quot;/posts.json&quot;).then(function(json) {
  	// json 是异步操作成功后, resolve(this.response)传递过来的
  	console.log(&#39;Contents: &#39; + json);
	}, 
  function(error) {
    console.error(&#39;出错了&#39;, error);
  });

// then 返回一个新的 Promise,
getJSON(&quot;/posts.json&quot;)
	.then(function(json) {
  	return json.post;
	})
  .then(function(post) {
  	// 该回调函数接收上一个回调函数的返回值(return json.post)作为参数
	});</code>
        </deckgo-highlight-code>
<h6 id="t-21" >手写 Promise</h6>
<p>理解浏览器的事件循环（Event loop），一句话即Promise是先同步处理then、catch函数再异步处理executor函数，接着通过resolve或reject触发then、catch的参数。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">// 因为会立即执行这个执行器函数
function MyPromise(executor){
  let self = this
  self.status = &#39;pending&#39; // 默认promise状态是pending
  function resolve(value){
    self.status = &#39;resolved&#39; // 成功状态
    self.onSuccess(value);
  }
  function reject(reason){
    self.status = &#39;rejected&#39; //失败状态
    self.onFail(reason);
  }
  executor(resolve, reject) 
}

MyPromise.prototype.then = function(onFulfilled, onRejected){
	this.onSuccess = onFulfilled;
  this.onFail = onRejected;
} 

// 使用MyPromise
let p = new MyPromise((resolve, reject) =&gt; {
  let timer = setTimeout( ()=&gt;{
    console.log(&#39;开始异步执行!&#39;);
    resolve(timer);
  }, 2000);
})
p.then(data=&gt;{
  console.log(`异步执行完成!  data:${data}`);
  clearTimeout(data);
})
.catch(error=&gt;console.log(error));

console.log(&#39;同步代码执行完成!&#39;);</code>
        </deckgo-highlight-code>
<h6 id="t-22" >参考</h6>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&#x26;mid=2247484260&#x26;idx=1&#x26;sn=0bc8a7aed8b15d3cc7e75c76394b648a&#x26;chksm=c06682f2f7110be41b29ce0eabc441fba11e1ab306ca40e4e7d81d338b4af7e35721573d1cca&#x26;mpshare=1&#x26;scene=1&#x26;srcid=&#x26;sharer_sharetime=1566171898757&#x26;sharer_shareid=c0fa4bb765d12545f4439ab827814978&#x26;key=56eb82a42460d979c3afc63a4f31177e13db16329cf4763c707bf96642e8906b81d68c0b03fa52eaabde20326b79c31368a9de23b389122e084df4a3c4aa327001973a319a1020fe8e99f6a26930b5b9&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060833&#x26;lang=zh_CN&#x26;pass_ticket=D8igzih7KnA8%2F5LHQdRG6th5IVXvvQD7ukUD5HSt%2FLcfZ7gOforYJWqBjo9rYF%2FC">你了解Promise吗-segmentfault</a></li>
<li><a href="https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4">Promse A+ 规范</a> </li>
<li><a href="https://juejin.im/post/5b83cb5ae51d4538cc3ec354">Promise 实现原理-掘金</a></li>
</ul>
<h5 id="t-23" >async &#x26; await</h5>
<p><strong>async 函数就是 Generator 函数的语法糖。</strong>  </p>
<p>await 命令只能出现在 async 函数中，await 表达式会暂停当前 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function"><code>async function</code></a> 的执行，等待其后面表达式的结果，像 Generateor 函数一样将执行权转让给其他程序；</p>
<ul>
<li>async 定义一个通过事件循环异步执行的异步函数，该函数隐式返回一个 Promise 对象，可以用<code>then</code>方法指定下一步的操作。</li>
<li><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数；</li>
<li><code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</li>
<li><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，才会执行<code>then</code>方法指定的回调函数，除非遇到<code>return</code>语句或者抛出错误。</li>
</ul>
<p>result = await 表达式</p>
<ul>
<li>await 等待一个Promise对象，await 表达式的值就是 Promise 处理的结果，若表达式不是 Promise，则返回表达式本身的值；</li>
<li>await 会暂停异步函数(async 函数)的执行，调用async函数的上层函数会继续执行(收到异步函数返回的隐式Promise)</li>
<li>若 await 后面的表达式是Promise，且 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function"><code>async function</code></a>。</li>
<li>
<p>若 await 后面的表达式是Promise，且  Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。所以最好将await命令放在<code>try catch</code>中</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">async function myFunction() {
try {
  await somethingThatReturnsAPromise();
} catch (err) {
  console.log(err);
}
}</code>
        </deckgo-highlight-code>
</li>
</ul>
<p><strong>async 实现</strong></p>
<p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">function spawn(genF) {
  return new Promise(function (resolve, reject) {
    const gen = genF();
    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch (e) {
        return reject(e);
      }
      if (next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(
        function (v) {
          step(function () {
            return gen.next(v);
          });
        },
        function (e) {
          step(function () {
            return gen.throw(e);
          });
        }
      );
    }
    
    step(function () {
      return gen.next(undefined);
    });
  });
}</code>
        </deckgo-highlight-code>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">MDN-aync</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">MDN-await</a>  </li>
<li><a href="https://segmentfault.com/a/1190000007535316">理解 JavaScript 的 async/await</a> </li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&#x26;mid=2650215577&#x26;idx=1&#x26;sn=0edb4be37430e17ba1029ab3b1a36a57&#x26;chksm=befe14b889899daea69684da9ac22613cfef5e534f920a194a640f21ab5ec839d498642ed455&#x26;scene=0&#x26;key=6deb43fc298651d2935752bd2c9f8fa907d71cfcf410807341a1a420ced46efe20f453fa8f835874ef05bec5deefb1be9a1a136a7027e798b32030bded88d257b46b8f1442a2b56ac165cfaa80db49f5&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060720&#x26;lang=zh_CN&#x26;pass_ticket=Pn9cJyIWK2xt%2BmQltkMddf4S5oGoplFdiJ%2B16Yj6gD8L9Zd0WMlQ1u32%2FRJtZE1p">async &#x26; await 面试题</a> </li>
<li><a href="https://gongchenghuigch.github.io/2019/09/14/awat/">setTimeout promise async</a> </li>
</ul>
<h5 id="t-24" >异步编程</h5>
<ul>
<li>
<p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调、事件监听、Promise对象</li>
</ul>
</li>
</ul>
<h4 id="t-25" >模块</h4>
<ul>
<li>import 命令具有提升效果，import 是在编译阶段执行的，在代码运行之前。</li>
<li><code>import</code>语句会执行所加载的模块</li>
<li>
<p><code>import</code>语句是 Singleton 模式，多次import 同一个模块只会导入一次，也只会执行一次模块中的全局代码</p>
<deckgo-highlight-code language="js" terminal="carbon" theme="blackboard"  >
          <code slot="code">import {A} from &#39;mode&#39;
import {A} from &#39;mode&#39;

// 等价于 
import {A, B} from &#39;mode&#39;</code>
        </deckgo-highlight-code>
</li>
</ul></article><div class="article-title-wrap"><ul class="article-title-list"><li data-id="0"></li><li data-id="1"></li><li data-id="2"></li><li data-id="3"></li><li data-id="4"></li><li data-id="5"></li><li data-id="6"></li><li data-id="7"></li><li data-id="8"></li><li data-id="9"></li><li data-id="10"></li><li data-id="11"></li><li data-id="12"></li><li data-id="13"></li><li data-id="14"></li><li data-id="15"></li><li data-id="16"></li><li data-id="17"></li><li data-id="18"></li><li data-id="19"></li><li data-id="20"></li><li data-id="21"></li><li data-id="22"></li><li data-id="23"></li><li data-id="24"></li><li data-id="25"></li></ul></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/articles/前端/JS/ES6/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-0672eb177be2180b9b97.js"],"app":["/app-f4e8fefb92197832af63.js"],"component---src-pages-404-js":["/component---src-pages-404-js-da26abf276b01cb65497.js"],"component---src-pages-debug-jsx":["/component---src-pages-debug-jsx-f5795fb4e41157ac863f.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-c1efa013a56a9a5d7d92.js"],"component---src-pages-other-js":["/component---src-pages-other-js-708266e2a7807cb5b20b.js"],"component---src-pages-repos-jsx":["/component---src-pages-repos-jsx-f8712835bf082d4773a5.js"],"component---src-templates-post-js":["/component---src-templates-post-js-840351838ca4d9a352eb.js"],"polyfills-dom":["/polyfills-dom-527287ec3415f87639b2.js"],"polyfills-core-js":["/polyfills-core-js-00812e0208c5c6bfb98e.js"]};/*]]>*/</script><script src="/polyfill-0672eb177be2180b9b97.js" nomodule=""></script><script src="/component---src-templates-post-js-840351838ca4d9a352eb.js" async=""></script><script src="/styles-407fe62976dc5310c43e.js" async=""></script><script src="/app-f4e8fefb92197832af63.js" async=""></script><script src="/framework-671e2a16129b80fb7370.js" async=""></script><script src="/webpack-runtime-d557a9f2c8da8c87174e.js" async=""></script></body></html>