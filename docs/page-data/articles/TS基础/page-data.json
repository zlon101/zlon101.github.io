{"componentChunkName":"component---src-templates-post-js","path":"/articles/TS基础/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/TS基础/"},"html":"<blockquote>\n<p><code>ReactNode</code> 、 <code>ReactElement</code> 和 <code>JSX.Element</code> 的区别？</p>\n</blockquote>\n<p><code>children?: React.ReactNode </code></p>\n<blockquote>\n<p>任意数量的参数、剩余参数、默认参数的类型声明</p>\n</blockquote>\n<blockquote>\n<p>Class private 声明？</p>\n</blockquote>\n<blockquote>\n<p>交叉类型、联合类型、extends 区别</p>\n</blockquote>\n<blockquote>\n<p>infer</p>\n</blockquote>\n<blockquote>\n<p>泛型只能用在函数中，<code>()</code> 前面？</p>\n</blockquote>\n<h1>概况</h1>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 621px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 71.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACuklEQVQ4y32Ta28aRxSG94/3W9Xf0KpS+6FN3TpWjO0a2/iixCEOEDCYa2RDzYKXhV32fr/xVKwhcqq2M3q0Z45m33nnzIxwdnrG4cEhpbMSxeMT9t8UeL27R7VaQ5JmyDMZeTZnMVdQ5grqQmWpLFmqGpqmoWs6ur7GQDdMhKVhYDjOFyzPw/Y9TNdBty10287z67HpulhrPBfb8/D8AD/YEuYIURyzbiv48t3GL9t/5f6JEIZRHmSrVU66ev51PFcp1Ttc3nbRLDvPbef8H0IYRV+tmm0ExcWSwrsqB+8qGI77r4IvjWy7ICtLdq4q/FG6ZiROeF1u8r7e4n4qc1DpclRpIz5JHFda/Fm5I96UKNuIPYu+3HIQcNcb0Oj0kGcSzW6f4eMjk8mE6l2Hym0TWZboD0e0e30c28L1XNI4zIXTLPvKpdAYPHBcrpGkCcUPddoPj5iOw+7FNZqh0/trTPGmjh/4nNeaVDt95KXG7mWZhW5s3G7LkCHU2gP2L8s4nsvJxwbvb9vIqsovxQskRaE7GnN0XcFybE4+fuJTt49mWfx2esVwLJKlCUHowyrLxQVFUbl/GG7uQUIYeCRpTOg/H4S8mDOeiHn8KI5RliphHNHq9ZirKtVmi6EoUu90mc4XCDvnZb75eQ/DMonTJHcSRCGa+bydN+U63746ZDKT+G7niF9P3yIpKj8USlzVGvxYOONV8YLvD875/fQK4WH8RLU9IE3TvAZxtLaf4m8cjqYS9f5nojiiMbhnOJmiOw77b29QTRN/fUBpgm2bxHGEkIQRrmWTJglP8oxyq0ft84hGt0eSxFiWiWObpFmKbZlEoc9YkvmpcMJQnGAYOrbrYJhGPkcI1u/QCwgCn6k8o3DTZK98y4dmJ3dpr9+3Y+P5HrZj5/iBl9c6DIN87LgOQRjk1+ZvAk4QuOg/yRkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image-20200820171028681\" title=\"image-20200820171028681\" src=\"/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png\" srcset=\"/static/2d5d45cf184dbee81bfeca5b3846a42f/772e8/image-20200820171028681.png 200w,\n/static/2d5d45cf184dbee81bfeca5b3846a42f/e17e5/image-20200820171028681.png 400w,\n/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png 621w\" sizes=\"(max-width: 621px) 100vw, 621px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>  \n<img src=\"assets/TS%E5%9F%BA%E7%A1%80/image-20201114122155270.png\" alt=\"image-20201114122155270\" style=\"zoom:80%;\" />  \n<p>上面的是父级，下面是子级，子级类型可以赋值给父级。</p>\n<p>TS简单的说就是为JS中的变量指定了类型，JS中的变量本身是没有类型的。有了TS就可以为变量指定一个类型，这样在【编译阶段】就可以检查变量是否赋予了正确的类型，提前发现错误，配合编辑器的语法提示能有效提高开发效率。</p>\n<blockquote>\n<p>TypeScript体系</p>\n</blockquote>\n<p><strong>值 、变量 和 类型</strong></p>\n<ul>\n<li>类型的标注/推导确定</li>\n<li>类型的检查，检查数据类型是否安全</li>\n</ul>\n<blockquote>\n<p>TS资源</p>\n</blockquote>\n<p><a href=\"https://ts.xcatliu.com/\">TS入门教程-阮一峰</a>\r\n<a href=\"https://jkchao.github.io/typescript-book-chinese/#why\">深入理解TS</a></p>\n<h1>类型声明</h1>\n<p>类型是值的集合，比如：\r\nNull  只有<code>null</code>一个元素的集合\r\nBoolean  有两个元素<code>false</code>和<code>true</code>的集合</p>\n<p>变量的类型有：基本数据类型、数组、对象、函数、枚举。</p>\n<p>基本数据类型除了 number、string 等还包括 TS 中 3 种特殊类型：<code>never</code>、<code>undefined</code>、<code>null</code>、<code>any</code>、<code>void</code></p>\n<ul>\n<li>\n<p>undefined 、null、any 可以视为不进行类型检查</p>\n</li>\n<li>\n<p>void 表示函数没有返回值</p>\n</li>\n<li>\n<p><code>never</code> 表示永远不存在的值的类型，即这个类型没有对应的值，never 只能被 never 赋值</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function fail(message: string): never {\r\n  throw new Error(message);\r\n}</code>\n        </deckgo-highlight-code>\n<h2>指定变量的类型</h2>\n<ul>\n<li>变量声明为基本数据类型</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const name: string = &#39;xxx&#39;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>变量声明为数组类型</li>\n</ul>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const arr: number[]</code>\n        </deckgo-highlight-code>\n<ul>\n<li>变量声明为对象</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Person {\r\n  name: string;\r\n  age: number;\r\n  seedrandom(seed?: string): void;\r\n}\r\ninterface Array&lt;T&gt; {\r\n  reverse(): T[];\r\n}\r\n// 或者使用【内联类型】，省略类型的定义\r\nlet name: {\r\n  first: string;\r\n  second: string;\r\n};</code>\n        </deckgo-highlight-code>\n<ul>\n<li>变量声明为函数</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const onBlur:  (value: string, e?: React.FocusEvent&lt;HTMLInputElement&gt;) =&gt; void;\r\n\r\nconst listener: (ev: MouseEvent) =&gt; any  // 指定listener 是一个函数，同时指定该函数的输入输出类型\r\n\r\nlet mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {\r\n    return x + y;\r\n};</code>\n        </deckgo-highlight-code>\n<ul>\n<li>变量声明为枚举</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Week = &#39;Mon&#39; | &#39;Tue&#39;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>元组类型</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let nameNumber: [string, number];</code>\n        </deckgo-highlight-code>\n<h2>字面量类型</h2>\n<p>string、boolean、number 类型的值可以作为字面量类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let foo: &#39;Hello&#39;;\r\ntype OneToFive = 1 | 2 | 3 | 4 | 5;\r\ntype Bools = true | false;</code>\n        </deckgo-highlight-code>\n<h2>索引签名</h2>\n<p>指定对象的 key 或 key-value 对应该符合的类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Foo {\r\n  [key: string | number]: any\r\n}\r\n\r\nconst foo: {\r\n  [key: string]: { message: string }; // key 可以改为任意名称\r\n} = {};\r\n\r\ntype Index = &#39;a&#39; | &#39;b&#39; | &#39;c&#39;;\r\ntype FromIndex = { [k in Index]?: number };\r\nconst good: FromIndex = { b: 1, c: 2 };</code>\n        </deckgo-highlight-code>\n<h1>类型运算</h1>\n<p>操作数应该是【类型】</p>\n<h2>type 别名</h2>\n<p>与接口不同，接口定义了一种新的类型，别名只是对现有的类型声明了新的名字，别名通常与字面量类型、联合类型、交叉类型、泛型使用，例如：</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 为string起一个别名Name，\r\ntype Name = string;\r\nlet myName:Name = &#39;abc&#39;;\r\n\r\n// 等号右边是字符串字面量类型，Easing是这个字面量类型的别名\r\ntype Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;\r\nlet easing: Easing = &#39;ease-in&#39;;\r\nlet easing: Easing = &#39;other&#39;; // 报错\r\n// easing这个变量只能被赋值为&quot;ease-in&quot; 或 &quot;ease-out&quot; 或 &quot;ease-in-out&quot;这三个字符串中的一个，赋值为其他值就会报错\r\n\r\ntype Callback = (data: string) =&gt; void;</code>\n        </deckgo-highlight-code>\n<p>interface 可以作为 <code>implements</code> 和 <code>extends</code> 的操作数，type 声明的别名不能。</p>\n<h2>enum 枚举</h2>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">enum CardSuit {\r\n  Clubs,\r\n  Diamonds = 1,\r\n  Hearts,\r\n  Spades\r\n}\r\n// 简单的使用枚举类型\r\nlet Card = CardSuit.Clubs;</code>\n        </deckgo-highlight-code>\n<h2>或运算  联合类型</h2>\n<p>多个类型的或运算，逆 <code>extends</code> ，生成的类型是参与运算的类型的父类型。</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 声明了NumOrStr为一个联合类型\r\ntype NumOrStr = sting | number;\r\n\r\nlet x: NumOrStr = 1; // success\r\nx = &#39;abc&#39;; // success\r\nx = [1]; // error</code>\n        </deckgo-highlight-code>\n<h2>与运算  交叉类型</h2>\n<p>合并多个类型</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Parent1 = {\r\n  name: string;\r\n}\r\ntype Parent2 = {\r\n  age: number;\r\n}\r\ntype Child = Parent1 &amp; Parent2;\r\n\r\n// 子级类型可以赋值给父类型(属性只能多不能少)\r\nlet my: Parent1 = {\r\n  age: 2,\r\n  name: &#39;&#39;\r\n}</code>\n        </deckgo-highlight-code>\n<h2>as  类型断言</h2>\n<p>当 <code>S</code> 类型是 <code>T</code> 类型的子集，或者 <code>T</code> 类型是 <code>S</code> 类型的子集时，<code>S</code> 能被成功断言成 <code>T</code>。</p>\n<p>如果 S 和 T 类型不存在包含关系时，可以使用【双重断言】</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let foo = 123;\r\nlet bar = &#39;hey&#39;;\r\nbar = foo as any; // ok\r\n// 双重断言\r\nbar = (foo as string) as any;</code>\n        </deckgo-highlight-code>\n<p>使用类型断言手动去除某个类型中的<code>null</code>和<code>undefined</code></p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">name!.charAt(0)  // name为undefined 时会报错,!的意思是显式告诉编译器name不会为undefined\r\nname?.charAt(0) // 可选链运算符，name为undefined 时不会报错</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>const 断言</p>\n</blockquote>\n<p>使用 const 断言构造新的字面量表达式时，我们可以向编程语言发出以下信号：</p>\n<ul>\n<li>表达式中的任何字面量类型都不应该被扩展；</li>\n<li>对象字面量的属性，将使用 readonly 修饰；</li>\n<li>数组字面量将变成 readonly 元组。</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let z = { text: &quot;hello&quot; } as const;\r\ntype Z = typeof z; // let z: { readonly text: &quot;hello&quot;; }</code>\n        </deckgo-highlight-code>\n<h2>类型保护</h2>\n<p>缩小类型范围或更精确的指明变量的类型，具体实现方法有：instance、typeof、in</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function doSome(x: number | string) {\r\n  if (typeof x === &#39;string&#39;) {\r\n    // 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`\r\n    console.log(x.subtr(1)); // Error: &#39;subtr&#39; 方法并没有存在于 `string` 上\r\n    console.log(x.substr(1)); // ok\r\n  }\r\n\r\n  x.substr(1); // Error: 无法保证 `x` 是 `string` 类型\r\n}</code>\n        </deckgo-highlight-code>\n<p>typeof 类型保护只支持两种形式：typeof v === \"typename\" 和 typeof v !== typename，\"typename\" 必须是 \"number\"， \"string\"， \"boolean\" 或 \"symbol\"。但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护</p>\n<blockquote>\n<p>自定义类型保护</p>\n</blockquote>\n<p>当 instance、typeof、in 无法满足复杂的类型判断场景时可以自定义类型保护</p>\n<p>自定义类型保护的主要特点是：</p>\n<ul>\n<li>返回类型谓词，如 <code>vehicle is Car</code>；</li>\n<li>包含可以准确确定给定变量类型的逻辑语句，如 <code>xx.someProp !== undefined &#x26;&#x26; xx.someProp !== 0</code>。</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function isOfType&lt;T&gt;(\r\n  varToBeChecked: any,\r\n  propertyToCheckFor: keyof T\r\n): varToBeChecked is T {\r\n  return (varToBeChecked as T)[propertyToCheckFor] !== undefined;\r\n}\r\n\r\n// 使用\r\nif (isOfType&lt;Car&gt;(vehicle,  &#39;turnSteeringWheel&#39;)) {\r\n  console.log(&quot;这是一辆车&quot;);\r\n} else {\r\n  console.log(&quot;这不是一辆车&quot;);\r\n}</code>\n        </deckgo-highlight-code>\n<h2>类型推断</h2>\n<p>TypeScript 能根据一些简单的规则推断变量的类型</p>\n<ol>\n<li>变量定义并赋值</li>\n<li>赋值</li>\n<li>函数返回值</li>\n<li>对象、数组解构</li>\n</ol>\n<blockquote>\n<p>示例</p>\n</blockquote>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let foo = 123;\r\nlet bar: typeof foo; \r\n\r\n// 捕获 key 的名称\r\nconst colors = {\r\n  red: &#39;red&#39;,\r\n  blue: &#39;blue&#39;\r\n};\r\n\r\ntype Colors = keyof typeof colors;\r\n\r\nlet color: Colors; // color 的类型是 &#39;red&#39; | &#39;blue&#39;\r\ncolor = &#39;red&#39;; // ok\r\ncolor = &#39;blue&#39;; // ok\r\ncolor = &#39;anythingElse&#39;; // Error</code>\n        </deckgo-highlight-code>\n<p>从实现中推断类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const initialState = {\r\n  show: false,\r\n};\r\ntype State = Readonly&lt;typeof initialState&gt;;\r\ntype ToggleableComponentProps = {\r\n  show: State[&#39;show&#39;];\r\n};</code>\n        </deckgo-highlight-code>\n<p>xxx</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type ToggleableComponentProps = {\r\n  toggle: Toggleable[&#39;toggle&#39;];\r\n  // Toggleable 本来就是类型，不能是变量\r\n};\r\n\r\nexport class Toggleable extends Component&lt;Props, State&gt; {\r\n  readonly state: State = initialState;\r\n  render() {\r\n    // \r\n  }\r\n  private toggle = (event: MouseEvent&lt;HTMLElement&gt;) =&gt; this.setState(updateShowState);\r\n}</code>\n        </deckgo-highlight-code>\n<h2>keyof &#x26; typeof</h2>\n<p><code>keyof</code> 后面跟一个【类型】，获取该类型的所有 key，产生联合类型。\r\n在 TS 中 <code>typeof</code> 后面跟一个【变量】，得到的是类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type State = Readonly&lt;typeof initialState&gt;;\r\n\r\nconst COLORS = {\r\n  red: &#39;red&#39;,\r\n  blue: &#39;blue&#39;\r\n}\r\n\r\n// 首先通过 typeof 操作符获取 Colors 变量的类型，然后通过keyof操作符获取该类型的所有键，\r\n// 即字符串字面量联合类型 &#39;red&#39; | &#39;blue&#39;\r\ntype Colors = keyof typeof COLORS\r\nlet color: Colors;\r\ncolor = &#39;red&#39;// Ok\r\ncolor = &#39;blue&#39;// Ok\r\n\r\n// Type &#39;&quot;yellow&quot;&#39; is not assignable to type &#39;&quot;red&quot; | &quot;blue&quot;&#39;.\r\ncolor = &#39;yellow&#39;// Error</code>\n        </deckgo-highlight-code>\n<p>定义一个获取对象属性值的函数</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) {\r\n  return obj[key];\r\n}</code>\n        </deckgo-highlight-code>\n<h2>索引访问类型</h2>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type P3 = string[&quot;charAt&quot;];  // (pos: number) =&gt; string\r\ntype P4 = string[][&quot;push&quot;];  // (...items: string[]) =&gt; number</code>\n        </deckgo-highlight-code>\n<h2>类型提取</h2>\n<p>从复合类型中提取出单个类型，方法有索引访问类型、条件类型+infer、ReturnType</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Person = {\r\n  name: string;\r\n  age: number;\r\n}\r\ntype PersonName = Person[&quot;name&quot;];</code>\n        </deckgo-highlight-code>\n<h2>条件类型</h2>\n<p>根据某些条件得到不同的类型，这里所说的条件是类型兼容性约束</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">T extends U ? X : Y</code>\n        </deckgo-highlight-code>\n<p>上述表达式为若 <code>T</code> 能够赋值给 <code>U</code>，那么类型是 <code>X</code>，否则为 <code>Y</code></p>\n<h2>infer</h2>\n<p><code>infer</code> 声明一个类型变量并且对它进行使用</p>\n<h2>readonly</h2>\n<p>readonly 作用于属性，表示属性不能被修改</p>\n<ul>\n<li>Readonly</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Foo {\r\n  readonly [x: number]: number;\r\n}\r\n\r\ntype Foo = {\r\n  bar: number;\r\n  bas: number;\r\n};\r\n// 将所有属性标记为只读类型\r\ntype FooReadonly = Readonly&lt;Foo&gt;;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>ReadonlyArray</li>\n</ul>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let foo: ReadonlyArray&lt;number&gt; = [1, 2, 3];</code>\n        </deckgo-highlight-code>\n<h2>extends</h2>\n<p>使用 extends 给泛型添加约束</p>\n<p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p>\n<p>extends ：ts 中的 extends 理解为扩展更合适，用 <code>&#x26; </code> 可以实现和 <code>extends</code> 类似的效果。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface ILengthwise {\r\n  length: number;\r\n}\r\nfunction loggingIdentity&lt;T extends ILengthwise&gt;(arg: T): T {\r\n  console.log(arg.length);\r\n  return arg;\r\n}\r\n\r\n// 这时我们需要传入符合约束类型的值，必须包含必须的属性：\r\nloggingIdentity(3);  // Error, number doesn&#39;t have a .length property\r\nloggingIdentity({length: 10, value: 3});</code>\n        </deckgo-highlight-code>\n<h2>implements</h2>\n<p>implements：在 TypeScript 中，<code>implements</code>操作只是为<code>class</code>提供一种类型约束。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Alarm {\r\n  alert(): void;\r\n}\r\nclass Door {\r\n}\r\n\r\nclass SecurityDoor extends Door implements Alarm,接口B {\r\n  alert() {\r\n    console.log(&#39;SecurityDoor alert&#39;);\r\n  }\r\n}\r\n\r\nclass Car implements Alarm {\r\n  alert() {\r\n    console.log(&#39;Car alert&#39;);\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://ts.xcatliu.com/basics/primitive-data-types.html\">原始数据类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/any.html\">任意值</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-inference.html\">类型推论</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/union-types.html\">联合类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-of-object-interfaces.html\">对象的类型——接口</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-of-array.html\">数组的类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-of-function.html\">函数的类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-assertion.html\">类型断言</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/declaration-files.html\">声明文件</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/built-in-objects.html\">内置对象</a></li>\n</ul>\n<h1>Interfaces</h1>\n<p>使用接口（Interfaces）来定义对象的类型，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。除了可用于<a href=\"https://ts.xcatliu.com/advanced/class-and-interfaces.html#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3\">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p>\n<blockquote>\n<p>example</p>\n</blockquote>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Person {\r\n    name: string;\r\n    age: number;\r\n}\r\n\r\nlet tom: Person = {\r\n    name: &#39;Tom&#39;,\r\n    age: 25\r\n};</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式</p>\n</blockquote>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Person {\r\n    name: string;\r\n    age?: number; // 可选\r\n    [propName: string]: string | number; // 任意属性，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集。 \r\n}\r\n\r\nlet tom: Person = {\r\n    name: &#39;Tom&#39;,\r\n    gender: &#39;male&#39;\r\n};</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>使用接口定义类数组数据</p>\n</blockquote>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function sum() {\r\n    let args: {\r\n        [index: number]: number;\r\n        length: number;\r\n        callee: Function;\r\n    } = arguments;\r\n}</code>\n        </deckgo-highlight-code>\n<h2>接口继承</h2>\n<p>接口是一个类型，接口可以继承类和其他interface(包括自定义类)。\r\n接口继承类的时候，只会继承它的实例属性和实例方法。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface ApiError extends Error {\r\n  code: number;\r\n}</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://ts.xcatliu.com/advanced/class-and-interfaces.html\">https://ts.xcatliu.com/advanced/class-and-interfaces.html</a></p>\n<h2>interface 和 type 的区别</h2>\n<ol>\n<li>interface 可以用于 extends 和 implements，type 不能；</li>\n<li><code>type</code> 可以声明联合、交叉类型，interface 不能；</li>\n<li><code>type</code> 可以与 <code>typeof </code> 联用，从变量值推断类型；</li>\n<li>interface 存在声明合并的情况，可以用来重载函数，<a href=\"https://www.tslang.cn/docs/handbook/declaration-merging.html\">详解</a></li>\n</ol>\n<h1>函数</h1>\n<p>在没有提供函数实现的情况下，有两种声明函数类型的方式:</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type LongHand = {\r\n  (a: number): number;\r\n};\r\n\r\n// 内联注释\r\ntype ShortHand = (a: number) =&gt; number;\r\nconst simple: (foo: number) =&gt; string = foo =&gt; foo.toString();</code>\n        </deckgo-highlight-code>\n<p>当你想使用【函数重载】时，只能用第一种方式:</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type LongHandAllowsOverloadDeclarations = {\r\n  (a: number): number;\r\n  (a: string): string;\r\n};</code>\n        </deckgo-highlight-code>\n<p>更复杂的例子</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Complex {\r\n  (foo: string, bar?: number, ...others: boolean[]): number;\r\n}\r\n\r\n// ==============================================\r\ninterface Overloaded {\r\n  (foo: string): string;\r\n  (foo: number): number;\r\n}\r\n\r\n// 实现接口的一个例子：\r\nfunction stringOrNumber(foo: number): number;\r\nfunction stringOrNumber(foo: string): string;\r\nfunction stringOrNumber(foo: any): any {\r\n  if (typeof foo === &#39;number&#39;) {\r\n    return foo * foo;\r\n  } else if (typeof foo === &#39;string&#39;) {\r\n    return `hello ${foo}`;\r\n  }\r\n}\r\n\r\nconst overloaded: Overloaded = stringOrNumber;\r\n\r\n// 使用\r\nconst str = overloaded(&#39;&#39;); // str 被推断为 &#39;string&#39;\r\nconst num = overloaded(123); // num 被推断为 &#39;number&#39;</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>函数重载</p>\n</blockquote>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function padding(all: number);\r\nfunction padding(topAndBottom: number, leftAndRight: number);</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>可实例化</p>\n</blockquote>\n<p>表示需要使用 <code>new</code> 关键字去调用它</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface CallMeWithNewToGetString {\r\n  new (): string;\r\n}\r\n// 使用\r\ndeclare const Foo: CallMeWithNewToGetString;\r\nconst bar = new Foo(); // bar 被推断为 string 类型</code>\n        </deckgo-highlight-code>\n<h1>泛型</h1>\n<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>\n<p>对类型的进一步抽象，与模板的概念相似，例如：</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 定义一个泛型函数\r\nfunction logging&lt;T&gt;(arg: T[]): T[] {\r\n    console.log(arg.length);  // Array has a .length, so no more error\r\n    return arg;\r\n}\r\n\r\n// 分别使用number 和 string 指定泛型的类型\r\nlogging&lt;number&gt;([1,2,3]); // ok\r\nloggin&lt;string&gt;([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]); // ok</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>示例</p>\n</blockquote>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {\r\n    let result: T[] = [];\r\n    for (let i = 0; i &lt; length; i++) {\r\n        result[i] = value;\r\n    }\r\n    return result;\r\n}\r\ncreateArray&lt;string&gt;(3, &#39;x&#39;);\r\n\r\nconst getJSON = &lt;T&gt;(config: { url: string; headers?: { [key: string]: string } }): Promise&lt;T&gt; =&gt; {\r\n  const fetchConfig = {\r\n    method: &#39;GET&#39;,\r\n    Accept: &#39;application/json&#39;,\r\n    &#39;Content-Type&#39;: &#39;application/json&#39;,\r\n    ...(config.headers || {})\r\n  };\r\n  return fetch(config.url, fetchConfig).then&lt;T&gt;(response =&gt; response.json());\r\n};</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>复杂示例</p>\n</blockquote>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">export interface ResponseData&lt;T = any&gt; {\r\n  code: number;\r\n  result: T;\r\n  message: string;\r\n}\r\n\r\nimport Ax from &#39;./axios&#39;;\r\nexport function getUser&lt;T&gt;() {\r\n  return Ax.get&lt;ResponseData&lt;T&gt;&gt;(&#39;/somepath&#39;)\r\n    .then(res =&gt; res.data)\r\n    .catch(err =&gt; console.error(err));\r\n}\r\n\r\n// 使用\r\ninterface User {\r\n  name: string;\r\n  age: number;\r\n}\r\nasync function test() {\r\n  // user 被推断出为\r\n  // {\r\n  //  code: number,\r\n  //  result: { name: string, age: number },\r\n  //  message: string\r\n  // }\r\n  const user = await getUser&lt;User&gt;();\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>数组泛型</p>\n</blockquote>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code>\n        </deckgo-highlight-code>\n<h2>内置高级泛型</h2>\n<p>内置高级类型泛型有： Partial、Required、Pick、Exclude、Omit</p>\n<h3>Partial</h3>\n<p>将某个类型里的属性全部变为可选项</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Partial&lt;T&gt; = { [P in keyof T]  ?:  T[P] };</code>\n        </deckgo-highlight-code>\n<h3>Required</h3>\n<p>将所有属性变为必选</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Required&lt;T&gt; = { [P in keyof T]  -?:   T[P] };\r\n// -? 作用是移除 ?</code>\n        </deckgo-highlight-code>\n<h3>Readonly</h3>\n<p>将某个类型所有属性变为只读属性</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Readonly&lt;T&gt; = {\r\n    readonly [P in keyof T]  : T[P];\r\n};</code>\n        </deckgo-highlight-code>\n<h3>Extract</h3>\n<p>Extract：从类型 T 中提取 U，类似于取交集</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Extract&lt;T, U&gt; = T extends U ? T : never;\r\n\r\n// 使用\r\ntype T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt;void</code>\n        </deckgo-highlight-code>\n<h3>Pick</h3>\n<p>Pick：从类型 T 中选中部分，得到选中的类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Pick&lt;T, K extends keyof T&gt; = {\r\n    [P in K]: T[P];\r\n};\r\n// 使用\r\ninterface Todo {\r\n  title: string;\r\n  description: string;\r\n  completed: boolean;\r\n}\r\ntype TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;\r\nconst todo: TodoPreview = {\r\n  title: &quot;Clean room&quot;,\r\n  completed: false\r\n};</code>\n        </deckgo-highlight-code>\n<h3>Exclude</h3>\n<p>Exclude：从类型 T 中剔除部分类型，得到剩余的类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Exclude&lt;T, U&gt; = T extends U ? never : T;\r\n\r\n// 使用\r\ntype T2 = Exclude&lt;string | number | (() =&gt; void),  Function&gt;; // string | number</code>\n        </deckgo-highlight-code>\n<p>如果 T 能赋值给 U 类型的话，那么就会返回 never 类型，否则返回 T 类型。最终实现的效果就是将 T 中某些属于 U 的类型移除掉</p>\n<h3>Omit</h3>\n<p>用 T 类型中除了 K 类型的所有属性，来构造一个新的类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Omit&lt;T,  K extends keyof any&gt; = Pick&lt;T,  Exclude&lt;keyof T, K&gt;&gt;;\r\n\r\n// 使用\r\ninterface Todo {\r\n  title: string;\r\n  description: string;\r\n  completed: boolean;\r\n}\r\ntype TodoPreview = Omit&lt;Todo, &quot;description&quot;&gt;;\r\nconst todo: TodoPreview = {\r\n  title: &quot;Clean room&quot;,\r\n  completed: false\r\n};</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>Omit 和 Exclude 的区别</p>\n</blockquote>\n<p>xxxxxxxxxxxxxxx</p>\n<h3>Record</h3>\n<p><code>Record</code> :  <code>Record&#x3C;K extends keyof any, T></code> 的作用是将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Record&lt;K extends keyof any, T&gt; = {\r\n    [P in K]: T;\r\n};\r\n\r\ninterface PageInfo {\r\n  title: string;\r\n}\r\ntype Page = &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;;\r\n\r\nconst x: Record&lt;Page, PageInfo&gt; = {\r\n  about: { title: &quot;about&quot; },\r\n  contact: { title: &quot;contact&quot; },\r\n  home: { title: &quot;home&quot; }\r\n};</code>\n        </deckgo-highlight-code>\n<h3>RetureType</h3>\n<p>ReturnType：用于获取函数 <code>T</code> 的返回类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type ReturnType&lt;T extends (...args: any) =&gt; any&gt;   = T extends (...args: any) =&gt; infer R ? R : any;\r\n\r\n// 使用\r\ntype T0 = ReturnType&lt;() =&gt;string&gt;; // string</code>\n        </deckgo-highlight-code>\n<h3>InstanceType</h3>\n<p>获取构造函数类型的实例类型</p>\n<h3>ThisType</h3>\n<p>指定上下文对象的类型，使用 <code>ThisType&#x3C;T></code> 时，必须确保 --noImplicitThis 标志设置为 true</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Person {\r\n    name: string;\r\n    age: number;\r\n}\r\n\r\nconst obj: ThisType&lt;Person&gt; = {\r\n  dosth() {\r\n    this.name // string\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<h3>参考</h3>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&#x26;mid=2247484142&#x26;idx=1&#x26;sn=946ba90d10e2625513f09e60a462b3a7&#x26;scene=19#wechat_redirect\">TS内置高级泛型</a></p>\n<h2>泛型参数组件</h2>\n<blockquote>\n<p>类组件定义及使用</p>\n</blockquote>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 定义泛型参数的组件\r\nclass GenericComponent&lt;P&gt; extends React.Component&lt;P&gt; {\r\n  internalProp: P;\r\n  constructor(props: P) {\r\n    super(props);\r\n    this.internalProp = props;\r\n  }\r\n  render() {\r\n    return null;\r\n  }\r\n}\r\n\r\ntype Props = { a: number; b: string };\r\n\r\n&lt;GenericComponent&lt;Props&gt; a={10} b=&quot;hi&quot; /&gt;; // OK\r\n&lt;GenericComponent&lt;Props&gt; a={10} b={20} /&gt;; // Error</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>函数式组件</p>\n</blockquote>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function GenericComponent&lt;P&gt;(props: P) {\r\n  const internalProp = useRef(props)\r\n  return null;\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>箭头函数</p>\n</blockquote>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 这样会解析错误\r\nconst GenericComponent = &lt;P&gt;(props: P) =&gt;{\r\n  const internalProp = useRef(props);\r\n  return null;\r\n}\r\n\r\n// 泛型必须使用extends关键字才能解析\r\nconst GenericComponent = &lt;P extends any&gt;(props: P) =&gt;{\r\n  const internalProp = useRef(props);\r\n  return null;\r\n}</code>\n        </deckgo-highlight-code>\n<h1>类型兼容</h1>\n<p>一种类型能否赋值给另一种类型，比如 string 不能赋值给 number、子类可以赋值给父类</p>\n<h1>声明文件</h1>\n<p>你可以通过 <code>declare</code> 关键字来告诉 TypeScript，你正在试图表述一个其他地方已经存在的代码</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface ReturnString {\r\n  (): string;\r\n}\r\n\r\ndeclare const foo: ReturnString;\r\nconst bar = foo(); // bar 被推断为一个字符串。</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>demo.d.ts</p>\n</blockquote>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">declare let process: any;\r\n\r\nexport declare enum ButtonsPopoverConfigIconType {\r\n    XiaoSen = &quot;XiaoSen&quot;,\r\n    Scan = &quot;Scan&quot;,\r\n    AppStore = &quot;AppStore&quot;,\r\n    Setting = &quot;Setting&quot;\r\n}\r\nexport interface ButtonsPopoverConfig {\r\n    positionX: number;\r\n    buttons: Array&lt;{\r\n        iconType: ButtonsPopoverConfigIconType;\r\n        title: string;\r\n    }&gt;;\r\n}\r\n\r\nexport declare function openButtonsPopover(cfg: ButtonsPopoverConfig): Promise&lt;ButtonsPopoverResult&gt;;\r\n\r\n// 暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 namespace 下\r\ndeclare namespace jQuery {\r\n  interface AjaxSettings {\r\n    method?: &#39;GET&#39; | &#39;POST&#39;\r\n    data?: any;\r\n  }\r\n  function ajax(url: string, settings?: AjaxSettings): void;\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>声明合并</p>\n</blockquote>\n<p>当一个变量有多种类型时(如：jQuery 既可以作为函数被调用也可以作为对象)可以组合多个声明语句，它们会合并起来。</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">declare function jQuery(selector: string): any;\r\ndeclare namespace jQuery {\r\n    function ajax(url: string, settings?: any): void;\r\n}  </code>\n        </deckgo-highlight-code>\n<h1>模块</h1>\n<p>使用其他模块中声明的类型</p>\n<h1>TS &#x26; React</h1>\n<h2>内置类型</h2>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Props = { \r\n onClick(e: MouseEvent&lt;HTMLElement&gt;): void\r\n children?: ReactNode \r\n}\r\n \r\ntype RenderCallback = (args: ToggleableComponentProps) =&gt; JSX.Element;</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>React源码</p>\n</blockquote>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type ComponentType&lt;P = {}&gt; = ComponentClass&lt;P&gt; | FunctionComponent&lt;P&gt;;\r\n\r\ninterface ReactDOM extends ReactHTML, ReactSVG { }\r\n\r\ninterface ReactElement&lt;P = any, T extends string | JSXElementConstructor&lt;any&gt; = string | JSXElementConstructor&lt;any&gt;&gt; {\r\ntype: T;\r\nprops: P;\r\nkey: Key | null;\r\n}\r\n\r\ntype ReactElement = ReactComponentElement | ReactDOMElement;\r\n\r\ninterface ReactComponentElement&lt;\r\nT extends keyof JSX.IntrinsicElements | JSXElementConstructor&lt;any&gt;,\r\nP = Pick&lt;ComponentProps&lt;T&gt;, Exclude&lt;keyof ComponentProps&lt;T&gt;, &#39;key&#39; | &#39;ref&#39;&gt;&gt;\r\n&gt; extends ReactElement&lt;P, Exclude&lt;T, number&gt;&gt; { }\r\n\r\n\r\ntype ReactText = string | number;\r\ntype ReactChild = ReactElement | ReactText;\r\n\r\ntype ReactFragment = {} | ReactNodeArray;\r\n\r\ntype ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\r\n\r\ninterface ReactNodeArray extends Array&lt;ReactNode&gt; {}\r\n\r\n//------------------------------------------------------\r\ninterface ReactDOM extends ReactHTML, ReactSVG { }\r\n// ReactHIML:  a\\h\\div等\r\n\r\ntype ReactNode = ReactElement | ReactFragment | ReactText;\r\n\r\n// type ReactElement = ReactComponentElement | ReactDOMElement;\r\n\r\ninterface ReactDOM extends ReactHTML, ReactSVG { }\r\n\r\ntype ReactDOMElement = {\r\ntype : string,\r\nprops : {\r\n  children : ReactNodeList,\r\n  className : string,\r\n  etc.\r\n},\r\nkey : string | boolean | number | null,\r\nref : string | null\r\n};\r\n\r\ntype ReactComponentElement&lt;TProps&gt; = {\r\ntype : ReactClass&lt;TProps&gt;,\r\nprops : TProps,\r\nkey : string | boolean | number | null,\r\nref : string | null\r\n};\r\n\r\ntype ReactFragment = Array&lt;ReactNode | ReactEmpty&gt;;\r\n\r\ntype ReactNodeList = ReactNode | ReactEmpty;\r\n\r\ntype ReactText = string | number;\r\n\r\ntype ReactEmpty = null | undefined | boolean;</code>\n        </deckgo-highlight-code>\n<p><strong><a href=\"https://gist.github.com/sebmarkbage/fcb1b6ab493b0c77d589\">React Virtual DOM 术语</a></strong></p>\n<ul>\n<li>ReactElement</li>\n<li>ReactNode</li>\n</ul>\n<blockquote>\n<p>一些<code>React</code>的内置类型</p>\n</blockquote>\n<ul>\n<li>\n<p><code>React.ReactElement</code> —— 使用<code>React.createElement</code>创建的，可以简单理解为<code>React</code>中的<code>JSX</code>的元素</p>\n</li>\n<li>\n<p><code>React.ReactNode</code> —— <code>&#x3C;div>xxx&#x3C;/div></code> xxx的合法类型</p>\n</li>\n<li>\n<p><code>React.ReactDOM</code></p>\n</li>\n<li>\n<p><code>React.CSSProperties</code> —— 组件内联的<code>style</code>对象的类型</p>\n</li>\n<li>\n<p><code>React.RefObject</code> —— <code>React.createRef</code>创建的类型，只读不可改</p>\n</li>\n<li>\n<p><code>React.MutableRefObject</code> —— <code>useRef</code>创建的类型，可以修改</p>\n</li>\n</ul>\n<blockquote>\n<p>内置事件类型</p>\n</blockquote>\n<ul>\n<li><code>React.MouseEventHandler&#x3C;HEMLInputElement></code></li>\n<li><code>React.ChangeEventHandler&#x3C;HTMLInputElement></code></li>\n<li><code>React.FocusEventHandler&#x3C;HTMLInputElement></code></li>\n</ul>\n<blockquote>\n<p>无状态组件</p>\n</blockquote>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">\r\nimport { SFC } from &#39;react&#39;\r\nimport { MouseEvent } from &#39;react&#39;\r\nimport * as React from &#39;react&#39;\r\ninterface IProps {\r\n  onClick (event: MouseEvent&lt;HTMLDivElement&gt;): void,\r\n}\r\nconst Button: SFC&lt;IProps&gt; = ({onClick, children}) =&gt; {\r\n  return (\r\n    &lt;div onClick={onClick}&gt;\r\n      { children }\r\n    &lt;/div&gt;\r\n  )\r\n}\r\nexport default Button</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>函数组件</p>\n</blockquote>\n<p>函数组件定义的方式有两种：</p>\n<ol>\n<li>使用<code>React.FC</code></li>\n</ol>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface IProps {\r\n  value: string;\r\n  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void\r\n  // 使用React.FC定义函数式组件时不用声明children\r\n}\r\nconst App: React.FC&lt;IProps&gt; = (props)=&gt;{\r\n  return &lt;div&gt;{children}&lt;/div&gt;\r\n}</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>使用接口定义<code>props</code></li>\n</ol>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface IProps{\r\n  value: string;\r\n  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void\r\n  children?: React.ReactNode; // 需要自己定义children的类型\r\n}\r\nfunction App(props:IProps){\r\n  return &lt;div&gt;{children}&lt;/div&gt;\r\n}</code>\n        </deckgo-highlight-code>","id":"1ad2677d-117a-56a3-ac93-8db5cb8ab4a1","parent":{"name":"TS基础","base":"TS基础.md","mtime":"2023-07-24T09:04:10.569Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/TS基础/"}},"staticQueryHashes":["3957182205"]}