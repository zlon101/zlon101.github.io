{"componentChunkName":"component---src-templates-post-js","path":"/articles/TS基础/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/TS基础/"},"html":"<h2>如何定义一个类型，或得到一个类型？</h2>\n<ul>\n<li>\n<p><code>keyof</code> 后面跟一个类型，获取该类型的所有 key，产生联合类型。\r\n<code>typeof</code> 后面跟一个变量，获取变量的类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type State = Readonly&lt;typeof initialState&gt;;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>类型别名</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Props = { \r\n onClick(e: MouseEvent&lt;HTMLElement&gt;): void\r\n children?: ReactNode \r\n}\r\n \r\ntype RenderCallback = (args: ToggleableComponentProps) =&gt; JSX.Element;</code>\n        </deckgo-highlight-code>\n<p><strong><code>type</code> 和 <code>interface</code> 的区别？</strong></p>\n</li>\n<li>\n<p><strong>类型断言</strong></p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const initialState = {name: &#39;&#39;}\r\ntype State = Readonly&lt;typeof initialState&gt;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>查找类型\r\n从已有的类型中查找</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const initialState = {\r\n  show: false,\r\n};\r\ntype State = Readonly&lt;typeof initialState&gt;;\r\ntype ToggleableComponentProps = {\r\n  show: State[&#39;show&#39;];\r\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>从实现中推断类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type ToggleableComponentProps = {\r\n  toggle: Toggleable[&#39;toggle&#39;];\r\n  // Toggleable 本来就是类型，不能是变量\r\n};\r\n\r\nexport class Toggleable extends Component&lt;Props, State&gt; {\r\n  readonly state: State = initialState;\r\n  render() {\r\n    // \r\n  }\r\n  private toggle = (event: MouseEvent&lt;HTMLElement&gt;) =&gt; this.setState(updateShowState);\r\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2><code>ReactNode</code> 、 <code>ReactElement</code> 和 <code>JSX.Element</code> 的区别？</h2>\n<ul>\n<li><code>children?: React.ReactNode </code></li>\n</ul>\n<h1>概况</h1>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 621px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 71.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACuklEQVQ4y32Ta28aRxSG94/3W9Xf0KpS+6FN3TpWjO0a2/iixCEOEDCYa2RDzYKXhV32fr/xVKwhcqq2M3q0Z45m33nnzIxwdnrG4cEhpbMSxeMT9t8UeL27R7VaQ5JmyDMZeTZnMVdQ5grqQmWpLFmqGpqmoWs6ur7GQDdMhKVhYDjOFyzPw/Y9TNdBty10287z67HpulhrPBfb8/D8AD/YEuYIURyzbiv48t3GL9t/5f6JEIZRHmSrVU66ev51PFcp1Ttc3nbRLDvPbef8H0IYRV+tmm0ExcWSwrsqB+8qGI77r4IvjWy7ICtLdq4q/FG6ZiROeF1u8r7e4n4qc1DpclRpIz5JHFda/Fm5I96UKNuIPYu+3HIQcNcb0Oj0kGcSzW6f4eMjk8mE6l2Hym0TWZboD0e0e30c28L1XNI4zIXTLPvKpdAYPHBcrpGkCcUPddoPj5iOw+7FNZqh0/trTPGmjh/4nNeaVDt95KXG7mWZhW5s3G7LkCHU2gP2L8s4nsvJxwbvb9vIqsovxQskRaE7GnN0XcFybE4+fuJTt49mWfx2esVwLJKlCUHowyrLxQVFUbl/GG7uQUIYeCRpTOg/H4S8mDOeiHn8KI5RliphHNHq9ZirKtVmi6EoUu90mc4XCDvnZb75eQ/DMonTJHcSRCGa+bydN+U63746ZDKT+G7niF9P3yIpKj8USlzVGvxYOONV8YLvD875/fQK4WH8RLU9IE3TvAZxtLaf4m8cjqYS9f5nojiiMbhnOJmiOw77b29QTRN/fUBpgm2bxHGEkIQRrmWTJglP8oxyq0ft84hGt0eSxFiWiWObpFmKbZlEoc9YkvmpcMJQnGAYOrbrYJhGPkcI1u/QCwgCn6k8o3DTZK98y4dmJ3dpr9+3Y+P5HrZj5/iBl9c6DIN87LgOQRjk1+ZvAk4QuOg/yRkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image-20200820171028681\" title=\"image-20200820171028681\" src=\"/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png\" srcset=\"/static/2d5d45cf184dbee81bfeca5b3846a42f/772e8/image-20200820171028681.png 200w,\n/static/2d5d45cf184dbee81bfeca5b3846a42f/e17e5/image-20200820171028681.png 400w,\n/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png 621w\" sizes=\"(max-width: 621px) 100vw, 621px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>  \n<img src=\"assets/TS%E5%9F%BA%E7%A1%80/image-20201114122155270.png\" alt=\"image-20201114122155270\" style=\"zoom:50%;\" />  \n<p>上面的是父级，下面是子级，子级类型可以赋值给父级。</p>\n<p><strong>TypeScript体系</strong></p>\n<p><strong>值 、变量 和 类型</strong></p>\n<ul>\n<li>类型的标注/推导确定</li>\n<li>类型的检查，检查数据类型是否安全</li>\n</ul>\n<h1>TS资源</h1>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/docs/home.html\">官网</a>  <a href=\"https://www.tslang.cn/\">中文</a></li>\n<li><a href=\"https://ts.xcatliu.com/\">TS入门教程-阮一峰</a></li>\n<li><a href=\"https://zhongsp.gitbook.io/typescript-handbook/\">非官方中文版</a></li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/#why\">深入理解TS</a></li>\n</ul>\n<h1>泛型参数组件</h1>\n<ul>\n<li>\n<p>类组件定义及使用</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 定义泛型参数的组件\r\nclass GenericComponent&lt;P&gt; extends React.Component&lt;P&gt; {\r\n  internalProp: P;\r\n  constructor(props: P) {\r\n    super(props);\r\n    this.internalProp = props;\r\n  }\r\n  render() {\r\n    return null;\r\n  }\r\n}\r\n\r\ntype Props = { a: number; b: string };\r\n\r\n&lt;GenericComponent&lt;Props&gt; a={10} b=&quot;hi&quot; /&gt;; // OK\r\n&lt;GenericComponent&lt;Props&gt; a={10} b={20} /&gt;; // Error</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数式组件</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function GenericComponent&lt;P&gt;(props: P) {\r\n  const internalProp = useRef(props)\r\n  return null;\r\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>箭头函数</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 这样会解析错误\r\nconst GenericComponent = &lt;P&gt;(props: P) =&gt;{\r\n  const internalProp = useRef(props);\r\n  return null;\r\n}\r\n\r\n// 泛型必须使用extends关键字才能解析\r\nconst GenericComponent = &lt;P extends any&gt;(props: P) =&gt;{\r\n  const internalProp = useRef(props);\r\n  return null;\r\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h1>关键字</h1>\n<p>extends ：ts 中的 extends 理解为扩展更合适，用 <code>&#x26; </code> 可以实现和 <code>extends</code> 类似的效果。</p>\n<p>implements：在 TypeScript 中，<code>implements</code>操作只是为<code>class</code>提供一种类型约束。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Alarm {\r\n  alert(): void;\r\n}\r\nclass Door {\r\n}\r\n\r\nclass SecurityDoor extends Door implements Alarm,接口B {\r\n  alert() {\r\n    console.log(&#39;SecurityDoor alert&#39;);\r\n  }\r\n}\r\n\r\nclass Car implements Alarm {\r\n  alert() {\r\n    console.log(&#39;Car alert&#39;);\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>example</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">(&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];  // 类型断言\r\n\r\n\r\ninterface Padder {\r\n    getPaddingString(): string\r\n}\r\nclass SpaceRepeatingPadder implements Padder {\r\n    constructor(private numSpaces: number) { }\r\n    getPaddingString() {\r\n        return Array(this.numSpaces + 1).join(&quot; &quot;);\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>使用类型断言手动去除某个类型中的<code>null</code>和<code>undefined</code></p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">name!.charAt(0)  // name为undefined 时会报错,!的意思是显式告诉编译器name不会为undefined\r\n\r\nname?.charAt(0) // name为undefined 时不会报错</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数类型</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">export interface ThemeContextValue {\r\n  theme: Theme;\r\n  onThemeChange: (theme: Theme) =&gt; void;\r\n  handleClick?(e: React.MouseEvent&lt;HTMLElement&gt;):void;\r\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>extends</h2>\n<p>使用 extends 给泛型添加约束</p>\n<p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface ILengthwise {\r\n  length: number;\r\n}\r\nfunction loggingIdentity&lt;T extends ILengthwise&gt;(arg: T): T {\r\n  console.log(arg.length);\r\n  return arg;\r\n}\r\n\r\n// 这时我们需要传入符合约束类型的值，必须包含必须的属性：\r\nloggingIdentity(3);  // Error, number doesn&#39;t have a .length property\r\nloggingIdentity({length: 10, value: 3});</code>\n        </deckgo-highlight-code>\n<h1>参考</h1>\n<ul>\n<li><a href=\"https://ts.xcatliu.com/basics/primitive-data-types.html\">原始数据类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/any.html\">任意值</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-inference.html\">类型推论</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/union-types.html\">联合类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-of-object-interfaces.html\">对象的类型——接口</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-of-array.html\">数组的类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-of-function.html\">函数的类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-assertion.html\">类型断言</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/declaration-files.html\">声明文件</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/built-in-objects.html\">内置对象</a></li>\n</ul>\n<h1>数据类型</h1>\n<blockquote>\n<p>类型是值的集合</p>\n<p>Undefined  只有<code>undefined</code>一个元素的集合</p>\n<p>Null  只有<code>null</code>一个元素的集合</p>\n<p>Boolean  有两个元素<code>false</code>和<code>true</code>的集合</p>\n<p>...</p>\n</blockquote>\n<p><strong>指定变量的类型</strong></p>\n<ul>\n<li>\n<p>使用接口（Interfaces）来定义对象的类型</p>\n</li>\n<li>\n<p>指定变量为函数</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Cat {\r\n  name: string;\r\n  run(): void;\r\n  onBlur?: (value: string, e?: React.FocusEvent&lt;HTMLInputElement&gt;) =&gt; void;\r\n}\r\n\r\nlistener: (ev: MouseEvent) =&gt; any  // 指定listener 是一个函数，同时指定该函数的输入输出类型\r\n\r\nlet mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {\r\n    return x + y;\r\n};</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>TS简单的说就是为JS中的变量指定了类型，JS中的变量本身是没有类型的，比如：</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let x = 1;\r\nx = &#39;anc&#39;;\r\nx = [1,2,3];</code>\n        </deckgo-highlight-code>\n<p>上述中变量<code>x</code>既可以存储数字也可以存储字符串，JS中的某一个变量可以存储任意类型的值。有了TS就可以为变量指定一个类型，这样在编译阶段就可以检查变量是否赋予了正确的类型，提前发现错误，配合编辑器的语法提示能有效提高开发效率。</p>\n<p>TS中描述类型的方法有：</p>\n<ol>\n<li>\n<p>原始类型: numble  string   Boolean</p>\n</li>\n<li>\n<p>字面量类型：123  'abc'</p>\n</li>\n<li>\n<p>接口：描述一类对象的类型，例如：</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface IPerson{\r\n  name: string;\r\n  age: number\r\n}\r\n\r\nlet me: IPerson = {\r\n  name: &#39;abc&#39;,\r\n  aeg: 10\r\n}\r\nlet you: IPerson = {\r\n  name: 12,  // 报错：name必须是string\r\n}\r\n// 报错 you 必须同时包含 name 和 age 两个属性</code>\n        </deckgo-highlight-code>\n<p>上述代码定义了一个名为<code>IPerson</code>的接口来表示'人'这一类对象的类型，如果某个对象被指定为<code>IPerson</code>这种类型，那这个对象就必须符合<code>IPerson</code>描述的特征，即包含<code>name</code>和<code>age </code>两个属性。</p>\n</li>\n<li>\n<p>别名\r\n与接口不同，接口定义了一种新的类型，别名只是对现有的类型声明了新的名字，别名通常与字面量类型、联合类型、交叉类型、泛型使用，例如：</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 为string起一个别名Name，\r\ntype Name = string;\r\nlet myName:Name = &#39;abc&#39;;\r\n\r\n// 等号右边是字符串字面量类型，Easing是这个字面量类型的别名\r\ntype Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;\r\nlet easing: Easing = &#39;ease-in&#39;;\r\nlet easing: Easing = &#39;other&#39;; // 报错\r\n// easing这个变量只能被赋值为&quot;ease-in&quot; 或 &quot;ease-out&quot; 或 &quot;ease-in-out&quot;这三个字符串中的一个，赋值为其他值就会报错</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code>never</code>  <code>undefined</code>   <code>null</code>\r\n<code>never</code>  <code>undefined</code>   <code>null</code> 是TS中三中特殊的类型</p>\n<ul>\n<li><code>never</code> 表示永远不存在的值的类型，即这个类型没有对应的值</li>\n<li><code>undefined</code>这个类型只有一个值，就是<code>undefined</code></li>\n<li><code>null</code>与<code>undefined</code>同理</li>\n</ul>\n</li>\n<li>\n<p>联合类型\r\n多个类型的或运算，逆 <code>extends</code> ，生成的类型是参与运算的类型的父类型。</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 声明了NumOrStr为一个联合类型\r\ntype NumOrStr = sting | number;\r\n\r\nlet x: NumOrStr = 1; // success\r\nx = &#39;abc&#39;; // success\r\nx = [1]; // error</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>交叉类型\r\n和并多个类型</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Parent1 = {\r\n  name: string;\r\n}\r\ntype Parent2 = {\r\n  age: number;\r\n}\r\ntype Child = Parent1 &amp; Parent2;\r\n\r\n// 子级类型可以赋值给父类型(属性只能多不能少)\r\nlet my: Parent1 = {\r\n  age: 2,\r\n  name: &#39;&#39;\r\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>泛型：对类型的进一步抽象，与模板的概念相似，例如：</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 定义一个泛型函数\r\nfunction logging&lt;T&gt;(arg: T[]): T[] {\r\n    console.log(arg.length);  // Array has a .length, so no more error\r\n    return arg;\r\n}\r\n\r\n// 分别使用number 和 string 指定泛型的类型\r\nlogging&lt;number&gt;([1,2,3]); // ok\r\nloggin&lt;string&gt;([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]); // ok</code>\n        </deckgo-highlight-code>\n</li>\n</ol>\n<h1>接口</h1>\n<blockquote>\n<p>使用接口（Interfaces）来定义对象的类型，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。除了可用于<a href=\"https://ts.xcatliu.com/advanced/class-and-interfaces.html#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3\">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p>\n</blockquote>\n<ul>\n<li>\n<p>demo</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Person {\r\n    name: string;\r\n    age: number;\r\n}\r\n\r\nlet tom: Person = {\r\n    name: &#39;Tom&#39;,\r\n    age: 25\r\n};\r\n\r\n// 有时候我们希望一个接口允许有任意的属性，可以使用如下方式\r\ninterface Person {\r\n    name: string;\r\n    age?: number; // 可选\r\n    [propName: string]: string | number; // 任意属性，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集。 \r\n}\r\n\r\nlet tom: Person = {\r\n    name: &#39;Tom&#39;,\r\n    gender: &#39;male&#39;\r\n};\r\n</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>使用接口定义类数组数据</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function sum() {\r\n    let args: {\r\n        [index: number]: number;\r\n        length: number;\r\n        callee: Function;\r\n    } = arguments;\r\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>接口继承</h2>\n<p>接口是一个类型，接口可以继承类和其他interface(包括自定义类)。\r\n接口继承类的时候，只会继承它的实例属性和实例方法。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface ApiError extends Error {\r\n  code: number;\r\n}</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://ts.xcatliu.com/advanced/class-and-interfaces.html\">https://ts.xcatliu.com/advanced/class-and-interfaces.html</a></p>\n<h2>interface 和 type 的区别</h2>\n<p>​    1)  interface 可以用于 extends 和 implements，type 不能；</p>\n<p>​    2)  <code>type</code> 可以声明联合、交叉类型，interface 不能；</p>\n<p>​    3)  <code>type</code> 可以与 <code>typeof </code> 联用，从变量值推断类型；</p>\n<p>​    4)  interface 存在声明合并的情况，可以用来重在函数，详解：<a href=\"https://www.tslang.cn/docs/handbook/declaration-merging.html\">https://www.tslang.cn/docs/handbook/declaration-merging.html</a></p>\n<h1>泛型</h1>\n<blockquote>\n<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>\n</blockquote>\n<ul>\n<li>\n<p>demo</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {\r\n    let result: T[] = [];\r\n    for (let i = 0; i &lt; length; i++) {\r\n        result[i] = value;\r\n    }\r\n    return result;\r\n}\r\n\r\ncreateArray&lt;string&gt;(3, &#39;x&#39;);</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>数组泛型</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h1>内置高级泛型</h1>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// extends 表示类型约束\r\nfunction copy&lt;T extends BaseType&gt;(arg: T): T {\r\n  return arg;\r\n}\r\n// 条件类型\r\ntype Extract&lt;T, U&gt; = T extends U ? T : never;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>内置高级类型泛型： <code>Partial Required Pick Exclude Omit</code></p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 将所有接口变为可选\r\ntype Partial&lt;T&gt; = { [P in keyof T]?: T[P] };\r\n\r\n// 将所有接口变为必选\r\ntype Required&lt;T&gt; = { [P in keyof T]-?: T[P] };\r\n\r\n// 从 T 中取出 一系列 K 的属性\r\ntype Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P] };\r\n\r\ntype Readonly&lt;T&gt; = {\r\n    readonly [P in keyof T]: T[P];\r\n};\r\n\r\n/**\r\n * Exclude from T those types that are assignable to U\r\n * T 是联合类型？\r\n */\r\ntype Exclude&lt;T, U&gt; = T extends U ? never : T;\r\n\r\n/**\r\n * Extract from T those types that are assignable to U\r\n */\r\ntype Extract&lt;T, U&gt; = T extends U ? T : never;\r\n\r\n/**\r\n * Construct a type with the properties of T except for those in type K.\r\n */\r\ntype Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code>Record</code> :  <code>Record&#x3C;K extends keyof any, T></code> 的作用是将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Record&lt;K extends keyof any, T&gt; = {\r\n    [P in K]: T;\r\n};\r\n\r\n\r\ninterface PageInfo {\r\n  title: string;\r\n}\r\ntype Page = &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;;\r\n\r\nconst x: Record&lt;Page, PageInfo&gt; = {\r\n  about: { title: &quot;about&quot; },\r\n  contact: { title: &quot;contact&quot; },\r\n  home: { title: &quot;home&quot; }\r\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>Pick：从类型 T 中选中部分，得到选中的类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Pick&lt;T, K extends keyof T&gt; = {\r\n    [P in K]: T[P];\r\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>Exclude：从类型 T 中剔除部分类型，得到剩余的类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Exclude&lt;T, U&gt; = T extends U ? never : T;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>Extract：从类型 T 中提取部分，得到提取的</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Extract&lt;T, U&gt; = T extends U ? T : never;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>ReturnType：用于获取函数 <code>T</code> 的返回类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>参考：</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&#x26;mid=2247484142&#x26;idx=1&#x26;sn=946ba90d10e2625513f09e60a462b3a7&#x26;scene=19#wechat_redirect\">TS内置高级泛型</a></p>\n<h1>声明文件</h1>\n<ul>\n<li>\n<p>demo.d.ts</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">export declare enum ButtonsPopoverConfigIconType {\r\n    XiaoSen = &quot;XiaoSen&quot;,\r\n    Scan = &quot;Scan&quot;,\r\n    AppStore = &quot;AppStore&quot;,\r\n    Setting = &quot;Setting&quot;\r\n}\r\nexport interface ButtonsPopoverConfig {\r\n    positionX: number;\r\n    buttons: Array&lt;{\r\n        iconType: ButtonsPopoverConfigIconType;\r\n        title: string;\r\n    }&gt;;\r\n}\r\n\r\nexport declare function openButtonsPopover(cfg: ButtonsPopoverConfig): Promise&lt;ButtonsPopoverResult&gt;;\r\n\r\n// 暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 namespace 下\r\ndeclare namespace jQuery {\r\n  interface AjaxSettings {\r\n    method?: &#39;GET&#39; | &#39;POST&#39;\r\n    data?: any;\r\n  }\r\n  function ajax(url: string, settings?: AjaxSettings): void;\r\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>声明合并：当一个变量有多种类型时(如：jQuery 既可以作为函数被调用也可以作为对象)\r\n可以组合多个声明语句，它们会合并起来。</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">declare function jQuery(selector: string): any;\r\ndeclare namespace jQuery {\r\n    function ajax(url: string, settings?: any): void;\r\n}  </code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h1>TS &#x26; React</h1>\n<h2>内置类型</h2>\n<p>React源码</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type ComponentType&lt;P = {}&gt; = ComponentClass&lt;P&gt; | FunctionComponent&lt;P&gt;;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface ReactDOM extends ReactHTML, ReactSVG { }\r\n\r\ninterface ReactElement&lt;P = any, T extends string | JSXElementConstructor&lt;any&gt; = string | JSXElementConstructor&lt;any&gt;&gt; {\r\ntype: T;\r\nprops: P;\r\nkey: Key | null;\r\n}\r\n\r\ntype ReactElement = ReactComponentElement | ReactDOMElement;\r\n\r\ninterface ReactComponentElement&lt;\r\nT extends keyof JSX.IntrinsicElements | JSXElementConstructor&lt;any&gt;,\r\nP = Pick&lt;ComponentProps&lt;T&gt;, Exclude&lt;keyof ComponentProps&lt;T&gt;, &#39;key&#39; | &#39;ref&#39;&gt;&gt;\r\n&gt; extends ReactElement&lt;P, Exclude&lt;T, number&gt;&gt; { }\r\n\r\n\r\ntype ReactText = string | number;\r\ntype ReactChild = ReactElement | ReactText;\r\n\r\ntype ReactFragment = {} | ReactNodeArray;\r\n\r\ntype ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\r\n\r\ninterface ReactNodeArray extends Array&lt;ReactNode&gt; {}\r\n\r\n//------------------------------------------------------\r\ninterface ReactDOM extends ReactHTML, ReactSVG { }\r\n// ReactHIML:  a\\h\\div等\r\n\r\ntype ReactNode = ReactElement | ReactFragment | ReactText;\r\n\r\n// type ReactElement = ReactComponentElement | ReactDOMElement;\r\n\r\ninterface ReactDOM extends ReactHTML, ReactSVG { }\r\n\r\ntype ReactDOMElement = {\r\ntype : string,\r\nprops : {\r\n  children : ReactNodeList,\r\n  className : string,\r\n  etc.\r\n},\r\nkey : string | boolean | number | null,\r\nref : string | null\r\n};\r\n\r\ntype ReactComponentElement&lt;TProps&gt; = {\r\ntype : ReactClass&lt;TProps&gt;,\r\nprops : TProps,\r\nkey : string | boolean | number | null,\r\nref : string | null\r\n};\r\n\r\ntype ReactFragment = Array&lt;ReactNode | ReactEmpty&gt;;\r\n\r\ntype ReactNodeList = ReactNode | ReactEmpty;\r\n\r\ntype ReactText = string | number;\r\n\r\ntype ReactEmpty = null | undefined | boolean;</code>\n        </deckgo-highlight-code>\n<p><strong><a href=\"https://gist.github.com/sebmarkbage/fcb1b6ab493b0c77d589\">React Virtual DOM 术语</a></strong></p>\n<ul>\n<li>ReactElement</li>\n<li>ReactNode</li>\n</ul>\n<p>一些<code>React</code>的内置类型</p>\n<ul>\n<li><code>React.ReactElement</code> —— 使用<code>React.createElement</code>创建的，可以简单理解为<code>React</code>中的<code>JSX</code>的元素</li>\n<li><code>React.ReactNode</code> —— <code>&#x3C;div>xxx&#x3C;/div></code> xxx的合法类型</li>\n<li><code>React.ReactDOM</code></li>\n<li></li>\n<li><code>React.CSSProperties</code> —— 组件内联的<code>style</code>对象的类型</li>\n<li><code>React.RefObject</code> —— <code>React.createRef</code>创建的类型，只读不可改</li>\n<li><code>React.MutableRefObject</code> —— <code>useRef</code>创建的类型，可以修改</li>\n</ul>\n<p><strong>内置事件类型</strong></p>\n<ul>\n<li>\n<p><code>React.MouseEventHandler&#x3C;HEMLInputElement></code></p>\n</li>\n<li>\n<p><code>React.ChangeEventHandler&#x3C;HTMLInputElement></code></p>\n</li>\n<li>\n<p><code>React.FocusEventHandler&#x3C;HTMLInputElement></code></p>\n</li>\n<li>\n<p>无状态组件</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">\r\nimport { SFC } from &#39;react&#39;\r\nimport { MouseEvent } from &#39;react&#39;\r\nimport * as React from &#39;react&#39;\r\ninterface IProps {\r\n  onClick (event: MouseEvent&lt;HTMLDivElement&gt;): void,\r\n}\r\nconst Button: SFC&lt;IProps&gt; = ({onClick, children}) =&gt; {\r\n  return (\r\n    &lt;div onClick={onClick}&gt;\r\n      { children }\r\n    &lt;/div&gt;\r\n  )\r\n}\r\nexport default Button</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数组件\r\n函数组件定义的方式有两种：</p>\n<ol>\n<li>使用<code>React.FC</code></li>\n</ol>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface IProps {\r\n  value: string;\r\n  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void\r\n  // 使用React.FC定义函数式组件时不用声明children\r\n}\r\nconst App: React.FC&lt;IProps&gt; = (props)=&gt;{\r\n  return &lt;div&gt;{children}&lt;/div&gt;\r\n}</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>使用接口定义<code>props</code></li>\n</ol>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface IProps{\r\n  value: string;\r\n  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void\r\n  children?: React.ReactNode; // 需要自己定义children的类型\r\n}\r\nfunction App(props:IProps){\r\n  return &lt;div&gt;{children}&lt;/div&gt;\r\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>","id":"a9c33a5a-5fa7-58cc-9ebf-c2b4a554bd93","parent":{"name":"TS基础","base":"TS基础.md","mtime":"2023-03-08T03:39:20.006Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/TS基础/"}},"staticQueryHashes":["3957182205"]}