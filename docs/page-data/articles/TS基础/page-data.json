{"componentChunkName":"component---src-templates-post-js","path":"/articles/TS基础/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/TS基础/"},"html":"<h5>如何定义一个类型，或得到一个类型？</h5>\n<ul>\n<li>\n<p><code>keyof</code> 后面跟一个类型，获取该类型的所有 key，产生联合类型。\n<code>typeof</code> 后面跟一个变量，获取变量的类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type State = Readonly&lt;typeof initialState&gt;;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>类型别名</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Props = { \nonClick(e: MouseEvent&lt;HTMLElement&gt;): void\nchildren?: ReactNode \n}\n\ntype RenderCallback = (args: ToggleableComponentProps) =&gt; JSX.Element;</code>\n        </deckgo-highlight-code>\n<p><strong><code>type</code> 和 <code>interface</code> 的区别？</strong>  </p>\n</li>\n<li>\n<p><strong>类型断言</strong>  </p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const initialState = {name: &#39;&#39;}\ntype State = Readonly&lt;typeof initialState&gt;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>查找类型\n从已有的类型中查找</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const initialState = {\nshow: false,\n};\ntype State = Readonly&lt;typeof initialState&gt;;\ntype ToggleableComponentProps = {\nshow: State[&#39;show&#39;];\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>从实现中推断类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type ToggleableComponentProps = {\ntoggle: Toggleable[&#39;toggle&#39;];\n// Toggleable 本来就是类型，不能是变量\n};\n\nexport class Toggleable extends Component&lt;Props, State&gt; {\nreadonly state: State = initialState;\nrender() {\n  // \n}\nprivate toggle = (event: MouseEvent&lt;HTMLElement&gt;) =&gt; this.setState(updateShowState);\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5><code>ReactNode</code> 、 <code>ReactElement</code> 和 <code>JSX.Element</code> 的区别？</h5>\n<ul>\n<li><code>children?: React.ReactNode</code>  </li>\n</ul>\n<h4>概况</h4>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 621px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 71.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACuklEQVQ4y32Ta28aRxSG94/3W9Xf0KpS+6FN3TpWjO0a2/iixCEOEDCYa2RDzYKXhV32fr/xVKwhcqq2M3q0Z45m33nnzIxwdnrG4cEhpbMSxeMT9t8UeL27R7VaQ5JmyDMZeTZnMVdQ5grqQmWpLFmqGpqmoWs6ur7GQDdMhKVhYDjOFyzPw/Y9TNdBty10287z67HpulhrPBfb8/D8AD/YEuYIURyzbiv48t3GL9t/5f6JEIZRHmSrVU66ev51PFcp1Ttc3nbRLDvPbef8H0IYRV+tmm0ExcWSwrsqB+8qGI77r4IvjWy7ICtLdq4q/FG6ZiROeF1u8r7e4n4qc1DpclRpIz5JHFda/Fm5I96UKNuIPYu+3HIQcNcb0Oj0kGcSzW6f4eMjk8mE6l2Hym0TWZboD0e0e30c28L1XNI4zIXTLPvKpdAYPHBcrpGkCcUPddoPj5iOw+7FNZqh0/trTPGmjh/4nNeaVDt95KXG7mWZhW5s3G7LkCHU2gP2L8s4nsvJxwbvb9vIqsovxQskRaE7GnN0XcFybE4+fuJTt49mWfx2esVwLJKlCUHowyrLxQVFUbl/GG7uQUIYeCRpTOg/H4S8mDOeiHn8KI5RliphHNHq9ZirKtVmi6EoUu90mc4XCDvnZb75eQ/DMonTJHcSRCGa+bydN+U63746ZDKT+G7niF9P3yIpKj8USlzVGvxYOONV8YLvD875/fQK4WH8RLU9IE3TvAZxtLaf4m8cjqYS9f5nojiiMbhnOJmiOw77b29QTRN/fUBpgm2bxHGEkIQRrmWTJglP8oxyq0ft84hGt0eSxFiWiWObpFmKbZlEoc9YkvmpcMJQnGAYOrbrYJhGPkcI1u/QCwgCn6k8o3DTZK98y4dmJ3dpr9+3Y+P5HrZj5/iBl9c6DIN87LgOQRjk1+ZvAk4QuOg/yRkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image-20200820171028681\" title=\"image-20200820171028681\" src=\"/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png\" srcset=\"/static/2d5d45cf184dbee81bfeca5b3846a42f/772e8/image-20200820171028681.png 200w,\n/static/2d5d45cf184dbee81bfeca5b3846a42f/e17e5/image-20200820171028681.png 400w,\n/static/2d5d45cf184dbee81bfeca5b3846a42f/3075e/image-20200820171028681.png 621w\" sizes=\"(max-width: 621px) 100vw, 621px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>  \n<img src=\"assets/TS%E5%9F%BA%E7%A1%80/image-20201114122155270.png\" alt=\"image-20201114122155270\" style=\"zoom:50%;\" />  \n<p>上面的是父级，下面是子级，子级类型可以赋值给父级。</p>\n<p><strong>TypeScript体系</strong> </p>\n<p><strong>值 、变量 和 类型</strong>  </p>\n<ul>\n<li>类型的标注/推导确定</li>\n<li>类型的检查，检查数据类型是否安全</li>\n</ul>\n<h4>TS资源</h4>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/docs/home.html\">官网</a>  <a href=\"https://www.tslang.cn/\">中文</a> </li>\n<li><a href=\"https://ts.xcatliu.com/\">TS入门教程-阮一峰</a> </li>\n<li><a href=\"https://zhongsp.gitbook.io/typescript-handbook/\">非官方中文版</a> </li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/#why\">深入理解TS</a> </li>\n</ul>\n<h4>泛型参数组件</h4>\n<ul>\n<li>\n<p>类组件定义及使用</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 定义泛型参数的组件\nclass GenericComponent&lt;P&gt; extends React.Component&lt;P&gt; {\ninternalProp: P;\nconstructor(props: P) {\n  super(props);\n  this.internalProp = props;\n}\nrender() {\n  return null;\n}\n}\n\ntype Props = { a: number; b: string };\n\n&lt;GenericComponent&lt;Props&gt; a={10} b=&quot;hi&quot; /&gt;; // OK\n&lt;GenericComponent&lt;Props&gt; a={10} b={20} /&gt;; // Error</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数式组件</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function GenericComponent&lt;P&gt;(props: P) {\nconst internalProp = useRef(props)\nreturn null;\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>箭头函数</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 这样会解析错误\nconst GenericComponent = &lt;P&gt;(props: P) =&gt;{\nconst internalProp = useRef(props);\nreturn null;\n}\n\n// 泛型必须使用extends关键字才能解析\nconst GenericComponent = &lt;P extends any&gt;(props: P) =&gt;{\nconst internalProp = useRef(props);\nreturn null;\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h4>关键字</h4>\n<p>extends ：ts 中的 extends 理解为扩展更合适，用 <code>&#x26;</code> 可以实现和 <code>extends</code> 类似的效果。</p>\n<p>implements：在 TypeScript 中，<code>implements</code>操作只是为<code>class</code>提供一种类型约束。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Alarm {\n  alert(): void;\n}\nclass Door {\n}\n\nclass SecurityDoor extends Door implements Alarm,接口B {\n  alert() {\n    console.log(&#39;SecurityDoor alert&#39;);\n  }\n}\n\nclass Car implements Alarm {\n  alert() {\n    console.log(&#39;Car alert&#39;);\n  }\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>example</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">(&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];  // 类型断言\n\n\ninterface Padder {\n  getPaddingString(): string\n}\nclass SpaceRepeatingPadder implements Padder {\n  constructor(private numSpaces: number) { }\n  getPaddingString() {\n      return Array(this.numSpaces + 1).join(&quot; &quot;);\n  }\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>使用类型断言手动去除某个类型中的<code>null</code>和<code>undefined</code> </p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">name!.charAt(0)  // name为undefined 时会报错,!的意思是显式告诉编译器name不会为undefined\n\nname?.charAt(0) // name为undefined 时不会报错</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数类型</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">export interface ThemeContextValue {\ntheme: Theme;\nonThemeChange: (theme: Theme) =&gt; void;\nhandleClick?(e: React.MouseEvent&lt;HTMLElement&gt;):void;\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5>extends</h5>\n<p>使用 extends 给泛型添加约束</p>\n<p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface ILengthwise {\n  length: number;\n}\nfunction loggingIdentity&lt;T extends ILengthwise&gt;(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\n// 这时我们需要传入符合约束类型的值，必须包含必须的属性：\nloggingIdentity(3);  // Error, number doesn&#39;t have a .length property\nloggingIdentity({length: 10, value: 3});</code>\n        </deckgo-highlight-code>\n<h4>参考</h4>\n<ul>\n<li><a href=\"https://ts.xcatliu.com/basics/primitive-data-types.html\">原始数据类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/any.html\">任意值</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-inference.html\">类型推论</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/union-types.html\">联合类型</a> </li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-of-object-interfaces.html\">对象的类型——接口</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-of-array.html\">数组的类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-of-function.html\">函数的类型</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/type-assertion.html\">类型断言</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/declaration-files.html\">声明文件</a></li>\n<li><a href=\"https://ts.xcatliu.com/basics/built-in-objects.html\">内置对象</a></li>\n</ul>\n<h4>数据类型</h4>\n<blockquote>\n<p>类型是值的集合</p>\n<p>Undefined  只有<code>undefined</code>一个元素的集合</p>\n<p>Null  只有<code>null</code>一个元素的集合</p>\n<p>Boolean  有两个元素<code>false</code>和<code>true</code>的集合</p>\n<p>...</p>\n</blockquote>\n<p><strong>指定变量的类型</strong>   </p>\n<ul>\n<li>使用接口（Interfaces）来定义对象的类型</li>\n<li>\n<p>指定变量为函数</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Cat {\nname: string;\nrun(): void;\nonBlur?: (value: string, e?: React.FocusEvent&lt;HTMLInputElement&gt;) =&gt; void;\n}\n\nlistener: (ev: MouseEvent) =&gt; any  // 指定listener 是一个函数，同时指定该函数的输入输出类型\n\nlet mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {\n  return x + y;\n};</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>TS简单的说就是为JS中的变量指定了类型，JS中的变量本身是没有类型的，比如：</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let x = 1;\nx = &#39;anc&#39;;\nx = [1,2,3];</code>\n        </deckgo-highlight-code>\n<p>上述中变量<code>x</code>既可以存储数字也可以存储字符串，JS中的某一个变量可以存储任意类型的值。有了TS就可以为变量指定一个类型，这样在编译阶段就可以检查变量是否赋予了正确的类型，提前发现错误，配合编辑器的语法提示能有效提高开发效率。</p>\n<p>TS中描述类型的方法有：</p>\n<ol>\n<li>原始类型: numble  string   Boolean</li>\n<li>字面量类型：123  'abc'</li>\n<li>\n<p>接口：描述一类对象的类型，例如：</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface IPerson{\n name: string;\n age: number\n}\n\nlet me: IPerson = {\n name: &#39;abc&#39;,\n aeg: 10\n}\nlet you: IPerson = {\n name: 12,  // 报错：name必须是string\n}\n// 报错 you 必须同时包含 name 和 age 两个属性</code>\n        </deckgo-highlight-code>\n<p>上述代码定义了一个名为<code>IPerson</code>的接口来表示'人'这一类对象的类型，如果某个对象被指定为<code>IPerson</code>这种类型，那这个对象就必须符合<code>IPerson</code>描述的特征，即包含<code>name</code>和<code>age</code>两个属性。</p>\n</li>\n<li>\n<p>别名\n与接口不同，接口定义了一种新的类型，别名只是对现有的类型声明了新的名字，别名通常与字面量类型、联合类型、交叉类型、泛型使用，例如：</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 为string起一个别名Name，\ntype Name = string;\nlet myName:Name = &#39;abc&#39;;\n\n// 等号右边是字符串字面量类型，Easing是这个字面量类型的别名\ntype Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;\nlet easing: Easing = &#39;ease-in&#39;;\nlet easing: Easing = &#39;other&#39;; // 报错\n// easing这个变量只能被赋值为&quot;ease-in&quot; 或 &quot;ease-out&quot; 或 &quot;ease-in-out&quot;这三个字符串中的一个，赋值为其他值就会报错</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code>never</code>  <code>undefined</code>   <code>null</code>\n<code>never</code>  <code>undefined</code>   <code>null</code> 是TS中三中特殊的类型</p>\n<ul>\n<li><code>never</code> 表示永远不存在的值的类型，即这个类型没有对应的值</li>\n<li><code>undefined</code>这个类型只有一个值，就是<code>undefined</code></li>\n<li><code>null</code>与<code>undefined</code>同理</li>\n</ul>\n</li>\n<li>\n<p>联合类型\n多个类型的或运算，逆 <code>extends</code> ，生成的类型是参与运算的类型的父类型。</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 声明了NumOrStr为一个联合类型\ntype NumOrStr = sting | number;\n\nlet x: NumOrStr = 1; // success\nx = &#39;abc&#39;; // success\nx = [1]; // error</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>交叉类型\n和并多个类型</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Parent1 = {\n name: string;\n}\ntype Parent2 = {\n age: number;\n}\ntype Child = Parent1 &amp; Parent2;\n\n// 子级类型可以赋值给父类型(属性只能多不能少)\nlet my: Parent1 = {\n age: 2,\n name: &#39;&#39;\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>泛型：对类型的进一步抽象，与模板的概念相似，例如：</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 定义一个泛型函数\nfunction logging&lt;T&gt;(arg: T[]): T[] {\n   console.log(arg.length);  // Array has a .length, so no more error\n   return arg;\n}\n\n// 分别使用number 和 string 指定泛型的类型\nlogging&lt;number&gt;([1,2,3]); // ok\nloggin&lt;string&gt;([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]); // ok</code>\n        </deckgo-highlight-code>\n</li>\n</ol>\n<h4>接口</h4>\n<blockquote>\n<p>使用接口（Interfaces）来定义对象的类型，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。除了可用于<a href=\"https://ts.xcatliu.com/advanced/class-and-interfaces.html#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3\">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p>\n</blockquote>\n<ul>\n<li>\n<p>demo</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface Person {\n  name: string;\n  age: number;\n}\n\nlet tom: Person = {\n  name: &#39;Tom&#39;,\n  age: 25\n};\n\n// 有时候我们希望一个接口允许有任意的属性，可以使用如下方式\ninterface Person {\n  name: string;\n  age?: number; // 可选\n  [propName: string]: string | number; // 任意属性，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集。 \n}\n\nlet tom: Person = {\n  name: &#39;Tom&#39;,\n  gender: &#39;male&#39;\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>使用接口定义类数组数据</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function sum() {\n  let args: {\n      [index: number]: number;\n      length: number;\n      callee: Function;\n  } = arguments;\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5>接口继承</h5>\n<p>接口是一个类型，接口可以继承类和其他interface(包括自定义类)。\n接口继承类的时候，只会继承它的实例属性和实例方法。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface ApiError extends Error {\n  code: number;\n}</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://ts.xcatliu.com/advanced/class-and-interfaces.html\">https://ts.xcatliu.com/advanced/class-and-interfaces.html</a>  </p>\n<h5>interface 和 type 的区别</h5>\n<p>​    1)  interface 可以用于 extends 和 implements，type 不能；</p>\n<p>​    2)  <code>type</code> 可以声明联合、交叉类型，interface 不能；</p>\n<p>​    3)  <code>type</code> 可以与 <code>typeof</code> 联用，从变量值推断类型；</p>\n<p>​    4)  interface 存在声明合并的情况，可以用来重在函数，详解：<a href=\"https://www.tslang.cn/docs/handbook/declaration-merging.html\">https://www.tslang.cn/docs/handbook/declaration-merging.html</a></p>\n<h4>泛型</h4>\n<blockquote>\n<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>\n</blockquote>\n<ul>\n<li>\n<p>demo</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {\n  let result: T[] = [];\n  for (let i = 0; i &lt; length; i++) {\n      result[i] = value;\n  }\n  return result;\n}\n\ncreateArray&lt;string&gt;(3, &#39;x&#39;);</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>数组泛型</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h4>内置高级泛型</h4>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// extends 表示类型约束\nfunction copy&lt;T extends BaseType&gt;(arg: T): T {\n  return arg;\n}\n// 条件类型\ntype Extract&lt;T, U&gt; = T extends U ? T : never;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>内置高级类型泛型： <code>Partial Required Pick Exclude Omit</code>  </p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 将所有接口变为可选\ntype Partial&lt;T&gt; = { [P in keyof T]?: T[P] };\n\n// 将所有接口变为必选\ntype Required&lt;T&gt; = { [P in keyof T]-?: T[P] };\n\n// 从 T 中取出 一系列 K 的属性\ntype Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P] };\n\ntype Readonly&lt;T&gt; = {\n  readonly [P in keyof T]: T[P];\n};\n\n/**\n* Exclude from T those types that are assignable to U\n* T 是联合类型？\n*/\ntype Exclude&lt;T, U&gt; = T extends U ? never : T;\n\n/**\n* Extract from T those types that are assignable to U\n*/\ntype Extract&lt;T, U&gt; = T extends U ? T : never;\n\n/**\n* Construct a type with the properties of T except for those in type K.\n*/\ntype Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code>Record</code> :  <code>Record&#x3C;K extends keyof any, T></code> 的作用是将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Record&lt;K extends keyof any, T&gt; = {\n  [P in K]: T;\n};\n\n\ninterface PageInfo {\ntitle: string;\n}\ntype Page = &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;;\n\nconst x: Record&lt;Page, PageInfo&gt; = {\nabout: { title: &quot;about&quot; },\ncontact: { title: &quot;contact&quot; },\nhome: { title: &quot;home&quot; }\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>Pick：从类型 T 中选中部分，得到选中的类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Pick&lt;T, K extends keyof T&gt; = {\n  [P in K]: T[P];\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>Exclude：从类型 T 中剔除部分类型，得到剩余的类型</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Exclude&lt;T, U&gt; = T extends U ? never : T;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>Extract：从类型 T 中提取部分，得到提取的</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Extract&lt;T, U&gt; = T extends U ? T : never;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>ReturnType：用于获取函数 <code>T</code> 的返回类型。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>参考：</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&#x26;mid=2247484142&#x26;idx=1&#x26;sn=946ba90d10e2625513f09e60a462b3a7&#x26;scene=19#wechat_redirect\">TS内置高级泛型</a>    </p>\n<h4>声明文件</h4>\n<ul>\n<li>\n<p>demo.d.ts</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">export declare enum ButtonsPopoverConfigIconType {\n  XiaoSen = &quot;XiaoSen&quot;,\n  Scan = &quot;Scan&quot;,\n  AppStore = &quot;AppStore&quot;,\n  Setting = &quot;Setting&quot;\n}\nexport interface ButtonsPopoverConfig {\n  positionX: number;\n  buttons: Array&lt;{\n      iconType: ButtonsPopoverConfigIconType;\n      title: string;\n  }&gt;;\n}\n\nexport declare function openButtonsPopover(cfg: ButtonsPopoverConfig): Promise&lt;ButtonsPopoverResult&gt;;\n\n// 暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 namespace 下\ndeclare namespace jQuery {\ninterface AjaxSettings {\n  method?: &#39;GET&#39; | &#39;POST&#39;\n  data?: any;\n}\nfunction ajax(url: string, settings?: AjaxSettings): void;\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>声明合并：当一个变量有多种类型时(如：jQuery 既可以作为函数被调用也可以作为对象)\n可以组合多个声明语句，它们会合并起来。</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">declare function jQuery(selector: string): any;\ndeclare namespace jQuery {\n  function ajax(url: string, settings?: any): void;\n}  </code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h4>TS &#x26; React</h4>\n<h5>内置类型</h5>\n<p>React源码</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type ComponentType&lt;P = {}&gt; = ComponentClass&lt;P&gt; | FunctionComponent&lt;P&gt;;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface ReactDOM extends ReactHTML, ReactSVG { }\n\ninterface ReactElement&lt;P = any, T extends string | JSXElementConstructor&lt;any&gt; = string | JSXElementConstructor&lt;any&gt;&gt; {\ntype: T;\nprops: P;\nkey: Key | null;\n}\n\ntype ReactElement = ReactComponentElement | ReactDOMElement;\n\ninterface ReactComponentElement&lt;\nT extends keyof JSX.IntrinsicElements | JSXElementConstructor&lt;any&gt;,\nP = Pick&lt;ComponentProps&lt;T&gt;, Exclude&lt;keyof ComponentProps&lt;T&gt;, &#39;key&#39; | &#39;ref&#39;&gt;&gt;\n&gt; extends ReactElement&lt;P, Exclude&lt;T, number&gt;&gt; { }\n\n\ntype ReactText = string | number;\ntype ReactChild = ReactElement | ReactText;\n\ntype ReactFragment = {} | ReactNodeArray;\n\ntype ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\n\ninterface ReactNodeArray extends Array&lt;ReactNode&gt; {}\n\n//------------------------------------------------------\ninterface ReactDOM extends ReactHTML, ReactSVG { }\n// ReactHIML:  a\\h\\div等\n\ntype ReactNode = ReactElement | ReactFragment | ReactText;\n\n// type ReactElement = ReactComponentElement | ReactDOMElement;\n\ninterface ReactDOM extends ReactHTML, ReactSVG { }\n\ntype ReactDOMElement = {\ntype : string,\nprops : {\n  children : ReactNodeList,\n  className : string,\n  etc.\n},\nkey : string | boolean | number | null,\nref : string | null\n};\n\ntype ReactComponentElement&lt;TProps&gt; = {\ntype : ReactClass&lt;TProps&gt;,\nprops : TProps,\nkey : string | boolean | number | null,\nref : string | null\n};\n\ntype ReactFragment = Array&lt;ReactNode | ReactEmpty&gt;;\n\ntype ReactNodeList = ReactNode | ReactEmpty;\n\ntype ReactText = string | number;\n\ntype ReactEmpty = null | undefined | boolean;</code>\n        </deckgo-highlight-code>\n<p><strong><a href=\"https://gist.github.com/sebmarkbage/fcb1b6ab493b0c77d589\">React Virtual DOM 术语</a></strong>  </p>\n<ul>\n<li>ReactElement</li>\n<li>ReactNode</li>\n</ul>\n<p>一些<code>React</code>的内置类型</p>\n<ul>\n<li><code>React.ReactElement</code> —— 使用<code>React.createElement</code>创建的，可以简单理解为<code>React</code>中的<code>JSX</code>的元素</li>\n<li><code>React.ReactNode</code> —— <code>&#x3C;div>xxx&#x3C;/div></code> xxx的合法类型</li>\n<li><code>React.ReactDOM</code></li>\n<li></li>\n<li><code>React.CSSProperties</code> —— 组件内联的<code>style</code>对象的类型</li>\n<li><code>React.RefObject</code> —— <code>React.createRef</code>创建的类型，只读不可改</li>\n<li><code>React.MutableRefObject</code> —— <code>useRef</code>创建的类型，可以修改</li>\n</ul>\n<p><strong>内置事件类型</strong> </p>\n<ul>\n<li><code>React.MouseEventHandler&#x3C;HEMLInputElement></code></li>\n<li><code>React.ChangeEventHandler&#x3C;HTMLInputElement></code></li>\n<li><code>React.FocusEventHandler&#x3C;HTMLInputElement></code></li>\n<li>\n<p>无状态组件</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">import { SFC } from &#39;react&#39;\nimport { MouseEvent } from &#39;react&#39;\nimport * as React from &#39;react&#39;\ninterface IProps {\nonClick (event: MouseEvent&lt;HTMLDivElement&gt;): void,\n}\nconst Button: SFC&lt;IProps&gt; = ({onClick, children}) =&gt; {\nreturn (\n  &lt;div onClick={onClick}&gt;\n    { children }\n  &lt;/div&gt;\n)\n}\nexport default Button</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数组件\n函数组件定义的方式有两种：</p>\n<ol>\n<li>使用<code>React.FC</code></li>\n</ol>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface IProps {\nvalue: string;\nonClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void\n// 使用React.FC定义函数式组件时不用声明children\n}\nconst App: React.FC&lt;IProps&gt; = (props)=&gt;{\nreturn &lt;div&gt;{children}&lt;/div&gt;\n}</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>使用接口定义<code>props</code></li>\n</ol>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">interface IProps{\nvalue: string;\nonClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void\nchildren?: React.ReactNode; // 需要自己定义children的类型\n}\nfunction App(props:IProps){\nreturn &lt;div&gt;{children}&lt;/div&gt;\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>","id":"945ed277-4134-54b5-b9e0-3cfcdee4d662","parent":{"__typename":"File","name":"TS基础","base":"TS基础.md","mtime":"2022-03-30T03:12:22.920Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/TS基础/"}},"staticQueryHashes":["3957182205"]}