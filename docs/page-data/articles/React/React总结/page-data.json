{"componentChunkName":"component---src-templates-post-js","path":"/articles/React/React总结/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/React/React总结/"},"html":"<h4>待解决</h4>\n<ul>\n<li><code>const ProfilePage = React.lazy(() => import('./ProfilePage')); // 懒加载</code>  </li>\n</ul>\n<h4><a href=\"https://zh-hans.reactjs.org/docs/thinking-in-react.html\">React哲学</a></h4>\n<blockquote>\n<p>将渲染UI和添加交互分开编写，视图和逻辑功能分开。</p>\n<p>先写静态UI，UI完成后再添加逻辑。编写静态UI时，不要使用state，state代表随时间变化的数据，此时可以使用props。</p>\n</blockquote>\n<ol>\n<li>扩展开发，修改关闭，当需要添加新的功能时，使用HOC高阶组件对基础组件进行封装；</li>\n<li>单一功能</li>\n</ol>\n<h4><a href=\"https://zh-hans.reactjs.org/docs/faq-state.html#what-is-the-difference-between-state-and-props\">组件状态-state &#x26; props</a></h4>\n<h4>setState到底是异步还是同步?</h4>\n<p>先给出答案: 有时表现出异步,有时表现出同步</p>\n<ol>\n<li><code>setState</code> 只在<strong>合成事件</strong>和<strong>钩子函数</strong>中是“异步”的，在原生事件和 <code>setTimeout</code> 中都是同步的。</li>\n<li><code>setState</code>的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 <code>setState(partialState, callback)</code> 中的callback拿到更新后的结果。</li>\n<li><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 <code>setState</code> ， <code>setState</code> 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 <code>setState</code> 多个不同的值，在更新时会对其进行合并批量更新。</li>\n</ol>\n<h4><a href=\"https://segmentfault.com/a/1190000012458996\">受控 | 非受控</a></h4>\n<h5><a href=\"https://overreacted.io/zh-hans/writing-resilient-components/\">弹性组件设计原则</a></h5>\n<ul>\n<li>\n<p>不要阻断数据流\n不要将props传递的数据转交给state，避免复制props到state</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class x extends React.Component {\nconstructor(props){\n  this.state = {\n    y: props.y\n  }\n}\n}</code>\n        </deckgo-highlight-code>\n<p>派生状态会导致代码冗余，并使组件难以维护。 <a href=\"https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html\">确保你已熟悉这些简单的替代方案：</a>  </p>\n<ul>\n<li>如果你需要<strong>执行副作用</strong>（例如，数据提取或动画）以响应 props 中的更改，请改用 <a href=\"https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate\"><code>componentDidUpdate</code></a>。</li>\n<li>如果只想在 <strong>prop 更改时重新计算某些数据</strong>，<a href=\"https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization\">请使用 memoization helper 代替</a>。</li>\n<li>如果你想<strong>在 prop 更改时“重置”某些 state</strong>，请考虑使组件<a href=\"https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component\">完全受控</a>或<a href=\"https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\">使用 <code>key</code> 使组件完全不受控</a> 代替。</li>\n</ul>\n</li>\n<li>不要在Side Effects中阻断数据流</li>\n</ul>\n<h4>性能优化</h4>\n<h5>纯函数组件</h5>\n<p>继承 React.PureComponent( <code>class Cmp extends React.PureComponent</code> )或在 <code>shouldComponentUpdate</code> 中比较current props 和 next props。</p>\n<p>只有在props更新时才渲染组件而不是每次父组件渲染时。</p>\n<p><code>React.PureComponent</code> 对 props 和 state 作了浅层比较，因为作深层比较反而会减低性能。</p>\n<h4>模态对话框</h4>\n<p><a href=\"https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal\">模态对话框</a>  </p>\n<h4><a href=\"https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html\">在 React 组件中获取数据的标准方法</a></h4>\n<blockquote>\n<p>该方法处于试验阶段</p>\n</blockquote>\n<p> suspense API 将使异步数据获取对于客户端和服务器渲染都是完全有可能的。</p>\n<p>让 Suspense 成为组件读取异步数据的主要方式——无论数据来自何方。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data\">使用Hook请求数据</a>  </li>\n<li><a href=\"https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props\">异步渲染更新</a>\n在类组件的各种生命周期中执行数据请求、setState</li>\n</ul>\n<h5>类组件</h5>\n<h5>函数式组件</h5>\n<h4>函数式组件 vs 类组件</h4>\n<p>参考：<a href=\"https://juejin.im/post/6844904049146331150\">https://juejin.im/post/6844904049146331150</a></p>\n<ul>\n<li>useRef 获取最新的状态</li>\n</ul>\n<h4>组件的默认属性及类型约束</h4>\n<p><strong>1) 类组件</strong>  </p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const defaultProps = {\n  name: &quot;stranger&quot;,\n};\ntype Props = {\n\tage: number;\n} &amp; Partial&lt;typeof defaultProps&gt;;\n\n\nclass Greeting extends React.Component&lt;Props, {}&gt; {\n\tstatic defaultProps = defaultProps;\n\t//  ...\n}</code>\n        </deckgo-highlight-code>\n<h4>TS + React</h4>\n<p>1). 为什么使用函数表达式而不是函数声明定义函数式组件？</p>\n<ul>\n<li>\n<p>因为使用函数表达式可以指定 <code>React.FC</code> 类型，<code>React.FC</code>  定义了 <code>children</code> 和函数返回类型。</p>\n<p>3).  <code>ReactNode</code> 、 <code>ReactElement</code> 和 <code>JSX.Element</code> 的区别？</p>\n</li>\n<li><code>document.getElementById('root') as HTMLElement</code> </li>\n<li><code>children?: React.ReactNode</code>  </li>\n<li><code>React.ReactNode</code> 包含了 <code>React.ReactElement</code>，<code>React.ReactElement</code> 是泛型</li>\n<li>组件类型用 <code>React.ComponentType</code> 声明</li>\n<li>\n<p>JSX 使用 <code>JSX.Element</code> 声明</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const Cmp : ComponentType&lt;IProps&gt;;\n&lt;Cmp/&gt;\n\n\n// \ndeclare global {\nnamespace JSX {\n  // tslint:disable-next-line:no-empty-interface\n  interface Element extends React.ReactElement&lt;any, any&gt; { }\n}\n}\n// render 返回的是 JSX.Element 类型？\ntype RenderCallback = (args) =&gt; JSX.Element;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p><strong>4).</strong> 定义函数类型：</p>\n<p>​    由于JavaScript具有动态和灵活的性质，有时可能会遇到一个对象，该对象可以作为上述某些类型的组合使用，就是一个既具有函数特性又具有对象特性的类型，它具有一些属性。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">type Foo = (a: string) =&gt; string\ninterface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\n\nfunction getCounter(): Counter {\n    let counter = (function (start: number) { }) as Counter;\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0</code>\n        </deckgo-highlight-code>\n<p><strong>5).</strong> TypeScript还有一种感叹号（<code>!</code>）结尾的语法，它会从前面的表达式里移除<code>null</code>和<code>undefined</code>。</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">export const withDefaultProps = &lt;P extends object, DP extends Partial&lt;P&gt; = Partial&lt;P&gt;&gt;\n(defaultProps: DP, Cmp: ComponentType&lt;P&gt;) =&gt; {\n  // 提取出必须的属性\n  type RequiredProps = Omit&lt;P, keyof DP&gt;;\n  // 重新创建我们的属性定义，通过一个相交类型，将所有的原始属性标记成可选的，必选的属性标记成可选的\n  type Props = Partial&lt;DP&gt; &amp; Required&lt;RequiredProps&gt;;\n\n  Cmp.defaultProps = defaultProps;\n\n  // 返回重新的定义的属性类型组件，通过将原始组件的类型检查关闭，然后再设置正确的属性类型\n  return (Cmp as ComponentType&lt;any&gt;) as ComponentType&lt;Props&gt;;\n};\n        \ntype State = Readonly&lt;typeof initialState&gt;;\n}\n\n// 定义类型/接口\ntype State = Readonly&lt;typeof initialState&gt; &amp; Partial&lt;typeof 可选字段集合&gt;;</code>\n        </deckgo-highlight-code>","id":"e33aaf90-b4c3-54ba-bd7e-6e490937a390","parent":{"__typename":"File","name":"React总结","base":"React总结.md","mtime":"2022-03-30T03:12:22.904Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/React/React总结/"}},"staticQueryHashes":["3957182205"]}