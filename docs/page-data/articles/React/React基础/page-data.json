{"componentChunkName":"component---src-templates-post-js","path":"/articles/React/React基础/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/React/React基础/"},"html":"<blockquote>\n<p>React 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。\n虚拟DOM渲染成页面上的UI的几种场景：</p>\n<ol>\n<li>通过react-dom在浏览器上渲染，react-dom将虚拟dom节点转换为浏览器的dom节点。</li>\n<li>使用node在服务端渲染</li>\n<li>使用react native在手机上渲染</li>\n<li><code>&#x3C;Contacts /></code> 和 <code>&#x3C;Chat /></code> 之类的 React 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。这种方法可能使你想起别的库中“槽”（slot）的概念，但在 React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。</li>\n</ol>\n</blockquote>\n<h4>React元素和组件</h4>\n<p>React 元素就是 JS 对象(一个轻量、不可变的虚拟DOM)，用于描述 UI。创建 React 元素的方法有两种：</p>\n<ol>\n<li><code>React.createElement</code> </li>\n<li><code>JSX</code> (JSX 是 <code>createElement</code> 的语法糖，本质还是调用的 <code>createElement</code> )。<code>&#x3C;div/></code> 和 <code>&#x3C;MyCmp></code> 都是React Element，<code>&#x3C;div/></code> 被渲染为DOM Node，<code>&#x3C;MyCmp></code> 被渲染为自定义组件。</li>\n</ol>\n<p><strong>React 组件</strong>  </p>\n<p>创建组件有两种方法：</p>\n<ol>\n<li><code>class</code> :  render--> return，返回 React 元素</li>\n<li><code>function</code> : return ，返回 React 元素</li>\n</ol>\n<p><code>render</code> 不负责组件的实际渲染工作，实际的渲染由 React 负责。</p>\n<h4>概念思想</h4>\n<ul>\n<li>\n<p>思想：</p>\n<ol>\n<li>Web 应用是一个状态机，视图与状态是一一对应的。</li>\n<li>所有的状态，保存在一个对象里面。Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</li>\n</ol>\n</li>\n<li>\n<p>从概念上讲，React 分<strong>两个阶段</strong>工作：</p>\n<ol>\n<li><strong>渲染</strong> 阶段会确定需要进行哪些更改，比如 DOM。在此阶段，React 调用 <code>render</code>，然后将结果与上次渲染的结果进行比较。</li>\n<li><strong>提交</strong> 阶段发生在当 React 应用变化时。（对于 React DOM 来说，会发生在 React 插入，更新及删除 DOM 节点的时候。）在此阶段，React 还会调用 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 之类的生命周期方法。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件（组件内部），这个对象被称之为 “props”。</li>\n<li>自定义组件名必须用大写字母开头，小写字母开头的被视为原生DOM标签</li>\n<li>组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。<strong>单向数据流</strong></li>\n<li>得益于 setState() 的调用，React 能够知道 state 已经改变了，然后会重新调用 render() 方法来更新页面</li>\n<li>\n<p><strong>state</strong></p>\n<ol>\n<li>不要直接修改state，这样不会重新渲染组件，应该使用 setState</li>\n<li>构造函数是唯一能给 state赋值的地方</li>\n<li>setState() 自动将部分 state 合并到当前 state,</li>\n<li>state 只能由拥有它们的组件进行更改</li>\n</ol>\n</li>\n<li>\n<p>通过问自己以下三个问题，你可以逐个检查相应数据是否应该属于 state：</p>\n<ol>\n<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state</li>\n<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>\n<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<h4>ReactDom.render</h4>\n<ul>\n<li>\n<p>ReactDom.render</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function Button() {\nreturn &lt;button id=&quot;btn&quot;&gt;Say Hello&lt;/button&gt;;\n}\n\nReactDOM.render(\n&lt;Button /&gt;,\ndocument.getElementById(&#39;container&#39;),\nfunction() {\n  // jQuery\n  $(&#39;#btn&#39;).click(function() {\n    alert(&#39;Hello!&#39;);\n  });\n}\n);</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h4>组件</h4>\n<p>从概念上讲，React 组件一直更像是函数。</p>\n<ol>\n<li>\n<p>函数组件(无状态组件)</p>\n<ul>\n<li>函数名必须大写开头，没有实例</li>\n<li>必须有返回值，可以返回 JSX对象或 null，当返回 JSX时，只能有一个根元素</li>\n</ul>\n</li>\n<li>class组件(有状态组件)\n组件可以维护其内部的状态数据（通过 <code>this.state</code> 访问）。当组件的状态数据改变时，组件会再次调用 <code>render()</code> 方法重新渲染对应的标记</li>\n</ol>\n<blockquote>\n<p>By default, React components (both the <code>function</code> type and the <code>class</code> type, if it extends <code>React.Component</code>) will re-render whenever their parent re-renders, or whenever you change their state with <code>setState</code>.</p>\n<p>An easy way to optimize a React component for performance is to make it a class, and make it extend <code>React.PureComponent</code> instead of <code>React.Component</code>. This way, the component will only re-render if its state is changed or if its <em>props have changed</em>. It will no longer mindlessly re-render every single time its parent re-renders; it will ONLY re-render if one of its props has changed since the last render.</p>\n<p>Here’s where immutability comes in: if you’re passing props into a <code>PureComponent</code>, you have to make sure that those props are updated in an immutable way. That means, if they’re objects or arrays, you’ve gotta replace the entire value with a new (modified) object or array. Just like with Bob – kill it off and replace it with a clone.</p>\n<p>If you modify the internals of an object or array – by changing a property, or pushing a new item, or even modifying an item <em>inside</em> an array – then the object or array is <em>referentially equal</em> to its old self, and a <code>PureComponent</code> will not notice that it has changed, and will not re-render. Weird rendering bugs will ensue.</p>\n<ul>\n<li>默认情况下，函数组件和继承自<code>React.Component</code> 的类组件在他们的父组件或 <code>state</code> 变化时会 re-render。</li>\n</ul>\n</blockquote>\n<h5>纯函数</h5>\n<ol>\n<li>纯函数相同的输入一定返回相同的输出</li>\n<li>纯函数没用副作用，</li>\n</ol>\n<p>What’s a “Side Effect”?</p>\n<p>“Side effects” is a broad term, but basically, it means modifying things outside the scope of that immediate function. Some examples of side effects…</p>\n<ul>\n<li>Mutating/modifying input parameters, like <code>giveAwesomePowers</code> does</li>\n<li>Modifying any other state outside the function, like global variables, or <code>document.(anything)</code> or <code>window.(anything)</code></li>\n<li>Making API calls</li>\n<li><code>console.log()</code> </li>\n<li><code>Math.random()</code> </li>\n</ul>\n<h4>JSX</h4>\n<ul>\n<li>\n<p>JSX 仅仅只是  React.createElement(component, props, ...children) 函数的语法糖，Reacr.createElement函数返回一个对象(这类对象称为<strong>React元素</strong>)</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;MyButton color=&quot;blue&quot; shadowSize={2}&gt;\nClick Me\n&lt;/MyButton&gt;\n// 函数组件\nfunction MyButton(props){\n  return &lt;button&gt;{ props.children }&lt;/button&gt;;\n}</code>\n        </deckgo-highlight-code>\n<p>标签MyButton被编译为变量（函数 MyButton）的直接引用，也可以使用对象属性的形式，<code>&#x3C;Mybutton.DatePicker></code></p>\n</li>\n<li>\n<p>JSX 的 <code>{}</code> 中可以插入任意的 JS 表达式，如字符串字面量</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;MyComponent message=&quot;hello world&quot; /&gt;等价于\n&lt;MyComponent message={&#39;hello world&#39;} /&gt;\n\n&lt;MyComponent message=&quot;&amp;lt;3&quot; /&gt;等价于\n&lt;MyComponent message={&#39;&lt;3&#39;} /&gt;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h4>CSS</h4>\n<p>React 中不能直接使用 CSS 样式<code>&#x3C;div style=\"background-color:red\"></code>；</p>\n<p>React 中用以下几种方式使用样式：</p>\n<ul>\n<li>\n<p>使用对象形式以 props.style 的形式，这种形式只作用于当前组件；</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const Sider = () =&gt; {\nconst style = {\n  display: &#39;block&#39;,\n  listStyleType: &#39;none&#39;\n}\nreturn (\n  &lt;a style={style}&gt;link to header.js&lt;/a&gt;\n);\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>import 外部 CSS 文件，以类的形式应用样式表中的规则，等价于普通情况</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">import &quot;/css/index.css&quot;;\nconst comp = () =&gt; {\n  return (\n      &lt;div className=&quot;xx&quot;&gt;&lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>参考：<a href=\"https://juejin.im/post/5b39e63ae51d4562aa017c81\">CSS 解决方案</a></p>\n<h4>数据(状态)</h4>\n<ul>\n<li>\n<p>React中只有两种数据(props和state)，数据向下流动；</p>\n<ol>\n<li>props：read-only只读，单向数据流</li>\n<li>state：组件内更新数据用setState</li>\n</ol>\n</li>\n</ul>\n<h5>setState</h5>\n<p><a href=\"https://cloud.tencent.com/developer/article/1431167\">参考</a></p>\n<h4>回调函数中的 this指向</h4>\n<p>class的方法默认不会绑定this，解决方法有三种：</p>\n<ol>\n<li>\n<p>class fields: create React App默认启用此语法，这种语法还处于试验性阶段！</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class MyComp extends React.Component {\n   handleClick = ()=&gt;{\n       // 此处的this已经绑定\n   }\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>回调中使用箭头函数</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;button onClick={ (e)=&gt; this.handleClick(e)} &gt;&lt;/button&gt;</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>bind</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class WordAdder extends React.Component {\n   constructor(props) {\n       super(props);\n       this.state = {\n           words: [&#39;marklar&#39;]\n       };\n       this.handleClick = this.handleClick.bind(this);\n   }\n\n   handleClick() {\n       // 如果constructor中没有用bind绑定this, 此处无法访问this.state, \n       // this指向undefined\n       let words = this.state.words;\n       console.log(&#39;call handleClick!&#39;);        \n   }\n\n   render() {\n       return (\n           &lt;div&gt;\n               &lt;button onClick={this.handleClick} &gt;按钮&lt;/button&gt;\n           &lt;/div&gt;\n       );\n   }\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ol>\n<h4>向事件处理程序传递参数</h4>\n<ul>\n<li>\n<p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;\n\n&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;</code>\n        </deckgo-highlight-code>\n<p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>\n</li>\n</ul>\n<h4>数组转换为元素列表</h4>\n<ul>\n<li>\n<p>使用 Javascript 中的<code>map()</code>方法来遍历 <code>numbers</code> 数组。将数组中的每个元素变成 <code>&#x3C;li></code> 标签，最后我们将得到的数组赋值给 <code>listItems</code></p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function NumberList(props) {\nconst numbers = props.numbers;\nconst listItems = numbers.map((number) =&gt;\n  &lt;li key={number.toString()}&gt;{number}&lt;/li&gt;\n);\nreturn (\n  &lt;ul&gt;{listItems}&lt;/ul&gt;\n);\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n&lt;NumberList numbers={numbers} /&gt;,\ndocument.getElementById(&#39;root&#39;)\n);</code>\n        </deckgo-highlight-code>\n<ol>\n<li>如果没有指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。不建议使用索引作为key值</li>\n<li>一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</li>\n</ol>\n</li>\n</ul>\n<h4>key</h4>\n<ul>\n<li>数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：</li>\n<li><a href=\"https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children\">https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children</a></li>\n<li><a href=\"https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318\">https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318</a></li>\n</ul>\n<h4>组合 &#x26; 插槽</h4>\n<ul>\n<li>建议使用组合而非继承</li>\n<li>\n<p>React中没有槽这个概念的限制，任何数据(包括React元素)都可以通过props传递，</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 借助props.children 传递组件的内容\nfunction WelcomeDialog() {\nreturn (\n  &lt;FancyBorder color=&quot;blue&quot;&gt;\n    &lt;h1 className=&quot;Dialog-title&quot;&gt;\n    \t\tWelcome\n    &lt;/h1&gt;\n    &lt;p className=&quot;Dialog-message&quot;&gt;\n    \t\tThank you for visiting our spacecraft!\n    &lt;/p&gt;\n  &lt;/FancyBorder&gt;\n);\n}\n\nfunction FancyBorder(props) {\nreturn (\n  &lt;div className={&#39;FancyBorder FancyBorder-&#39; + props.color}&gt;\n    {props.children}\n  &lt;/div&gt;\n);\n}\n\n// 传递多个组件的内容\nfunction SplitPane(props) {\nreturn (\n  &lt;div className=&quot;SplitPane&quot;&gt;\n    &lt;div className=&quot;SplitPane-left&quot;&gt;\n      {props.left}\n    &lt;/div&gt;\n\n    &lt;div className=&quot;SplitPane-right&quot;&gt;\n      {props.right}\n    &lt;/div&gt;\n  &lt;/div&gt;\n);\n}\n\nfunction App() {\nreturn (\n  &lt;SplitPane\n    left={ &lt;Contacts /&gt; }  \n    right={ &lt;Chat /&gt; }\n  /&gt;\n);\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h4>setState</h4>\n<p>setState(updater, [callback]]);  </p>\n<p>updater可以是对象或函数，</p>\n<p>callback是可选的，它将在 <code>setState</code> 完成合并并重新渲染组件后执行。通常，我们建议使用 <code>componentDidUpdate()</code> 来代替此方式。</p>\n<p>在事件处理函数内部的setState是异步，需要用函数作setState的参数更新state</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">setState((curState, props)=&gt;{\n  \n})</code>\n        </deckgo-highlight-code>\n<p>无论您在React事件处理程序中使用多少个setState（）调用了多少个组件，它们在事件结束时只会产生一次重新渲染。</p>\n<h5>Promise和定时器中执行setState</h5>\n<ul>\n<li>\n<p>Promise 和定时器中执行 setState 不是异步，也不是批处理</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">Promise.resolve().then(() =&gt; {\n// 不是异步, 不是批处理\nthis.setState({ a: &#39;子1&#39; });\n\t// 这里可以取到最新的 state\n\n// 每一个 setState 都会导致重渲染\nthis.setState({ a: &#39;子2&#39; });\n});\n\n\nsetTimeout(() =&gt; {\nthis.setState({\n  a: &#39;子1&#39;,\n});\n\t// 这里可以取到最新的值\n\n// 每次 setState 多会导致重渲染\nthis.setState({\n  a: &#39;子2&#39;,\n});\n});</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5>设置非受控组件的state</h5>\n<p>对于<strong>不受控</strong>的组件，当你想在 prop 变化（通常是 ID ）时重置 state 的话，可以选择以下几种方式：</p>\n<ul>\n<li><strong>建议: 重置内部所有的初始 state，使用 <code>key</code> 属性</strong></li>\n<li>选项一：仅更改某些字段，观察特殊属性的变化（比如 <code>props.userID</code>）。<code>(getDriveStateFromProps)</code> </li>\n<li>选项二：使用 ref 调用实例方法。</li>\n</ul>\n<h4>Ref</h4>\n<p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 <a href=\"http://calendar.perfplanet.com/2013/diff/\">DOM diff</a> ，它可以极大提高网页的性能表现。</p>\n<p>如果需要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。</p>\n<ul>\n<li>\n<p>访问 DOM 节点或在 render 方法中创建的 React 元素</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class MyComponent extends React.Component {\nconstructor(props) {\n  super(props);\n  this.myRef = React.createRef();\n  this.clickHandle = this.clickHandle.bind(this);\n}\nrender() {\n  return &lt;div id=&quot;my-div&quot; ref={this.myRef} /&gt;;\n}\nclickHandle()  {\n\t// this.myRef.current指向 div#my-div\n}\n}</code>\n        </deckgo-highlight-code>\n<p>当 ref 属性作用于 HTML 元素时，this.myRef.current指向原生DOM元素；当作用于自定义的class 组件时，指向组件实例。ref <strong>不能作用于函数组件</strong>(可以在函数组件内使用)，因为函数组件没有实例。</p>\n<p>不能这样使用<code>&#x3C;函数组件 ref='myRef'></code> </p>\n</li>\n</ul>\n<h4>Context</h4>\n<blockquote>\n<p>Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据，应用于<strong><Provider store={store}></Provider></strong>。Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，</p>\n</blockquote>\n<p><strong>参考</strong>：<a href=\"https://zh-hans.reactjs.org/docs/context.html\">https://zh-hans.reactjs.org/docs/context.html</a> </p>\n<h4><a href=\"https://zh-hans.reactjs.org/docs/higher-order-components.html\">HOC(高阶组件)</a></h4>\n<blockquote>\n<p>HOC的作用是对现有的组件进行封装扩展，添加新的功能。</p>\n<p>组件是将 props 转换为UI，高阶组件是将组件转换为新组件的函数（创建组件的函数，相当于组件工厂），因此高阶组件的参数是组件，返回值也是组件。</p>\n<p>HOC 是<strong>纯函数</strong>，没有副作用。HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件<strong>包装</strong>在容器组件中来组成新组件。</p>\n<p>高阶组件的实现方式本质上是装饰者设计模式。</p>\n</blockquote>\n<h4>Diff</h4>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/reconciliation.html\">Diff官网</a></li>\n</ul>\n<h4>生命周期</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0454d5f5840466b3311206b4fddcaf48/2cffa/image-20201029100258129.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACHklEQVQoz22Ti3LiMAxF+f+fW0oLtNDmAYRHEieOX4kD4ezY0O7uzHrmjpyMdSRZ8ux+v3O/E9dtmrjdJqZob1F9P2CtjRqGAdFItDZxP45jPPutcH52f9KC9X6gbQTb7ZahdzjnIjA41rVgs/2M/7z3MUDf9xhjWK3fEULEILNHhvdARFtPUVmSfU1+kshO0fcOozW9cyjVRaBWKioAA8QY+7Of8ddqlOej6HlLGpappGw0SlvqpkObnlpIlHFUQtLK7gfyqOQJtNZxPl+wRtPqkeRyJa9ubA6GxdcDvM4k73nHYluxTFt+bWrys2YcfQQFxg9Qac2hONK2ktH7WKJz9mGt5VD1vO8UnyfLKu84lJK2FZRliVLqn/v8KfnRmHCHA3XnKVuHUJ66G8gujnXa8DFPSJKaPK/YZScOxwqt/wMMrY4tv440aiC5jKQXT1aOUcnZkuSCYybY54IiE+yylnPzADxKfgCDZlJKiuIYxyKMx/V6jVG/Lf7CVafIakNzXiHLD+RlRXXcIpom+gRQOBs0C45hlrwfmUYD/YmbPYEv6bsdrknp24SrypnMDlwB/YGbq5im54u4/5mU2JSQYddpRq8xKkPJDGf2uK6ga3PaJqWTOUrmGL3HBpmKYfS40aGcwg4Gf31mGFKdbhOtkbwmS+abBctsjXaWSldkdR6/59sFi683lvmK5JBwEWfe0ldeNnNetnOOouA3CA6UM8LvJpIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20201029100258129\"\n        title=\"image-20201029100258129\"\n        src=\"/static/0454d5f5840466b3311206b4fddcaf48/5a190/image-20201029100258129.png\"\n        srcset=\"/static/0454d5f5840466b3311206b4fddcaf48/772e8/image-20201029100258129.png 200w,\n/static/0454d5f5840466b3311206b4fddcaf48/e17e5/image-20201029100258129.png 400w,\n/static/0454d5f5840466b3311206b4fddcaf48/5a190/image-20201029100258129.png 800w,\n/static/0454d5f5840466b3311206b4fddcaf48/2cffa/image-20201029100258129.png 1092w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>    </p>\n<p>componentDidMount: 挂载-当组件添加到 DOM 树之后执行；</p>\n<p>React组件的生命周期分为三个阶段：1. 挂载  2. 更新 3. 卸载。</p>\n<p>​    当组件的props或state变化时，组件的render方法会重新执行并返回新的虚拟DOM对象。在组件重渲染的过程中依次调用componentWillReceiveProps及上述其他4个方法。componentShouldUpdate方法默认返回true，如果componentShouldUpdate返回false，componentShouldUpdate之后的方法就不会调用，也就不会生成新的虚拟DOM对象和使用Diff算法比较新旧虚拟DOM。实现性能优化。</p>\n<p><strong>getDerivedStateFromProps</strong>  : 在组件内部保存上一次的 <code>props</code> 来区分是<code>props</code> 还是 <code>state</code> 变化导致的重渲染。</p>\n<h4>HOOK</h4>\n<blockquote>\n<p>我们推荐启用 <a href=\"https://www.npmjs.com/package/eslint-plugin-react-hooks#installation\"><code>eslint-plugin-react-hooks</code></a> 中的 <a href=\"https://github.com/facebook/react/issues/14920\"><code>exhaustive-deps</code></a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 你的 ESLint 配置\n{\n  &quot;plugins&quot;: [\n    // ...\n    &quot;react-hooks&quot;\n  ],\n  &quot;rules&quot;: {\n    // ...\n    &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;, // 检查 Hook 的规则\n    &quot;react-hooks/exhaustive-deps&quot;: &quot;warn&quot; // 检查 effect 的依赖\n  }\n}</code>\n        </deckgo-highlight-code>\n</blockquote>\n<p>Hook 就是 JavaScript <strong>函数</strong>。Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性，如生命周期函数。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 声明一个新的叫做 “count” 的 state 变量\nconst [count, setCount] = useState(0);\n// 不像 class 中的 this.setState，更新 state 变量总是替换它而不是合并它。\n// 变量定义为const!</code>\n        </deckgo-highlight-code>\n<p>Hook 为已知的 React 概念提供了更直接的 API：props， state，context，refs 以及生命周期。</p>\n<p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p>\n<ul>\n<li>只能在<strong>函数最外层</strong>调用 Hook，不要在循环、条件判断或者子函数中调用。</li>\n<li>只能在 <strong>React 的函数组件</strong>中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中。）</li>\n</ul>\n<p><strong>在组件之间复用状态逻辑和共享状态的方法：</strong> </p>\n<ol>\n<li><a href=\"https://zh-hans.reactjs.org/docs/render-props.html\">render props</a> 和<a href=\"https://zh-hans.reactjs.org/docs/higher-order-components.html\">高阶组件</a> ：render props和高阶组件只渲染一个子节点。</li>\n<li><strong>自定义HOOK：</strong> 你可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。<strong>Hook 使你在无需修改组件结构的情况下复用状态逻辑</strong>， 这使得在组件间或社区内共享 Hook 变得更便捷。</li>\n</ol>\n<h5>内置的HOOK</h5>\n<h6>state Hook</h6>\n<h6>Effect Hook</h6>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">useEffect(fnDoSomething(){\n  return fnCleanSomenthing(){}\n}, [dependA, dependB]);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>告诉 React 组件需要在<strong>渲染后</strong>（包括首次渲染和组件更新后：componentDidMount、componentDidUpdate）执行某些操作。可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</li>\n<li>\n<p>什么时候执行 useEffect：每次渲染时都会执行 Effect，React 会等待浏览器完成画面渲染之后才延迟调用 useEffect。当 useEffect 中有清除操作时，会先清除上一个Effect，然后执行当前 Effect。</p>\n<blockquote>\n<p>与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，在浏览器完成布局与绘制之后，传给 <code>useEffect</code> 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p>\n<p>使用 <a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect\">useLayoutEffect</a> 可以避免延迟执行。</p>\n</blockquote>\n</li>\n<li>\n<p>传递给 useEffect 的函数在每次渲染中都会有所不同（每次都创建一个新的函数），这是刻意为之的。事实上这正是我们可以在 effect 中获取最新的 count 的值，而不用担心其过期的原因。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect 属于一次特定的渲染。</p>\n<ul>\n<li>一旦 effect 的依赖发生变化，effect 就会被重新创建。</li>\n<li>Effect拿到的总是定义它的那次渲染中的props和state</li>\n</ul>\n</li>\n<li>Effect Hook通过返回一个函数，并在该函数中指定清除操作，每次渲染时都会执行Effect中的清除操作，而不是只在组件卸载时执行一次。\n组件首次渲染时不会执行 useEffect Hook 返回的函数，非首次渲染时，执行的顺序依次是:  render--> clean 函数-->useEffect </li>\n<li><code>an effect hook should return nothing or a clean up function.</code> </li>\n<li>一个组件中有多个 Effect Hook 时 React 将按照 effect 声明的顺序依次调用组件中的 effect。</li>\n</ul>\n<h5>useMemo &#x26; useCallback</h5>\n<p><strong>1.useMemo</strong> </p>\n<blockquote>\n<ul>\n<li>把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</li>\n<li>记住，传入 <code>useMemo</code> 的函数会在<strong>渲染期间</strong>执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</li>\n<li>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</li>\n<li>\n<p><strong>使用场景</strong>  </p>\n<ol>\n<li>缓存组件：父组件改变自身数据，不涉及子组件数据变化，不使用 useMemo 就会在父组件每次 render 时都渲染子组件。</li>\n<li>类组件中可以利用继承 React.PureComponent 或者 shouldComponentUpdate 生命周期函数避免组件重复渲染。(React.PureComponent 浅层对比了 props 和 state)</li>\n<li>函数式组件可以使用 useMemo 缓存组件可以避免组件重复渲染。或者使用 <a href=\"https://zh-hans.reactjs.org/docs/react-api.html#reactmemo\">React.memo(高阶组件)</a>，React.memo 默认对 props 作浅比较。</li>\n<li>缓存 props (引用比较)</li>\n<li>高消耗计算(计算属性)</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const main = useMemo(() =&gt; {\n  console.debug(&#39;执行useMemo中的函数!&#39;);\n  return (props.data || []).map((item, index) =&gt; {\n    return &lt;div key={index}&gt;{item}&lt;/div&gt;;\n  });\n}, [props.data]);\n\n// 父组件\nreturn (\n  &lt;div&gt;\n    &lt;p&gt;{count}&lt;/p&gt;\n    &lt;button onClick={handleCount}&gt;setCount&lt;/button&gt;\n    {main}\n  &lt;/div&gt;\n);</code>\n        </deckgo-highlight-code>\n<p><strong>分析</strong> </p>\n<ul>\n<li>当依赖<code>props.data</code>不变时，main的引用不变</li>\n<li>useMemo类似于计算属性，useMemo返回的是一个记忆后的<strong>值</strong>，这个值由其他数据计算得到并且与页面渲染有关(需要在页面上显示)。</li>\n<li>上述demo中如果没有使用useMemo，则点击事件导致count更新并触发页面渲染时<code>main</code>也要重新计算(每次点击都会输出console.debug中的内容)，虽然main没有改变。</li>\n<li><code>useMemo</code>是根据依赖(deps)缓存第一个入参(callback)执行后的值。</li>\n</ul>\n<p><strong>2.<a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback\">useCallback</a></strong> </p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const memoizedCallback = useCallback(\n  () =&gt; {\n    doSomething(a, b);\n  },\n  [a, b],\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>当依赖a、b不变时，memoized Callback的引用不变</li>\n<li><code>useCallback</code>是根据依赖(deps)缓存第一个入参的(callback)。</li>\n</ul>\n<p><strong>3.总结</strong></p>\n<ul>\n<li><code>useMemo</code>缓存值，这个值(React元素)用于渲染页面或传递给子组件。</li>\n<li><code>useCallback</code>缓存函数，这个函数通常传递给子组件，避免组件重复渲染。</li>\n</ul>\n<p><strong>4.参考</strong> </p>\n<ul>\n<li><a href=\"https://github.com/monsterooo/blog/issues/37\">useCallback、useMemo 分析 &#x26; 差别-github</a> </li>\n</ul>\n<h5><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data\">使用useEffect发送请求-fetch</a></h5>\n<ol>\n<li><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data#error-handling-with-react-hooks\">loadding &#x26; error处理</a> </li>\n<li><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data#custom-data-fetching-hook\">将fetch data封装为自定义hook</a> </li>\n<li><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data#reducer-hook-for-data-fetching\">使用useReducer进行fetch data</a> </li>\n<li><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data#abort-data-fetching-in-effect-hook\">abort-data-fetching-in-effect-hook</a>  </li>\n</ol>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">import React, { Fragment, useState, useEffect } from &#39;react&#39;;\nimport axios from &#39;axios&#39;;\n \nfunction App() {\n  const [data, setData] = useState({ hits: [] });\n  const [query, setQuery] = useState(&#39;redux&#39;);\n  const [url, setUrl] = useState(\n    &#39;https://hn.algolia.com/api/v1/search?query=redux&#39;,\n  );\n  const [isLoading, setIsLoading] = useState(false);\n  const [isError, setIsError] = useState(false);\n \n  useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n      setIsError(false);\n      setIsLoading(true);\n \n      try {\n        const result = await axios(url);\n \n        setData(result.data);\n      } catch (error) {\n        setIsError(true);\n      }\n \n      setIsLoading(false);\n    };\n \n    fetchData();\n  }, [url]);\n \n  return (\n    &lt;Fragment&gt;\n      &lt;input\n        type=&quot;text&quot;\n        value={query}\n        onChange={event =&gt; setQuery(event.target.value)}\n      /&gt;\n      &lt;button\n        type=&quot;button&quot;\n        onClick={() =&gt;\n          setUrl(`http://hn.algolia.com/api/v1/search?query=${query}`)\n        }\n      &gt;\n        Search\n      &lt;/button&gt;\n \n      {isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/div&gt;}\n \n      {isLoading ? (\n        &lt;div&gt;Loading ...&lt;/div&gt;\n      ) : (\n        &lt;ul&gt;\n          {data.hits.map(item =&gt; (\n            &lt;li key={item.objectID}&gt;\n              &lt;a href={item.url}&gt;{item.title}&lt;/a&gt;\n            &lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n      )}\n    &lt;/Fragment&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>自定义HOOK</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const useHackerNewsApi = () =&gt; {\nconst [data, setData] = useState({ hits: [] });\nconst [url, setUrl] = useState(\n  &#39;https://hn.algolia.com/api/v1/search?query=redux&#39;,\n);\nconst [isLoading, setIsLoading] = useState(false);\nconst [isError, setIsError] = useState(false);\n\nuseEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    setIsError(false);\n    setIsLoading(true);\n\n    try {\n      const result = await axios(url);\n\n      setData(result.data);\n    } catch (error) {\n      setIsError(true);\n    }\n\n    setIsLoading(false);\n  };\n\n  fetchData();\n}, [url]);\n\nreturn [{ data, isLoading, isError }, setUrl];\n}\n\n// \nfunction App() {\nconst [query, setQuery] = useState(&#39;redux&#39;);\nconst [{ data, isLoading, isError }, doFetch] = useHackerNewsApi();\n\nreturn (\n  &lt;Fragment&gt;\n    &lt;form onSubmit={event =&gt; {\n      doFetch(`http://hn.algolia.com/api/v1/search?query=${query}`);\n\n      event.preventDefault();\n    }}&gt;\n      &lt;input\n        type=&quot;text&quot;\n        value={query}\n        onChange={event =&gt; setQuery(event.target.value)}\n      /&gt;\n      &lt;button type=&quot;submit&quot;&gt;Search&lt;/button&gt;\n    &lt;/form&gt;\n\n    ...\n  &lt;/Fragment&gt;\n);\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p><strong>问题</strong> </p>\n<ol>\n<li>\n<p>useEffect的第二个参数没有、为空数组、非空数组3种情况时的运行情况？</p>\n<ul>\n<li>依赖数组为空时，改hook只在组件挂载时运行一次，在组件挂载和组件销毁时执行，并非每次渲染时运行。并且当依赖数组为空时 effect 内部的 props 和 state 就会一直持有其初始值。</li>\n<li></li>\n</ul>\n</li>\n<li>函数应该作为useEffect的依赖吗？</li>\n</ol>\n<p><strong>参考</strong> </p>\n<ul>\n<li><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">useEffect完整指南</a> <strong>重点</strong> </li>\n<li><strong>每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props和state</strong> --闭包</li>\n</ul>\n<h5>Context Hook &#x26; Reducer Hook &#x26; useRef</h5>\n<p><code>useReducer</code> 更适合用于管理包含多个子值的 state 对象。</p>\n<ul>\n<li>\n<p>demo</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">import React, { useReducer } from &#39;react&#39;;\n\nfunction reducer(state, action) {\nswitch (action.type) {\n  case &#39;add&#39;:\n    return [...state, action.item];\n  case &#39;remove&#39;:\n    return [\n      ...state.slice(0, action.index),\n      ...state.slice(action.index + 1)\n    ];\n  default:\n    throw new Error();\n}\n}\n\nfunction FavoriteMovies() {\n// useReducer接收一个reducer函数和一个初始化对象作为 input 参数\n// uesReducer返回一个状态对象和一个改变状态对象的函数dispatch，dispatch函数接收action对象作参数\nconst [state, dispatch] = useReducer(reducer, [{ name: &#39;Heat&#39; }]);\n\nreturn (\n  // Use dispatch({ type: &#39;add&#39;, item: movie })\n  // and dispatch({ type: &#39;remove&#39;, index })...\n);\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p><strong>useRef</strong> </p>\n<blockquote>\n<p>可变引用<code>useRef()</code>保存可变数据，这些数据在更改时不会触发重新渲染。当 ref 是一个对象时它并不会把当前 ref 的值的变化 通知到我们。</p>\n<p>场景：更新状态却不重新渲染组件</p>\n</blockquote>\n<ul>\n<li>\n<p>demo</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">import React, { useRef, useEffect } from &#39;react&#39;;\n\nfunction CountMyRenders() {\nconst countRenderRef = useRef(1);\n\nuseEffect(function afterRender() {\n  countRenderRef.current++;\n});\n\nreturn (\n  &lt;div&gt;I&#39;ve rendered {countRenderRef.current} times&lt;/div&gt;\n);\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5>自定义HOOK</h5>\n<blockquote>\n<p>自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 <code>use</code> 开头并调用其他 Hook，我们就说这是一个自定义 Hook，自定义hook只是用自己写的函数包裹原生的hook， <code>useSomething</code> 的命名约定可以让我们的 linter 插件在使用 Hook 的代码中找到 bug。</p>\n<p><strong>在两个组件中使用相同的 Hook 会共享 state 吗？</strong>不会。自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。</p>\n</blockquote>\n<h4>静态类型检查</h4>\n<p>组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。你可以使用 <a href=\"https://flow.org/\">Flow</a> 或 <a href=\"https://www.typescriptlang.org/\">TypeScript</a> 等 JavaScript 扩展来对整个应用程序做类型检查。但即使你不使用这些扩展，React 也内置了一些类型检查的功能。</p>\n<h5>PropTypes</h5>\n<p>要在组件的 props 上进行类型检查，你只需配置特定的 <a href=\"https://react.docschina.org/docs/typechecking-with-proptypes.html\">propTypes</a>属性：</p>\n<h5>Flow &#x26; TypeScript</h5>\n<blockquote>\n<p>Flow 或 TypeScript 来代替  PropTypes</p>\n</blockquote>\n<ul>\n<li>Flow是针对JS代码的静态类型检测器，</li>\n<li>TypeScript 是一种由微软开发的编程语言。它是 JavaScript 的一个类型超集，包含独立的编译器。作为一种类型语言，TypeScript 可以在构建时发现 bug 和错误，这样程序运行时就可以避免此类错误。</li>\n</ul>\n<hr>\n<h4>临时记录</h4>\n<p>在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 <code>render</code> 方法直接返回 <code>null</code>，而不进行任何渲染；</p>\n<p>在组件的 <code>render</code> 方法中返回 <code>null</code> 并不会影响组件的生命周期。例如，上面这个示例中，<code>componentDidUpdate</code> 依然会被调用；</p>\n<p><code>React.memo</code> 等效于 <code>PureComponent</code>，但它只比较 props。（你也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。）</p>","id":"e68538e8-3139-5350-aab5-b373888daf76","parent":{"__typename":"File","name":"React基础","base":"React基础.md","mtime":"2022-03-30T03:05:54.651Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/React/React基础/"}},"staticQueryHashes":["3957182205"]}