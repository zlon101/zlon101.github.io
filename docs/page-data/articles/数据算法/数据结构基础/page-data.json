{"componentChunkName":"component---src-templates-post-js","path":"/articles/数据算法/数据结构基础/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/数据算法/数据结构基础/"},"html":"<blockquote>\n<p><strong>递归本质上就是一个栈结构。</strong></p>\n</blockquote>\n<h1>树</h1>\n<h3>二叉树</h3>\n<blockquote>\n<p>二叉树：子节点个数最多为 2 个；</p>\n</blockquote>\n<h3>完全二叉树</h3>\n<blockquote>\n<p>除最后一层外，其他每层节点都是满的，最后一层从左向右填满二叉树；</p>\n</blockquote>\n<h3>平衡二叉树</h3>\n<blockquote>\n<p>任意节点的左右子树的高度之差不大于1；</p>\n</blockquote>\n<h3>二叉查找树</h3>\n<blockquote>\n<p>二叉查找树：特殊的二叉树，左节点的值比其父节点的值小；此特性使二叉查找树的查找效率很高。 </p>\n<p>遍历顺序：</p>\n<ol>\n<li>\n<p>先序：先访问根节点--->左节点--->右节点；</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function preOrder(node){\n if(!node){\n   print(node.val);\n   preOrder(node.left);\n   preOrder(node.right);\n }\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>中序：先访问左节点--->根节点(根节点在中间)--->右节点；</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function inOrder(node){\n if(!node){\n   inOrder(node.left);\n   print(node.val);\n   inOrder(node.right);\n }\n}\n// 使用循环\nfunction inOrder(root) {\n let cur = root;\n let arr = [], stack = [];\n while(cur || stack.length&gt;0){\n   while(cur){      \n     stack.push(cur);\n     cur = cur.left;\n   }\n   cur = stack.pop();\n   arr.push(cur.val);\n   cur = cur.right;\n }\n return arr;\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>后序：先访问左节点--->右节点--->根节点；</li>\n</ol>\n</blockquote>\n<h2>堆</h2>\n<blockquote>\n<p>堆是具有以下性质的<strong>完全二叉树</strong>：每个结点的值都大于或等于其左右子结点的值，称为大顶堆；</p>\n<p>或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>\n</blockquote>\n<h2>红黑树</h2>\n<h1>排序</h1>\n<p>排序一个长度为 n 的数组的时间复杂度是 O(nlogn)；</p>\n<ul>\n<li>冒泡、选择、插入排序的耗时比较：冒泡 > 选择 > 插入；</li>\n<li>高阶算法：希尔、归并、快速排序：</li>\n<li>空间消耗、平均时间复杂度、最差时间复杂度；</li>\n</ul>\n<h1>查找</h1>\n<ul>\n<li>二分查找、哈希表查找、二叉查找树查找；</li>\n<li>哈希表(散列表查找的时间复杂度是 O(1))</li>\n</ul>\n<h1>方法总结</h1>\n<ol>\n<li>查找二维数组上的搜索路径：<strong>回溯法</strong>；</li>\n<li>某个问题的最优解，且该问题可以分解为多个子问题，子问题也存在最优解，如果将每个小问题的最优解组合可以得到目标问题的最优解，这类情况可以考虑使用<strong>动态规划</strong>；</li>\n<li>在某种特殊情况下可以得到目标问题的最优解：<strong>贪心算法</strong>； </li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 689px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/bda73f8a579a73c62b82167be526be51/0f79a/1563431526213.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 37.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABaUlEQVQozzVR2a6CMBTk/39LE72uILQF1LiwKFR28MGXuZljfCCdnHJmq3M+n1GWJQ6HA2azGVzXhbUWz+cTVVXJHTFnURThdDrher0iCAIkSYK+7wVnWYZhGOA0TYOu6+RHrTVer5eQep4nJMS+78PaEpfLBZ/PRxYfj4dgElLwh531eo37/Q6lFIqylCGVx3ESoTRN8X6/0bYNlNKggbZtsVwuxSnxfD6XHWJnt9tJrDiKUFqLaRzFSdt1GMcRt9tNRIa+RxzH4o7z/X6PoigEbzYbSSORqcT8ge/DhKGQe677ddt1EplVcM7orIYuSUj8c0uHnDu8YG+MnKSpRNNKIcvzL9YaSZKiqWsYY2SJTn5CdE9CumVFDsunulKBWGdnoTH4+1shzzJoY7BarZDnmSRo2lYW2T0fhnixWOB4PH4J6ZD52SFd1nWNKApFvaprxFGIQGkUpZWlaZrk2263cvLBiBmZ+B9AWUelyh/BNAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1563431526213\" title=\"1563431526213\" src=\"/static/bda73f8a579a73c62b82167be526be51/0f79a/1563431526213.png\" srcset=\"/static/bda73f8a579a73c62b82167be526be51/772e8/1563431526213.png 200w,\n/static/bda73f8a579a73c62b82167be526be51/e17e5/1563431526213.png 400w,\n/static/bda73f8a579a73c62b82167be526be51/0f79a/1563431526213.png 689w\" sizes=\"(max-width: 689px) 100vw, 689px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 704px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9cf7eb7bdc0795e640a986f02df18bcb/5ebd7/1563673731524.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABbklEQVQoz21Sjc6DIAzk/Z9zc6Dy6zZQYf1y1TKzfEvIvGu5tlfUsizkvafWGuH3+Xz6abWStZbjEnPO0TiNVGtlzjtH0zRRrY3jyjlLj8eDQghUykrbttG6Hv+lFJrnmWPAOLgMTnLwPVvLGEehotaaRZ/PJ23bykII5pwpxtiL4ADLN/KAuZETK2ct3e93GoaBCYyOcXAghO5wWTgIvN/vf/G+76RAQPB2u1FKibtCgvyPxpC1jkrOzMFTY0zPOfDYscKYINFpSgsbjS55Ka1yESQfuPE3Fsk5rbEIJpB7CmLDOTISfzs0Rh8dlsIclgDPJQf42rGKMTCBpfgQuAq86B56zz7t+9dX8RR5v1jhjUFMtizbky3jnV15TCFxwa/Xq2OFLaJDmI+LUlUqI55L6XxKkQW+OLEo8Lpu3w6N1uzHfrYuF/BOISgjYXwUvmIIih28FBaEj1pz9Xw+ERiNOASEQwPXHHgcYuz4D7EAn40s/6YtAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1563673731524\" title=\"1563673731524\" src=\"/static/9cf7eb7bdc0795e640a986f02df18bcb/5ebd7/1563673731524.png\" srcset=\"/static/9cf7eb7bdc0795e640a986f02df18bcb/772e8/1563673731524.png 200w,\n/static/9cf7eb7bdc0795e640a986f02df18bcb/e17e5/1563673731524.png 400w,\n/static/9cf7eb7bdc0795e640a986f02df18bcb/5ebd7/1563673731524.png 704w\" sizes=\"(max-width: 704px) 100vw, 704px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>","id":"cdab561a-4887-5e78-a1dd-c9d2431b05a0","parent":{"__typename":"File","name":"数据结构基础","base":"数据结构基础.md","mtime":"2022-09-03T14:08:55.932Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/数据算法/数据结构基础/"}},"staticQueryHashes":["3957182205"]}