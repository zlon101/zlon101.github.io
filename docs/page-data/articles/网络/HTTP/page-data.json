{"componentChunkName":"component---src-templates-post-js","path":"/articles/网络/HTTP/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/网络/HTTP/"},"html":"<blockquote>\n<ul>\n<li>HTTP 协议是无状态的，不保留通信状态</li>\n<li>TCP\\IP 协议族按层次分别为：应用层(HTTP、FTP和DNS)、传输(TCP和UDP协议)、网络(IP协议)、数据链路层；</li>\n<li>http 传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</li>\n<li>HTTPS 的 SSL 加密是在<strong>传输层</strong>实现的；</li>\n</ul>\n</blockquote>\n<h1>GET &#x26; POST 的区别</h1>\n<p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。</p>\n<p>浏览器实现上的区别：</p>\n<ul>\n<li>GET 利用 URL 携带参数，参数暴露，URL 长度有限制，进行 URL 编码，产生 1 个TCP 数据包；</li>\n<li>POST 长度没有限制，更加安全，支持多种编码方式，产生 2 个 TCP 包；</li>\n<li>参数的传递：GET 使用 URL 或 cookie传递，POST使用body；</li>\n<li>参数的长度：浏览器和服务端对 URL的长度有限制，HTTP协议没有限制参数的长度；</li>\n<li>GET可以被缓存，POST不能；</li>\n</ul>\n<p>HTTP规范</p>\n<ul>\n<li><strong>幂等性</strong>：同样的请求被执行一次与连续执行多次的效果是一样的，服务端的状态是一样的，没有副作用，幂等性只和服务端的状态有关；</li>\n<li>在符合规范的情况下，GET、HEAD、PUT是幂等的；</li>\n</ul>\n<p>PUT：使用请求中的负载创建或替换指定的资源；</p>\n<p>参考：</p>\n<ul>\n<li>\n<p><a href=\"https://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html\">HTTP协议详解-真的很经典</a></p>\n</li>\n<li>\n<p><a href=\"https://segmentfault.com/a/1190000018264501\">HTTP 状态码</a></p>\n</li>\n<li>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&#x26;mid=2650215796&#x26;idx=1&#x26;sn=37fe278e3afd9d185671521e1b3d5c12&#x26;chksm=befe155589899c43069f677ddf82f0148b700f1d22e987928b22428ccf3713dcc4286f1bef76&#x26;scene=0&#x26;key=2bb12b254a1b9904b99c3ffe46445fb36666779af33ad8645c57b2ed181b5a5ec645fcf932e6bec081a0fb951ec8d38b4d7f715e1ac2b86d1cdf3a0f974d5bae8b8bef9c428816cbd85b98ebf0b34f8d&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060720&#x26;lang=zh_CN&#x26;pass_ticket=Pn9cJyIWK2xt%2BmQltkMddf4S5oGoplFdiJ%2B16Yj6gD8L9Zd0WMlQ1u32%2FRJtZE1p\">get &#x26; post的区别</a></p>\n</li>\n</ul>\n<h1>状态码</h1>\n<ul>\n<li>200：OK 请求成功，一般用于 GET 和 POST；</li>\n<li>304：Not modified 未修改，所请求的资源尚未修改，缓存可用，浏览器从缓存中获取数据；</li>\n<li>301：永久重定向；</li>\n<li>302：临时重定向；</li>\n<li>304：Not Modified，GET 请求中带有 <code>If-Match\\If-Modified-Since\\If-None-Match\\If-Range\\If\\UnModified-Since</code> 中任意一个字段，并且服务端资源未更新，可直接使用客户端<strong>缓存</strong>。</li>\n<li>401：未认证</li>\n<li>403：拒绝访问</li>\n</ul>\n<h1>缓存</h1>\n<blockquote>\n<p>缓存：指代理服务器或客户端将（用户）曾经访问过的数据保存在本地，当再次访问时拿来用。</p>\n<p>一般的缓存服务器对于首次访问某个资源无效，并且每次访问都需要询问源web服务器（持有资源实体的服务器）资源是否更新。为了改善这点，一种方法是让web服务器每次资源更新时通知缓存服务器，使缓存服务器上的资源保持最新状态。内容分发（CDN）采用的缓存服务器具有这种功能。</p>\n</blockquote>\n<h2>缓存服务器</h2>\n<blockquote>\n<p>缓存服务器作为代理服务器的一种，部署在服务器端，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源副本。</p>\n<p>是否存在缓存？如何对数据进行缓存？</p>\n<p>源服务器：保存了资源实体的服务器。</p>\n</blockquote>\n<p>缓存服务器代替web服务器注册到DNS服务器中，用户客户端向缓存服务器发送请求。缓存服务器收到请求后判断（<span style=\"color:red\">怎么判断？</span>）请求的数据是否已经保存在缓存中。</p>\n<ul>\n<li>如果没有缓存数据，缓存服务器会以客户端的身份向web服务器发送请求。缓存服务器收到响应后将响应保存在缓存中（磁盘）并记录<strong>保存的时间</strong>，同时缓存服务器以服务器的身份将响应发送给用户客户端。</li>\n<li>如果用户请求的资源在缓存服务器中有缓存数据，缓存服务器会添加一个<code>if-modefied-since</code>头部字段，字段的值就是上次保存的时间。然后缓存服务器将请求转发给web服务器。web服务器收到请求后根据<code>if-modefied-since</code>和资源的最后修改时间判断资源是否发生变化。如果数据没有变化web服务器会返回<code>304 Not Modified</code>。返回的消息到达缓存服务器后，缓存服务器就知道web服务器上的资源和本地缓存一样，就会将缓存的数据返回给用户。</li>\n<li>如果web服务器根据<code>if-modefied-since</code>和资源的最后修改时间判断资源有变化，后续过程和没有命中缓存一样。</li>\n</ul>\n<h2>强缓存 &#x26; 协商缓存</h2>\n<blockquote>\n<p>缓存相关的字段：</p>\n<p>通用字段：<code>Cache-Control</code></p>\n<p>实体字段：<code>Expires、Last-Modified</code></p>\n<p>请求字段中有：<code>If-Match、If-Modified-Since、If-Range、If-*、</code></p>\n<p>响应字段中有：<code>Etag</code></p>\n<p>请求和响应报文中都可以包含通用字段和实体字段</p>\n</blockquote>\n<p>根据响应的 header 决定是哪种缓存；</p>\n<p>强缓存：</p>\n<ul>\n<li>在第一次请求资源时在http响应头设置一个过期时间，在时效内都将直接从浏览器进行获取，不发送请求，状态码为200；</li>\n<li>强缓存相关字段有expires，cache-control，如果cache-control与expires同时存在的话，cache-control的优先级高于expires。</li>\n<li>expires：资源过期时间，服务端配置。</li>\n</ul>\n<p>协商缓存：</p>\n<ul>\n<li>发送请求到服务端，通过http响应头字段 <strong>ETag</strong> 或者 <strong>Last-Modified</strong> 等判断服务器上资源是否修改， 如果修改则从服务器重新获取，如果未修改则 <strong>304</strong> 指向浏览器缓存中进行获取；</li>\n<li>协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match</li>\n</ul>\n<p>HTTP1.0</p>\n<ul>\n<li>强缓存：Expires-以服务端时间为参考设置有效时间，服务端配置，Exprires的缺陷是必须保证服务端时间和客户端时间严格同步；</li>\n<li>协商缓存：Last-Modified/If-Modified-Since(服务端/客户端)；</li>\n</ul>\n<p>HTTP1.1</p>\n<ul>\n<li>强缓存：Cache-Control: Max-Age，服务端配置，以客户端时间为参考，解决了客户端和服务端时间必须同步的问题；</li>\n<li>协商缓存：Etag/If-None-Match：</li>\n</ul>\n<blockquote>\n<p>缓存请求指令，如：Cache-Control: max-age:604800, no-cache</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>no-cache</td>\n<td>强制向源服务器再次验证资源是否有效</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>不缓存请求或响应</td>\n</tr>\n<tr>\n<td>max-age=[秒]</td>\n<td>响应的最大Age值，缓存x秒后过期；</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>缓存响应指令，如: Cache-Control: private, no-store</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>可向任意方提供响应缓存</td>\n</tr>\n<tr>\n<td>no-cache</td>\n<td>缓存前必须先确认其有效性</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>不缓存请求或响应的任何资源</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>no-cache 和 no-store 的区别</p>\n</blockquote>\n<ul>\n<li>\n<p>no-cache: 目的为了防止从缓存中返回过期资源</p>\n<ul>\n<li>强制要求缓存把请求提交给原始服务器进行验证，只使用协商缓存；不代表浏览器不缓存，而是在获取缓存前要向服务器确认资源是否被更改；</li>\n<li>请求中带有<code>no-cache</code> 时，中间的缓存服务器必须将客户端请求转发给源服务器</li>\n<li>响应中带有<code>no-cache</code> 时，缓存服务器不能对资源进行缓存</li>\n</ul>\n</li>\n<li>\n<p>no-store: 禁止浏览器以及所有中间缓存存储任何版本的返回响应， 每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。</p>\n</li>\n</ul>\n<blockquote>\n<p>Cache-Control: max-age:12333 &#x26; expires</p>\n</blockquote>\n<ul>\n<li>请求中包含 max-age 时，如果判断缓存资源的缓存时间比指定的时间小，则返回缓存的资源，否则缓存服务器将请求转发给源服务器。</li>\n<li>当响应中包含 max-age 时，表示响应中的资源保存为缓存的最长时间，并且缓存服务器不需要确认资源的有效性（向源服务器确认资源是否有效、更新）.</li>\n<li>当 max-age 和 expires 同时存在时，HTTP1.1 优先处理 max-age 而忽略 expires，HTTP1.0 刚好相反。</li>\n</ul>\n<blockquote>\n<p>条件请求</p>\n<p>形如: <code>If-xxx</code> 的请求首部字段，源服务器收到附带条件的请求后，只有条件为真时，才会执行请求</p>\n</blockquote>\n<ul>\n<li><code>If-Match:  xxx</code>，服务器对比字段值和资源的<code>ETag</code>值，当两者一致时执行请求，否则返回 412 响应。</li>\n<li><code>If-Modified-Since: xxx</code>，如果在字段指定的日期之后 URI 对应的资源有更新，则服务器执行请求，否则返回 <code>304 Not Modified</code>。此时使用缓存服务器或客户端本地的缓存。资源的更新时间可以根据 <code>Last-Modified</code> 确定。</li>\n</ul>\n<blockquote>\n<p>参考</p>\n</blockquote>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&#x26;mid=2650215884&#x26;idx=1&#x26;sn=0c014d58bee5b5fa5f357e23d456d5ed&#x26;chksm=befe15ed89899cfbc92c261fc5eb654cb3a8a6c6fac129ca4828ff1f10e1d36536aeac46b96a&#x26;scene=0&#x26;key=7a9b0290e45b2078b8b6f5dbd382511d3f9fbb0dd4c5d04f2760b44efa7d5197bbbbfa4ed1e2628017bfb681e01ed2e1e1419e5468205f1a35ea9a00503b089a3ddd778817c87b7b5baf251d7f9e7774&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060720&#x26;lang=zh_CN&#x26;pass_ticket=ykZiUCMsNd2S9UoFxD9hRE9rxPn7dK3oVQwLBFu%2FDuD60Ikn%2Fg9Ot5qQ8Vlo%2Bq11\">浏览器缓存机制</a></li>\n<li><a href=\"%5Bhttps://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn#%E2%80%9Cno-cache%E2%80%9D%E5%92%8C%E2%80%9Cno-store%E2%80%9D%5D(https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn#%22no-cache%22%E5%92%8C%22no-store%22)\">HTTP缓存-developers.google</a></li>\n</ul>\n<h1>TCP</h1>\n<blockquote>\n<p>TCP的整体流程</p>\n<p>TCP头部格式</p>\n<ul>\n<li>ACK: 表示接收数据序号字段有效，一般表示数据已被接收方收到</li>\n<li>SYN: 发送方和接收方相互确认序号，表示连接操作</li>\n<li>FIN: 表示断开连接</li>\n</ul>\n</blockquote>\n<img src=\"assets/HTTP/TCP流程.svg\" align=\"center\" alt=\"TCP流程\">    \n<p>为了准确无误的将数据发送到目标处，TCP 协议采用了三次握手策略：</p>\n<ol>\n<li>客服端发送带有 SYN 标志的数据包给服务器；</li>\n<li>服务器接收数据后回复 ACK 表示可以收到数据，并同时发送一个带有 SYN 标志的数据包；</li>\n<li>客服端发送一个带 ACK 标志的数据包，表示可以收到对方的数据；</li>\n</ol>\n<ul>\n<li>客户端：hello，你是server么？</li>\n<li>服务端：hello，我是server，你是client么</li>\n<li>客户端：yes，我是client</li>\n</ul>\n<p><strong>四次挥手：</strong></p>\n<blockquote>\n<p>因为是全双工的，所以需要四次挥手，断开连接可以由任意一方发起，HTTP1.0中是服务器发起，HTTP1.1中是客户端发起</p>\n</blockquote>\n<ul>\n<li>主动方：客服端和服务器都可以主动发起挥手操作，发送 FIN 表明我的数据发送完了，但还可以接收数据；</li>\n<li>被动方：收到通道关闭的信息，发送 ACK，我收到你发起的关闭请求；</li>\n<li>被动方：数据发送完了后，发送 FIN 表明我的数据也发送完了；</li>\n<li>主动方：发送 ACK ，启动定时器，等待一定时间，若没有接收到数据，表明对方已经关闭，于是自己也关闭连接；</li>\n</ul>\n<h1>建立连接 | 断开连接</h1>\n<blockquote>\n<p>建立连接（三次握手）</p>\n<p>目的：通信双方交互控制信息，并确认双方是否能正常通信</p>\n</blockquote>\n<ol>\n<li>客户端发送一个只有头部信息没有数据的包，头部信息中的控制位 SYN 设置为1，ACK为0，并且带有一个序号初始值；SYN 代表发送方和接收方相互确认序号。</li>\n<li>服务端收到信息后，自身（某个套接字）状态改为正在连接，并返回一个带用SYN为1、ACK为1、带有序号初始值的响应，ACK表示数据已经收到。</li>\n<li>客户端收到SYN为1，表示连接成功，再发送一个ACK为置为1的包，告诉服务端成功收到数据。</li>\n</ol>\n<blockquote>\n<p>断开连接（四次挥手），客户端和服务端都可以发起断开连接的请求，并且都是类似的各子收发两次。</p>\n</blockquote>\n<p>Server   === FIN:1 ===>  Client\nServer   &#x3C;=== ACK号 ===  Client\nServer   &#x3C;=== FIN:1 ===>  Client\nServer   === ACK号 ===>  Client</p>\n<blockquote>\n<p>参考：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIyMTQ4OTM3NQ==&#x26;mid=2247491009&#x26;idx=2&#x26;sn=dc0b5681a2c3c47d67d30b4cbef77413&#x26;chksm=e83aac71df4d2567f9ddb889ec9a18d16f3441132537735e18e5877f032c1de2794d5bd32c45&#x26;scene=0&#x26;xtrack=1&#x26;key=06b6f34db6d09e0101135d0e0f9471fcbe1d399270588f3ad15472f2c5038299378bdf793d0001442f9536eb18b1fc12e8da26baae99321b1d200be29c24dea273ac2354cb7533b61a9c59681526cf14&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060833&#x26;lang=zh_CN&#x26;pass_ticket=hiTxquONQPaTvJxKQrJMJK72ymiupUbRqLJ4%2BR9RU6XsgbR5F7RWrWrttNQHvORo\">握手挥手</a></p>\n</blockquote>\n<h2>持久化连接</h2>\n<ul>\n<li>\n<p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接，比如浏览器浏览一个包含了多张图片的 HTML 页面，在发送请求访问 HTML 页面的同时，还会请求页面里包含的图片、CSS等其他资源，每次的请求多会造成无谓的 TCP 连接建立和断开。</p>\n</li>\n<li>\n<p>为了解决上述问题，提出了持久化连接，持久化连接的特点是只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>\n</li>\n<li>\n<p>HTTP1.1 的默认连接时持久化连接，客户端会在持久化连接上连续发送请求。HTTP1.1 之前的默认连接都是非持久化连接，想要维持持久化连接需要指定 <code>Connection: Keep-Alive; Keep-Alive: timeout=10</code></p>\n</li>\n</ul>\n<h1>HTTPS 的缺点</h1>\n<ol>\n<li>握手阶段更加耗时；</li>\n<li>缓存不如 HTTP 高效；</li>\n<li>SSL 证书需要绑定 IP ，不能再同一个 IP 地址上绑定多个域名，更加对 IVP4 资源的消耗；</li>\n</ol>\n<h1>http1.0 &#x26; http1.1</h1>\n<ul>\n<li>http1.0 默认使用短连接，一次TCP连接只进行一次请求响应，响应结束后断开连接，一次请求就会建立一个TCP连接；</li>\n<li>http1.1默认使用长连接，同一TCP连接可以被多个请求复用，并且可以在同一连接中同时发送多个请求，服务器按顺序进行响应，会导致队头阻塞；在tcp连接保持期间，如果没有数据包发送，需要双方发<strong>检测包</strong>以维持此连接；长连接的请求报文中有 <code>Connection: keep-alive</code>；</li>\n</ul>\n<h2>JSONP</h2>\n<ul>\n<li>\n<p>缺点：</p>\n<p>JSON只支持get，因为script标签只能使用get请求；\nJSONP需要后端配合返回指定格式的数据；</p>\n</li>\n</ul>\n<h1>HTTP 的缺点</h1>\n<ol>\n<li>使用未加密的明文通信，内容可能被窃听。解决方法对通信进行加密或对内容加密。\n<ul>\n<li>对通信进行加密：使用 SSL 建立 HTTPS。</li>\n<li>对传输的内容进行加班：加密报文主体，要求客户端和服务器同时具有加密、解密的功能。</li>\n</ul>\n</li>\n<li>未验证通信双方的身份，可能遭遇伪装。使用证书，确认通信双方的身份。</li>\n<li>无法验证报文的完整性，数据在传输的过程中可能遭遇篡改。\n如何防篡改：\n<ul>\n<li>MD5 和 SHA-1 等散列值校验方法。</li>\n<li>数字签名。</li>\n</ul>\n</li>\n</ol>\n<h1>HTTP 与 HTTPS 的区别</h1>\n<ol>\n<li>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</li>\n<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>\n<li>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为<strong>443</strong>；</li>\n<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>\n<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>\n</ol>\n<h1>HTTPS 工作原理</h1>\n<blockquote>\n<p>HTTPS 不是应用层的一种新协议，只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替了，就是身披 SSL 协议外壳的 HTTP。</p>\n<p>一般 HTTP 直接和 TCP 通信，当使用 SSL 时，HTTP 和 SSL 通信，SSL 再和 TCP 通信。</p>\n</blockquote>\n<blockquote>\n<p>两种加密方式：对称加密、公开密钥加密</p>\n</blockquote>\n<ul>\n<li><strong>对称加密</strong>(也叫共享密钥加密)：加密和解密使用相同的密钥。要解密就要密钥，怎么把密钥安全的发送给对方？</li>\n<li><strong>公开密钥加密</strong>(非对称加密)使用一对非对称的密钥，一把为公开密钥，另一个叫私钥，公钥是公开发布的，私钥是私人的不能让其他人知道。</li>\n<li>通信双方传输数据时，发送方使用<strong>对方</strong>的公开密钥对数据进行加密并发送，接收方收到加密后的数据后使用自己的私钥进行解密（<span style=\"color:red\">公钥加密，私钥解密</span>）。</li>\n<li>HTTPS 采用的混合加密机制，因为非对称加密更复杂，处理速度慢。因此先使用非对称加密【传输对称加密时使用的密钥】，再用对称加密的方式传输其他信息(报文)。</li>\n</ul>\n<blockquote>\n<p>证书的来源及使用</p>\n<p>公钥证书、数字证书、证书是一个东西</p>\n</blockquote>\n<p>使用公开密钥加密收发数据时，需要确定公钥的真实信，数字证书认证机构（CA）就是解决该问题。</p>\n<ol>\n<li>\n<p>服务器运营人员向 CA 机构申请公钥；</p>\n</li>\n<li>\n<p>CA 机构对申请的公钥做<strong>数字签名</strong>，并将该公钥放入公钥证书后绑定在一起后颁发给服务器；</p>\n<p>CA 机构用自己的私钥对申请的公钥进行<strong>数字签名</strong>并颁发公钥证书给服务器。</p>\n<p>公钥证书包含了服务器的公钥和 CA 机构的数字签名。</p>\n</li>\n<li>\n<p>客户端验证来自服务器的证书是否是 CA 机构签发的：</p>\n<p>服务器会将证书发送给客户端，客户端根据<strong>CA 机构的公钥</strong>对收到的证书上的<strong>数字签名</strong>进行验证，验证通过便可知道证书是否是 CA 机构颁发的，即服务器的公钥是否真实可信。</p>\n</li>\n<li>\n<p>CA 机构的公钥必须安全的转交给客户端，多数浏览器开发商会事先在内部植入常用 CA 机构的公钥。</p>\n</li>\n</ol>\n<blockquote>\n<p>HTTPS 通信步骤</p>\n</blockquote>\n<ul>\n<li>客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</li>\n<li>web服务器接收到客户端的请求之后，会将携带了<strong>公钥</strong>的证书传输给客户端。</li>\n<li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li>\n<li>客户端浏览器通过双方协商一致的安全等级，生成<strong>会话密钥</strong>(随机数)，然后通过服务器的<strong>公钥</strong>来加密会话密钥(<strong>非对称加密</strong>)，并将会话密钥传送给服务端。</li>\n<li>服务器通过自己的私钥解密出会话密钥，之后客服端与服务器之间的数据传输都通过该会话密钥加密后传输(对称加密)。</li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIyMTQ4OTM3NQ==&#x26;mid=2247491009&#x26;idx=2&#x26;sn=dc0b5681a2c3c47d67d30b4cbef77413&#x26;chksm=e83aac71df4d2567f9ddb889ec9a18d16f3441132537735e18e5877f032c1de2794d5bd32c45&#x26;scene=0&#x26;xtrack=1&#x26;key=06b6f34db6d09e0101135d0e0f9471fcbe1d399270588f3ad15472f2c5038299378bdf793d0001442f9536eb18b1fc12e8da26baae99321b1d200be29c24dea273ac2354cb7533b61a9c59681526cf14&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060833&#x26;lang=zh_CN&#x26;pass_ticket=hiTxquONQPaTvJxKQrJMJK72ymiupUbRqLJ4%2BR9RU6XsgbR5F7RWrWrttNQHvORo\">HTTPS的传输过程</a></p>\n</blockquote>\n<h1>数字签名</h1>\n<blockquote>\n<p>数字证书、数字签名、HTTPS加密解密</p>\n<p>公钥 私钥 数字签名 证书 CA证书 自签证书</p>\n</blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\">数字签名是什么-阮一峰</a></p>\n<blockquote>\n<p>自签证书</p>\n</blockquote>\n<p>独立构建的认证机构叫自认证机构，有自认证机构颁发的证书称为【自签名证书】</p>\n<p>使用 OpenSSL 程序可以构建属于自己的自认证机构并给自己的服务器颁发证书。但该服务器证书在互联网上不可作为证书使用。</p>\n<p><a href=\"https://ningyu1.github.io/site/post/51-ssl-cert/\">使用 OpenSSL 生成证书和私钥</a>：</p>\n<deckgo-highlight-code language=\"tex\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -subj &quot;/C=US/ST=CA/O=MyOrg, Inc./CN=127.0.0.1&quot; -keyout selfsigned.key -out selfsigned.crt</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E\">使用arcme.sh 生成免费证书</a></p>\n<h1>认证</h1>\n<blockquote>\n<p>确认是谁在访问服务器</p>\n</blockquote>\n<p>为了确认是谁在访问服务器，需要核对的信息包括：</p>\n<ul>\n<li>密码：只有本人知道的字符串信息</li>\n<li>动态令牌：仅限本人持有的设备内显示的一次性密码（TwoFA）</li>\n<li>数字证书：仅限本人（终端）持有的信息</li>\n<li>生物认证：指纹、虹膜等本人生理信息</li>\n<li>IC卡：仅限本人持有的信息</li>\n</ul>\n<blockquote>\n<p>双因素认证</p>\n</blockquote>\n<p>用户设备 + 用户双重认证，比如客户端证书认证客户端设备，账号密码认证用户，这样可以确认是用户本人使用匹配的设备访问服务器。</p>\n<blockquote>\n<p>HTTP 使用的认证方式</p>\n</blockquote>\n<ul>\n<li>BASIC 认证</li>\n<li>DIGEST 认证</li>\n<li>SSL 客户端认证：SSL 客户端认证借助 HTTPS 客户端证书完成认证。</li>\n<li>FormBase 认证（基于表单认证）</li>\n</ul>\n<h1>Cookie</h1>\n<blockquote>\n<p>因为 HTTP 是无状态协议，无法实现状态管理，之前已经认证成功（如登录成功）的用户状态无法通过协议层面保存下来。当该用户下一次继续访问时，服务端也无法将该用户与其他用户进行区分。所以使用 Cookie 管理回话（Session）。</p>\n</blockquote>\n<p>Web网站为了管理用户状态(登录状态)会通过浏览器将一些数据临时写入用户的计算机内。当用户访问该Web网站时，自动将之前存放的数据发送给服务器。</p>\n<ol>\n<li>客户端发送登录信息（如账号、密码）；</li>\n<li>服务器发放包含 <code>Session ID</code> 的 Cookie，将用户的认证状态和 <code>Session ID</code> 绑定后记录在服务器端，记录用户认证状态；</li>\n<li>客户端收到服务器发送的 Cookie 后保存在本地，在之后的请求之后浏览器自动发送 Cookie；</li>\n<li>服务端收到来自客户端的 Cookie 后通过验证 <code>Session ID</code> 识别用户及用户认证状态；</li>\n</ol>\n<p><code>Session ID</code> 用以区分用户的标识符，相当于身份证。</p>\n<table>\n<thead>\n<tr>\n<th>首部字段</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set-Cookie</td>\n<td>响应</td>\n<td>开始状态管理所使用的Cookie信息，通知客户端保存 Cookie</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>请求</td>\n<td>发送给服务器的Cookie信息</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Cookie 字段</p>\n</blockquote>\n<p>结构：<code>k1=v1; k2=v2;</code></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>字段值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>secure</td>\n<td>Set-Cookie: name:value; secure</td>\n<td>只有 https 才发送 Cookie</td>\n</tr>\n<tr>\n<td>HttpOnly</td>\n<td>Set-Cookie: name:value; HttpOnly</td>\n<td>使用 JS 不能读取带有 HttpOnly 属性的 Cookie 内容，主要为了防止跨站脚本攻击（XSS）</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Js 操作 Cookie</p>\n</blockquote>\n<p>Js 中可以通过 <code>document.cookie</code> 对 Cookie 进行 CRUD</p>\n<h2>Cookie | localStorage | sessionStorage 区别</h2>\n<p>三者都保存在浏览器端，并且是同源；</p>\n<ul>\n<li>\n<p>在请求响应的过程中，请求头每次都会携带cookie，在浏览器和服务器端来回传递，存储容量只有大约 4K 左右；</p>\n</li>\n<li>\n<p>sessionStorage 和 localStorage 不会把数据发给服务器，仅在浏览器中保存，存储大小约 5M；</p>\n</li>\n<li>\n<p>sessionStorage 在浏览器窗口关闭后清除，不能持久保持；localStorage 在窗口关闭后依然存在，除非手动清除；Cookie 在设置的过期时间之前一直有效(即使窗口关闭，若没有设置失效时间则在关闭浏览器后失效)；</p>\n</li>\n<li>\n<p>localStorage 和 Cookie 在所有同源窗口中都是共享的；</p>\n</li>\n<li>\n<p>应用场景：</p>\n<ul>\n<li>从安全性来说，因为每次http请求都回携带cookie信息，这样子浪费了带宽，所以cookie应该尽可能的少用，此外cookie还需要指定作用域，不可以跨域调用，限制很多，但是用户识别用户登陆来说，cookie还是比storage好用；</li>\n<li>localstorage可以用来在页面传递参数，sessionstorage可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数；</li>\n</ul>\n</li>\n<li>\n<p>cookie 与 httpOnly &#x26; secure</p>\n<ul>\n<li>cookie 由服务器创建，HttpOnly 是包含在Set-Cookie HTTP<strong>响应</strong>头文件中的附加标志。如果某一个Cookie 选项被设置成 HttpOnly = true 的话，那此Cookie 只能通过服务器端修改，JS 无法读取到cookie信息(<code>document.cookie</code>)，这样能有效的防止XSS攻击；（<code>document.cookie</code>无法访问带有 httponly 属性的 cookie）。</li>\n<li>标记为 <code>Secure</code> 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。</li>\n<li><code>cookie</code> 和 <code>set-cookie</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Cookie 和 session 的区别，localstorage 和 sessionstorage 的区别</p>\n</blockquote>\n<ul>\n<li>Cookie 和 session 都可用来存储用户信息，<strong>cookie存放于客户端</strong>，<strong>session存放于服务器端</strong>，因为cookie存放于客户端有可能被窃取，所以cookie一般用来存放不敏感的信息，敏感的信息用session存储；session可以存放于文件，数据库，内存中都可以，cookie可以服务器端响应的时候设置，也可以客户端通过 JS 设置 cookie 会在请求时在http首部发送给客户端，cookie一般在客户端有大小限制，一般为4K，</li>\n<li>同域名的资源请求时，浏览器会默认带上本地的cookie；</li>\n</ul>\n<blockquote>\n<p><a href=\"https://mp.weixin.qq.com/s/tkWPYyO_inTG1X76V-MKoQ\">彻底理解 cookie、session、token</a></p>\n<ul>\n<li>cookie 和 token 都是由服务器生成，发送给浏览器</li>\n</ul>\n</blockquote>\n<h1>WebSocket</h1>\n<blockquote>\n<p>浏览器与服务器进行全双工通信，可相互发送任意格式的数据。</p>\n</blockquote>\n<p>WebSocket 建立在 HTTP 基础上，连接的发起方是客户端，WebSocket 连接建立后希望一直保持连接状态。</p>\n<p>要实现 WebSocket 通信，在 HTTP 连接建立之后需要完成一次握手步骤：</p>\n<img src=\"assets/HTTP/WebSocket通信.svg\" style=\"background-color:#fff\">\n<p align=\"center\">WebSocket 通信</p>\n<blockquote>\n<p>WebSocket API</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// websocket url 格式: ws://example.com/  wss://example.com/\nconst socket = new WebSocket(&#39;ws://game.example.com:1200/xx&#39;);\nsocket.onopen = function() {\n  setInterval(() =&gt; {\n    if (socket.bufferedAmount === 0) {\n      socket.send(&#39;xxxx&#39;);\n    }\n  });\n};</code>\n        </deckgo-highlight-code>\n<h1>网络攻击</h1>\n<p>从浏览器那里接收到得 HTTP 请求的全部内容都可以在客户端任意篡改。</p>\n<p>在 HTTP 请求报文内容加载攻击代码就能发起对 Web 应用的攻击，通过 URL 查询字段、表单、HTTP 首部、Cookie 等途径把攻击代码传入，若 Web 应用存在安全漏洞则会被攻击者窃取内部信息或管理权限。</p>\n<blockquote>\n<p>攻击模式</p>\n</blockquote>\n<p>针对 Web 应用的攻击模式有两类</p>\n<ul>\n<li>主动攻击：直接针对服务器上的资源进行攻击，攻击者需要能访问服务器资源，代表有：\n<ul>\n<li>SQL 注入：针对 Web 应用的数据库攻击</li>\n<li>OS 命令注入：通过 Web 应用执行非法的操作系统命令</li>\n</ul>\n</li>\n<li>被动攻击：利用圈套策略执行攻击代码，攻击者在页面设置陷阱，用户触发陷阱并把含有攻击代码的 HTTP 请求发送给 Web 应用，执行攻击代码。代表有：\n<ul>\n<li>跨站脚本攻击</li>\n<li>跨站点请求伪造</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>跨站脚本攻击</p>\n</blockquote>\n<p>跨站脚本攻击(XSS, Cross Site Scripting)：网站(HTML 文档)被注入了非法恶意脚本(element.innerHTML 插入<code>&#x3C;script></code> 标签)；</p>\n<ul>\n<li>解决方法</li>\n</ul>\n<p>1:内容安全策略：<code>script-self</code>\n2:符号转义：&#x3C;>（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;(分号)、()（括号）、&#x26;（&#x26; 符号）、+（加号）等转义；</p>\n<blockquote>\n<p>跨站请求伪造CSRF</p>\n</blockquote>\n<ul>\n<li>解决方法：</li>\n</ul>\n<p>1：检查referer字段；\n2：添加校验Token；\n3：通过输入验证码校验合法请求；</p>\n<blockquote>\n<p>提高安全性</p>\n</blockquote>\n<p>输入验证、输出转义</p>\n<h2>内容安全策略</h2>\n<ul>\n<li>\n<p><code>CSP</code> 的主要目的是防止跨站脚本攻击（XSS）。</p>\n</li>\n<li>\n<p>启用 CSP 的两种方法：</p>\n<ol>\n<li>HTTP 头信息的 <code>Content-Security-Policy</code> 的字段；</li>\n<li>HTML 文件的 <code>&#x3C;meta></code> 标签；</li>\n</ol>\n</li>\n<li>\n<p><code>script-src</code> 和 <code>object-src</code> 是必设的，除非设置了<code>default-src</code>。\n因为攻击者只要能注入脚本，其他限制都可以规避。而<code>object-src</code>必设是因为 Flash 里面可以执行外部脚本；</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"json\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;;\nstyle-src cdn.example.org third-party.org; child-src https:</code>\n        </deckgo-highlight-code>\n<p>参考：<a href=\"http://www.ruanyifeng.com/blog/2016/09/csp.html\">Content Security Policy 入门教程-阮一峰</a></p>\n<h1>前端优化</h1>\n<ol>\n<li>CDN 分发：首次加载缓存无效，使用CDN进行内容分发，进静态内容分发到CDN上；</li>\n<li>加快请求速度：预解析DNS，减少域名数，并行加载；\n<code>&#x3C;meta http-equiv='X-dns-prefetch-control' content='on'></code></li>\n<li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。</li>\n<li>减少请求的次数：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</li>\n<li>路由懒加载，组件按需加载；</li>\n<li>渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。</li>\n</ol>\n<h1>HTTP 2.0</h1>\n<ol>\n<li>首部压缩（http头部压缩，减少体积）</li>\n<li>二进制分帧：http1.X的解析是基于<strong>文本</strong>的；</li>\n</ol>\n<p>请求和响应会被分解成一一个的帧，并对他们采用二进制格式编码，每个帧都会在一个 TCP 链路中无序的传输，同一个请求的帧有相同的Stream Identifier，当帧到达服务端之后，就可以根据 Stream Identifier 来重新组合得到完整的请求。\n3. 允许多路复用：同一个连接中可以同时发送多个请求或响应，并且请求和响应不需要按顺序对应，避免了队头阻塞（一条 TCP 连接上可以处理多个 HTTP 请求）；\n4. 内容安全，因为http2.0是基于https；</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 727px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3d2cd2db4236027f7ae14e1b562b6f7a/c54b3/http2%E7%9A%84%E4%BC%98%E7%82%B9.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9klEQVQ4y6VT7Y6kIBCc93/MncuooAiCqMxoXaoU95JN9s+ZtDQfVlVX46M4h8MY7F2HwwfsTYN9HLH/eWL/+sLetuf4fOLYCg4Ax3H8CD77vuOhSY1z9Xv+b173f3kEuJUC5xyGYcA8Z6zripQS0jwrn+dZOccQgsJ7rzM5Z2zrimmaNKe4x7ZtyHO+QdumQdM0MMag7wdYay+y+QaPMWJZFoETtO97rQuQm6/XS6wMAllrROBD0Mfv9xvrsoDknDNYDcHiFFHKhrKVs2QytW0La3sxUhGBh76H7XvlVMAopQiEwe9oicreNu1JIVFZf/XHGgtrDIy1Aum67iastozjqCpUFXNjME1RjXnwRQZ+zHJjSqdXHPN3k5ZlxZzOxrBkjlxnzpEYAqRCdomAo3MI3mteDa8AlaQScE5vWXqKCaW8z5KrwloKVSq/vGMeL0LuGWN1jiS0gGu0hQR3yWTiJhtiL++8HzVSoRucmkRwzZ0772pKAuc68xuQ6DS9quDo3ADvw02idd6AcZQi2kKgrjMwnMerKaybvrBjIUxSSwsY9JfBK1GvBvcZyj+f+zzPCTDGSYzVC14RBr0yppO6WhZVh2m6fwCeZ/DPYgMFWK8My/58PveF1S+Zs9ap5lR3Kb3ULjnfnX/XLi/XvzhcRv/v8xdYQdKKj7YIEwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"http2的优点\"\n        title=\"http2的优点\"\n        src=\"/static/3d2cd2db4236027f7ae14e1b562b6f7a/c54b3/http2%E7%9A%84%E4%BC%98%E7%82%B9.png\"\n        srcset=\"/static/3d2cd2db4236027f7ae14e1b562b6f7a/772e8/http2%E7%9A%84%E4%BC%98%E7%82%B9.png 200w,\n/static/3d2cd2db4236027f7ae14e1b562b6f7a/e17e5/http2%E7%9A%84%E4%BC%98%E7%82%B9.png 400w,\n/static/3d2cd2db4236027f7ae14e1b562b6f7a/c54b3/http2%E7%9A%84%E4%BC%98%E7%82%B9.png 727w\"\n        sizes=\"(max-width: 727px) 100vw, 727px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","id":"b8be3133-f8f3-5384-93fd-b2aef1a09925","parent":{"name":"HTTP","base":"HTTP.md","mtime":"2022-09-07T04:15:03.283Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/网络/HTTP/"}},"staticQueryHashes":["3957182205"]}