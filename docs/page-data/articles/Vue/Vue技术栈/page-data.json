{"componentChunkName":"component---src-templates-post-js","path":"/articles/Vue/Vue技术栈/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/Vue/Vue技术栈/"},"html":"<h4>Vue全家桶</h4>\n<ul>\n<li>vuex：状态管理</li>\n<li>vue-router：路由</li>\n<li>vue-resource &#x26; axios(通用)：http请求</li>\n<li>vuelidate：表单验证</li>\n</ul>\n<h4>Vuex</h4>\n<h5>1. 基本使用</h5>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">import Vuex from &#39;vuex&#39;;\nimport Vue from &#39;vue&#39;;\n\nVue.use(Vuex);\n\nconst store = new Vuex.Store({\n    state: {\n        count: 0\n    },\n    // 读取状态, 插值表达式{{ $store.getters.doubleCount }}\n    getters: {\n        // 类似计算属性computed, 起到缓存的作用\n        doubleCount(state){\n            return state.count * 2;\n        }\n    }\n    \n    /*\n\tmutations:\n    \t由组件触发:\n    \t&lt;button @click=&quot;$store.commit(&#39;increment&#39;, 2)&quot;&gt;触发commit&lt;/button&gt;\n    */\n    mutations: {\n        increment(state, newV){\n            state.count = state.count + newV;\n        }\n    },\n    \n    /*\n    触发方式\n    \t&lt;button @click=&quot;$store.dispatch(&#39;incrementAction&#39;, 2)&quot;&gt;触发dispatch&lt;/button&gt;\n    \t\n    \tactions 应该避免直接操作 state，state 的更改应该由 mutations 完成, 否则vue-devtools插件无法记录state的变更。\n    \tactions 可以根据当前 state 进一步处理数据, 计算或请求后端接口, 然后通过commit的方式提交给mutations去处理。\n\n    */\n    actions: {\n        incrementAction(ctx, newV){\n            let commit = ctx.commit;\n            setTimeout( () =&gt; commit(&#39;increment&#39;), 3000);\n        }\n    }\n});\n\nnew Vue({\n    store: store,\t\t// 在组件实例中通过this.$store访问该store\n    render: h =&gt; h(App)\n}).$mount(&#39;#app&#39;);\n\n// 在组件实例中读取store\ncomputed: {\n\tcount(){\n        return this.$store.state.count;\n    }\n}\n\n// 修改store</code>\n        </deckgo-highlight-code>\n<h5>2. 核心概念和原理</h5>\n<p><img src=\"assets/Vue%E6%8A%80%E6%9C%AF%E6%A0%88/1561195170226.png\" alt=\"1561195170226\" style=\"zoom: 67%;\" />   <img src=\"assets/Vue%E6%8A%80%E6%9C%AF%E6%A0%88/1561203551146.png\" alt=\"1561203551146\" style=\"zoom:67%;\" />    </p>\n<ul>\n<li>\n<p><strong>vuex底层实现</strong></p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 简化版Vuex vue-min.js\nimport Vue from &#39;vue&#39;\nconst Store = function Store (options = {}) {\nconst {state = {}, mutations={}} = options;\nthis._vm = new Vue({\n  data: {\n    $$state: state\n  },\n})\nthis._mutations = mutations\n}\n\nStore.prototype.commit = function(type, payload){\nif(this._mutations[type]) {\n  // this.state访问的是原型上面的state 数据项\n  this._mutations[type](this.state, payload)\n}\n}\n\nObject.defineProperties(Store.prototype, { \nstate: { \n  get: function(){\n    // this._vm._data 而不是 _vm.data,  \n    return this._vm._data.$$state\n  } \n}\n});\nexport default {Store}\n\n// 使用简化版Vuex\nimpore vuexMin from &#39;vue-min.js&#39;;\n\nconst store = new vuexMin.Store({\n  state: {\n      count: 0\n  },\n  mutations: {\n      increment(state, newV){\n          state.count = state.count + newV;\n      }\n  }\n})\n\nVue.prototype.$store = store;\nnew Vue({\n  el: &#39;xx&#39;,\n  rendre: ...\n});</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5>1. Vuex结构</h5>\n<table style='width:50px'>\n<tr>\n\t<th colspan=\"2\">this.$store</th>\n</tr>\n<tr>\n\t<td rowspan=\"2\" style='vertical-align:center'>getter</td>\n\t<td>action</td>\n</tr>\n<tr>\n\t<td>mution</td>\n</tr>\n<tr>\n\t<td colspan=\"2\">this.$store.state</td>\n</tr>\n</table>\n<h5>问答</h5>\n<ol>\n<li>$store是如何挂载到实例this上的?</li>\n<li></li>\n</ol>\n<hr>\n<h4><a href=\"https://router.vuejs.org/zh/\">vue-router使用</a></h4>\n<blockquote>\n<ul>\n<li>作用：通过组合组件组成应用。将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染组件。</li>\n</ul>\n</blockquote>\n<ol>\n<li>\n<p>安装vue-router，js文件导入，注册，配置</p>\n<p>npm install vue-router --save</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// main.js\nimport VueRouter from &#39;vue-router&#39;;\nimport Vue from &#39;Vue&#39;;\n\nVue.use(VueRouter);\t\t\t\t// 注册插件\n\nconst router = new VueRouter({\t// 配置路由\n   mode: &#39;history&#39;,\n   routes: [\n       {path: &#39;/&#39;, component: 组件1}\n       ...\n   ]\n});\n\n// 根实例\nnew Vue({\n   el: &#39;#app&#39;, \n   router: router\n})</code>\n        </deckgo-highlight-code>\n</li>\n<li>使用&#x3C;router-view>挂载路由，&#x3C;router-link>链接路由</li>\n</ol>\n<h4>预渲染</h4>\n<p>单页面(SPA) 应用的 SEO 优化有服务端渲染(SSR) 和页面预渲染两种方法。</p>\n<ul>\n<li>预渲染的使用场景更多是简单的静态页面，加快页面的加载速度，并且侵入性更小，在已上线的项目稍加改动也可以轻松引入预渲染机制。</li>\n<li>服务端渲染适用于复杂、较大型、与服务端交互频繁的功能型网站，比如电商网站。SSR方案则需要将整个项目结构推翻。</li>\n</ul>\n<h5>vue 预渲染实现</h5>\n<blockquote>\n<p>插件：prerender-spa-plugin &#x26; vue-meta-info</p>\n<p> npm install prerender-spa-plugin --save-dev</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// vue.config.js\n// 这三项一定要有，因为下面configureWebpack中用到了\nconst PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;);\nconst Renderer = PrerenderSPAPlugin.PuppeteerRenderer;\nconst path = require(&#39;path&#39;);\n\nmodule.exports = {\n  // 预渲染关键配置\n  configureWebpack: () =&gt; {\n    if (process.env.NODE_ENV !== &#39;production&#39;) return;\n    return {\n      plugins: [\n        new PrerenderSPAPlugin({\n          // 生成文件的路径，也可以与webpakc打包的一致。\n          // 下面这句话非常重要！！！\n          // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。\n          staticDir: path.join(__dirname, &#39;dist&#39;),\n  \n          // 对应自己的路由文件，如果有参数需要写具体参数，比如/a/:id需要写/a/123456\n          routes: [&#39;/&#39;, &#39;/about&#39;],\n  \n          // 这个很重要，如果没有配置这段，也不会进行预编译\n          renderer: new Renderer({\n            inject: {\n              foo: &#39;bar&#39;\n            },\n            headless: false,\n            // 在 main.js 中 document.dispatchEvent(new Event(&#39;render-event&#39;))，两者的事件名称要对应上。\n            renderAfterDocumentEvent: &#39;render-event&#39;\n          })\n        })\n      ]\n    };\n  }\n};\n\n// main.js\n  new Vue({\n    router,\n    store,\n    render: (h) =&gt; h(App),\n    // 添加mounted，不然不会执行预编译\n    mounted() {\n      document.dispatchEvent(new Event(&#39;render-event&#39;));\n    }\n  }).$mount(&#39;#app&#39;);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>服务端配置</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">History 模式需要后台配置支持，最简单的是通过 nginx 配置 try_files 指令。</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5>vue-meta-info</h5>\n<ul>\n<li>\n<p>组件内使用</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;script&gt;\nexport default {\n  metaInfo: {\n    title: &#39;My Example App&#39;, // set a title\n    meta: [{                 // set meta\n      name: &#39;keyWords&#39;,\n      content: &#39;My Example App&#39;\n    }]\n    link: [{                 // set link\n      rel: &#39;asstes&#39;,\n      href: &#39;https://assets-cdn.github.com/&#39;\n    }]\n  }\n}\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h4>单页面首屏加载优化</h4>\n<ol>\n<li>路由懒加载</li>\n<li>按需加载三方资源，如iview,建议按需引入iview中的组件</li>\n<li>将一些静态js css放到其他地方（如OSS），减小服务器压力</li>\n<li>使用CDN资源,减小服务器带宽压力</li>\n<li>使用nginx开启gzip减小网络传输的流量大小</li>\n<li>若首屏为登录页，可以做成多入口，登录页单独分离为一个入口</li>\n<li>使用uglifyjs-webpack-plugin插件代替webpack自带UglifyJsPlugin插件</li>\n</ol>\n<hr>\n<h4>vue资源</h4>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&#x26;mid=2650215743&#x26;idx=1&#x26;sn=2e2e67c19d24816c71351e81ef03a03d&#x26;chksm=befe151e89899c08cb755d67b14cd967f901e254c4e97e4a726b97cacdcb67faa52cc755f697&#x26;scene=0&#x26;key=2bb12b254a1b9904689047cb60b0e67a6d34c1466c57dc39d88f470f6ea5d06cc8b576a7eebc2a97aff410a4a7b0971419dea5e96612d186881de313fd07ea0296760dba9c91a8dbe297bfe59adf6437&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060720&#x26;lang=zh_CN&#x26;pass_ticket=Pn9cJyIWK2xt%2BmQltkMddf4S5oGoplFdiJ%2B16Yj6gD8L9Zd0WMlQ1u32%2FRJtZE1p\">vue 项目接口管理</a></li>\n</ul>\n<hr>\n<ul>\n<li><code>$nextTick</code> 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 <code>$nextTick</code>，则可以在回调中获取更新后的 DOM；</li>\n<li></li>\n</ul>","id":"fada9550-f547-516a-bb90-aa1afcfe78bf","parent":{"__typename":"File","name":"Vue技术栈","base":"Vue技术栈.md","mtime":"2022-03-30T03:12:22.916Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/Vue/Vue技术栈/"}},"staticQueryHashes":["3957182205"]}