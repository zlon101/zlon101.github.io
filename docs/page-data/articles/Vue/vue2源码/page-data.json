{"componentChunkName":"component---src-templates-post-js","path":"/articles/Vue/vue2源码/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/Vue/vue2源码/"},"html":"<h1>概念</h1>\n<blockquote>\n<p>关键词 | 核心概念</p>\n</blockquote>\n<ul>\n<li>\n<p>数据劫持</p>\n<ul>\n<li>vue2 中通过 <code>defineProperty</code> 定义对象属性的 <code>getter</code> 和 <code>setter</code> 和重写数组的部分方法实现数据劫持，当数据被访问时进行依赖收集（订阅），当数据被修改时通知所有的订阅者更新</li>\n</ul>\n</li>\n<li>\n<p>双向绑定</p>\n<ul>\n<li>MVVM，数据和视图进行双向绑定，1）当数据更新时视图自动更新，2）当视图更新时（用户输入）数据自动更新。</li>\n<li>Vue 是通过数据劫持 + 发布订阅模式来实现双向绑定。第一点通过数据劫持实现，第二点通过事件监听实现（<code>v-modle</code> 只是语法糖）。</li>\n</ul>\n</li>\n</ul>\n<p>响应式\r\n异步更新\r\n可观察对象 <code>Observer</code></p>\n<p>发布-订阅\r\nDep\r\nWatcher</p>\n<h1><code>new Vue</code></h1>\n<blockquote>\n<p><a href=\"https://github.com/Holybasil/Blog/issues/13\">Vue 的初始化过程都做了什么？</a></p>\n</blockquote>\n<ul>\n<li>initMixin、stateMixin、eventsMixin、lifecycleMixin、renderMixin</li>\n<li>处理组件配置项，选项合并，初始化 Vue 属性（$parent、$root、$children）</li>\n</ul>\n<blockquote>\n<p>实例化（new Vue(options)）</p>\n</blockquote>\n<h1>响应式流程</h1>\n<blockquote>\n<p>简述</p>\n</blockquote>\n<ul>\n<li>在 Vue 初始化过程中，为 data 对象中的每一个属性key定义【setter】和【getter】。</li>\n<li>当页面初次渲染时，执行渲染函数，访问属性时，会触发【getter】，从而收集依赖，将【Dep】和【Watcher】关联起来。（render View时进行依赖收集）</li>\n<li>当修改属性key时，会触发【setter】，从而通过 Dep 通知 Watcher 执行 update。之后，重新渲染页面。</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;div&gt;\r\n    &lt;p id=&quot;name&quot;&gt;&lt;/p&gt;\r\n&lt;/div&gt;\r\n\r\n&lt;script&gt;\r\n\tvar obj = { };\r\n\t\r\n\tObject.defineProperty(obj, &#39;name&#39;, {\r\n\t\tget(){\r\n\t\t\treturn document.querySelector(&#39;#name&#39;).innerHTML;\r\n\t\t}，\r\n\t\tset(val){\r\n\t\t\tdocument.querySelector(&#39;#name&#39;).innerHTML = val;\r\n\t\t}\r\n\t});\r\n\t\r\n\tobj.name = &#39;czl&#39;;\t// 执行set函数\r\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<h2>vue 响应式原理</h2>\n<p>响应式的数据分为两类：</p>\n<ul>\n<li>\n<p>对象，循环遍历对象的所有属性，为每个属性设置 getter、setter，以达到拦截访问和设置的目的，如果属性值依旧为对象，则递归为属性值上的每个 key 设置 getter、setter</p>\n<ul>\n<li>访问数据时（obj.key)进行依赖收集，在 dep 中存储相关的 watcher</li>\n<li>设置数据时由 dep 通知相关的 watcher 去更新</li>\n</ul>\n</li>\n<li>\n<p>数组，增强数组的那 7 个可以更改自身的原型方法，然后拦截对这些方法的操作</p>\n<ul>\n<li>添加新数据时进行响应式处理，然后由 dep 通知 watcher 去更新</li>\n<li>删除数据时，也要由 dep 通知 watcher 去更新</li>\n</ul>\n</li>\n</ul>\n<h2>数组的响应式更新</h2>\n<ul>\n<li>修改数组的原型，在原型上重写 <code>push</code>、<code>pop</code>、<code>split</code> 等方法</li>\n<li>若数组项是对象，则该对象是响应式更新，否则不会</li>\n</ul>\n<h1>watcher &#x26; dep</h1>\n<p>在 Vue 中共有三种 Watcher，分别为【 render watcher】，【computed watcher】，【user watcher】($watch)。\r\n三种 watcher 的创建顺序和更新时的执行顺序都是 computed watcher、user watcher、render watcher。</p>\n<p>组件更新顺序是：父组件先更新，然后更新子组件（因为父组件先于子组件创建）。\r\n用户定义的【watcher】先于【render watcher】执行，因为先创建【user watcher】再创建【render watcher】。</p>\n<blockquote>\n<p>三种 Watcher 创建的时间点</p>\n<p>compute watcher 在初始化 State 时（<code>initState => initComputed</code>）\r\nuser watcher 在初始化 State 时（<code>initState => initWatch</code>）\r\nrender watcher 在挂载时创建(<code>$mount</code>)</p>\n</blockquote>\n<p><code>vm._watcher => render watcher</code>。\r\n<code>vm._watchers</code> 保存了当前实例的所有（三种）watcher。</p>\n<p>若用户定义的【watcher】设置了 <code>immediate: true</code>，在创建 watcher 时就会执行 <code>handle</code>。</p>\n<blockquote>\n<p>Observer</p>\n</blockquote>\n<p>观察者，收到 Dep 的通知后，执行 <code>update</code>，重新渲染。（监听器，用来监听属性的变化通知订阅者）。\r\nObserver 的作用就是遍历对象的所有属性将其进行双向绑定，如果是对象，则进行深度递归遍历，将每一个子对象都转化成响应式对象。\r\n如果是数组，则会对每一个成员都执行一遍 observe 方法，并对其原生的数组方法进行改写</p>\n<p><strong>三类响应式数据：</strong></p>\n<ol>\n<li>props</li>\n</ol>\n<p>如果不是根组件，则只对 props 做shalow reactive（浅层响应式）</p>\n<ol start=\"2\">\n<li>data</li>\n<li>computed</li>\n</ol>\n<p>计算属性不会转化为响应式属性，不会作为其他数据的依赖，也不会创建【Dep】。其他需要用到某个计算属性的数据会将这个计算属性的依赖添加到自己的依赖集中。</p>\n<blockquote>\n<p>Dep：订阅者，负责将数据变化的消息通知给所有的 Watcher，Watcher 和 Dep 是多对多的关系</p>\n</blockquote>\n<ul>\n<li><code>pushTarget</code>、<code>popTarget</code></li>\n</ul>\n<blockquote>\n<p>Watcher：订阅者，收到属性的变化，然后更新视图</p>\n</blockquote>\n<ul>\n<li>Watcher.addDep(Dep)：为Watch添加依赖</li>\n<li><code>dep.depend()：Dep.target.addDep(dep)</code>，watcher 中保存了 dep，dep 中也保存了 watcher</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">addDep (dep: Dep) {\r\n  const id = dep.id\r\n  if (!this.newDepIds.has(id)) {\r\n    this.newDepIds.add(id)\r\n    this.newDeps.push(dep)\r\n    if (!this.depIds.has(id)) {\r\n      dep.addSub(this)\r\n    }\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>创建dep</p>\n</blockquote>\n<p>defineReactive()\r\nnew Observer() &#x3C;= observe</p>\n<ul>\n<li>observe：$data、数组中的对象、propsData</li>\n</ul>\n<blockquote>\n<p>触发更新：</p>\n</blockquote>\n<p>对象是通过 setter 修改器来触发更新的，数组是通过7个原型方法mutator的执行来触发更新。</p>\n<ul>\n<li>修改对象属性：setter() => dep.notify() => Watch.update() => queueWatcher(watch) => nextTick(执行队列中的watch) => watch.run() =></li>\n<li>修改数组：</li>\n</ul>\n<blockquote>\n<p>reactiveGetter：代理属性，在 getter 中收集依赖，在 setter 中触发更新</p>\n</blockquote>\n<blockquote>\n<p>proxyGetter：代理实例的 data、methods、props 对象上的属性，实现在实例上访问 data、methods 上的属性(<code>this.x</code>)</p>\n</blockquote>\n<h1>异步更新</h1>\n<p>可能你还没有注意到，Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>\n<p>例如，当你设置 <code>vm.someData = 'new value'</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。</p>\n<blockquote>\n<p>步骤</p>\n</blockquote>\n<p>1): 响应式数据（dep）变化触发 setter 或重写的数组方法；</p>\n<p>2): dep 通知它的所有订阅者更新（遍历 dep.subs 并执行 <code>sub.update()</code>，订阅者就是 watcher）;</p>\n<p>3): watcher 判断当前是同步更新、异步更新还是懒更新（对应计算属性），如果是异步更新判断异步队列中是否已经有当前 watcher，若没有就将当前 watcher 加入到队列中（队列中的 watcher 是按 watcher.id 排序）；</p>\n<p>4): 在 nextTick 时清空队列，执行队列中的 watcher，先执行 watcher.before 再执行 watcher.run</p>\n<p>5): 重置状态，调用组件 update、activated hooks</p>\n<h1>Q</h1>\n<blockquote>\n<p>Reflect Proxy</p>\n</blockquote>\n<ol>\n<li>Object.defineProperty只能劫持对象的属性，而Proxy是直接代理对象。</li>\n</ol>\n<p>由于 <code>Object.defineProperty</code> 只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 <code>Proxy</code> 直接代理对象，不需要遍历操作。</p>\n<ol start=\"2\">\n<li>Object.defineProperty对新增属性需要手动进行Observe</li>\n</ol>\n<p>由于 <code>Object.defineProperty</code> 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用 <code>Object.defineProperty</code> 进行劫持。</p>\n<blockquote>\n<p>$nextTick 回调什么时候执行？</p>\n</blockquote>\n<ul>\n<li><code>Promise.resolve().then(执行nextTick)</code>，主线程执行完后执行微任务时执行 <code>nextTick</code></li>\n<li>计算属性不会加入异步队列</li>\n</ul>\n<blockquote>\n<p>为什么不用 <code>Object.defineProperty 劫持数组索引</code> ？</p>\n</blockquote>\n<ul>\n<li>使用 <code>$set</code> 修改数组索引时可以实现响应式更新，Why？执行的重写之后的数组方法，<code>arr.splice</code></li>\n<li><a href=\"https://juejin.cn/post/6844904046722023438\">vue为什么不能检测数组的变化</a>：JS 是可以劫持通过数组索引进行修改，只是因为性能问题没有这样做，比如 <code>arr.unshift()</code> 会触发原数组中所有索引的 getter 和 setter。</li>\n</ul>\n<blockquote>\n<p>计算属性的缓存是怎么实现的？</p>\n</blockquote>\n<ul>\n<li>每个计算属性都会创建一个 watcher，计算属性的值实际上是 watcher.value，而只有 watcher 的依赖项变化时才会重新计算 watcher.value</li>\n<li>UI 依赖于某个计算属性，读取计算属性时，会将当前 Dep.target 加入到计算属性 watcher 中的 dep 列表中每项的订阅列表中\n<ul>\n<li>某个watcher-a  依赖于某个计算属性 ==> 该计算属性依赖于其他 dep 项 ==> 将 watcher-a 加入到 dep 项的订阅列表中</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>computed 和 watch 配置的区别？</p>\n</blockquote>\n<ul>\n<li>computed 默认为懒执行，dirty 为 true。watch 有 immediate 配置，可以实现立即执行一次 cb</li>\n<li>computed 支持缓存，依赖数据发生改变，才会重新进行计算。watch 不支持缓存，立即响应式变化</li>\n<li>computed 不支持异步，watch 支持异步</li>\n</ul>\n<blockquote>\n<p>pushTarget(watcher)，watcher 为空时表示不进行依赖收集，如执行 lifecycle hooks、data getters（执行组件配置中的 <code>data()</code> 函数）</p>\n</blockquote>\n<blockquote>\n<p>监听生命周期钩子: <code>@hook:beforeDestroy</code>、<code>@hook:mounted</code> ， 事件的监听和派发是在同一个组件上</p>\n</blockquote>\n<h1>diff 算法</h1>\n<blockquote>\n<p>updateChildren</p>\n<p>同层比较，首尾同时遍历\r\ndiff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)。</p>\n</blockquote>\n<ul>\n<li>更新子节点采用了 diff 算法</li>\n<li>做了四种假设，假设新老节点开头结尾有相同节点的情况，一旦命中假设，就避免了一次循环，以提高执行效率</li>\n<li>如果不幸没有命中假设，则执行遍历，从老节点中找到新开始节点</li>\n<li>找到相同节点，则执行 patchVnode，然后将老节点移动到正确的位置</li>\n<li>如果老节点先于新节点遍历结束，则剩余的新节点执行新增节点操作</li>\n<li>如果新节点先于老节点遍历结束，则剩余的老节点执行删除操作，移除这些老节点</li>\n</ul>\n<blockquote>\n<p>是否是同一个vnode</p>\n</blockquote>\n<p>vnode,key、tag,isComment都相同,并且都定义了对于vnode的数据对象。如果两个vnode是input标签的,那么type也一致,那么就说明这两个vnode是相同的vnode。</p>\n<h1>依赖收集与数据跟踪</h1>\n<p>vue 在实例化的时候, 会对【data】对象中的每一个属性, 去做数据跟踪, 但是在写业务逻辑时, 会有很多的属性其实在视图层根本用不到, 但是这个属性在下面的【methods】的方法中会用到, 比如下面的代码:</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">export default {\r\n  data () {\r\n    return {\r\n      title: &#39;xxx&#39;, \t\t// 这个属性需要在视图层用到, 需要加上数据跟踪\r\n      loginStatus: false, \t// 这个属性在视图层用不到, 但是在methods的方法中要用来改变和作为判断条件, 根本不需要加入数据跟踪\r\n    }\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<p>但是改写成这样以后, 不需要跟踪的就不会跟踪了, 但是这样会有什么问题吗? 目前不知道如何去验证</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">export default {\r\n  data () {\r\n    this.loginStatus = false // 这样这个属性就不会加上数据跟踪, 但是下面的方法还可以 this.loginStatus 的去使用\r\n    return {\r\n      title: &#39;xxx&#39; \t\t\t// 这个属性需要在视图层用到, 需要加上数据跟踪\r\n    }\r\n  }\r\n}</code>\n        </deckgo-highlight-code>","id":"c0bd48b6-7633-5842-9f43-0463f8d18ac2","parent":{"name":"vue2源码","base":"vue2源码.md","mtime":"2023-03-09T08:10:00.369Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/Vue/vue2源码/"}},"staticQueryHashes":["3957182205"]}