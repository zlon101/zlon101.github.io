{"componentChunkName":"component---src-templates-post-js","path":"/articles/Vue/vue基础概念/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/Vue/vue基础概念/"},"html":"<blockquote>\n<ul>\n<li>什么是字符串模板：单文件中的template 和 实例化vue对象时的template 属性。</li>\n<li>DOM 模板：在 html 文件中编写的html标签(包含自定义标签)，直接在DOM中使用组件。</li>\n<li>html 属性名和属性值</li>\n</ul>\n</blockquote>\n<ul>\n<li>vue 实例属性：<code>data、computed、methods、props</code> 中的属性都挂载到 vue 实例的一级属性上。</li>\n<li><code>computed</code> 可以依赖多个vue 实例属性，并根据依赖进行缓存。</li>\n<li>指令：指令可以带参数和修饰符，指令绑定的表达式。指令的值是多少？</li>\n<li>Vue 推荐在绝大多数情况下使用<strong>模板</strong>来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用<strong>渲染函数</strong>，它比模板更接近编译器。</li>\n<li>Vue 的模板实际上被编译成了渲染函数</li>\n</ul>\n<h1>组件</h1>\n<blockquote>\n<p>组件是可复用的 Vue 实例</p>\n<p>根实例特有选项: el</p>\n</blockquote>\n<p>创建组件的方式有哪些？</p>\n<ul>\n<li>使用 Vue.component 或 Vue.extend 定义组件</li>\n<li>\n<p>全局注册</p>\n<deckgo-highlight-code language=\"vue\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">Vue.component(&#39;my-component-name&#39;, {\n// ... options ...\n})</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>函数式组件和类组件：函数式组件只是函数，所以渲染开销也低很多</p>\n<p>vue-class-component 和 vue-property-decorator</p>\n<p>vm 表示实例，h 表示 createElement</p>\n<p>组件的选项对象</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">var app = new Vue({\n  el: &#39;#app&#39;,\n  data: {\n    message: &#39;Hello Vue!&#39;\n  }\n})</code>\n        </deckgo-highlight-code>\n<p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。</p>\n<p>// 定义一个名为 button-counter 的新组件</p>\n<p>// 全局注册：全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生</p>\n<p>html 的属性名不区分大小写，都是小写</p>\n<p>html 属性值只能是字符串？</p>\n<deckgo-highlight-code language=\"vue\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">Vue.component(&#39;button-counter&#39;, {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  props: [&#39;title&#39;],\n  template: &lt;button v-on:click=&quot;count++&quot;&gt;You clicked me {{ count }} times.&lt;/button&gt;\n})\n// ***********************************************************\nprops: [&#39;initialCounter&#39;],\ndata(){\n  return {\n    counter: this.initialCounter\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2><a href=\"https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6\">动态组件</a></h2>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;tbody is=&quot;my-cmp&quot;&gt;&lt;/tbody&gt;</code>\n        </deckgo-highlight-code>\n<p><code>tbody</code> 在渲染时被替换为<code>my-cmp</code> 组件</p>\n<p>$emit ==> $event</p>\n<p>自定义事件(非click)</p>\n<ul>\n<li>$emit：触发一个事件</li>\n<li>$event：</li>\n</ul>\n<hr>\n<h1>vue组件三大核心概念</h1>\n<img src=\"assets/vue%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/vue%E7%BB%84%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.jpeg\" alt=\"vue组件核心概念\" style=\"zoom: 67%;\" />    \n<ul>\n<li>\n<p>原生组件(也叫 HTML 元素)的构成：<code>&#x3C;div id='app' style='width:70%'>内容&#x3C;/div></code>，开始标签、内容、结束标签、属性(特性)、属性值；自定义组件也由这些部分构成。</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;!--使用自定义组件--&gt;\n&lt;my-component name=&#39;czl&#39;&gt;\n  &lt;!-- 此处为组件内容，通过slot插槽传递 --&gt;\n  &lt;p&gt;&lt;/p&gt;\n  &lt;div&gt;&lt;/div&gt;\n&lt;/my-component&gt;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>一个 Vue 应用由一个通过 new Vue 创建的<strong>根 Vue 实例</strong>，以及可选组件树组成；</li>\n<li>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 <strong>Vue 实例</strong>，每个组件都会各自独立维护它的 data对象。因为你每用一次组件，就会有一个它的新<strong>实例</strong>被创建，所以data对象是通过函数返回；</li>\n<li>在组件上使用<strong>v-for</strong>时，<strong>key</strong> 是必须提供的；</li>\n<li><strong>组件有自己独立的作用域，</strong>数据不会传递到组件内 ，因此使用<strong>props</strong>向组件内部传递数据； </li>\n<li>不要在选项属性或回调上使用箭头函数；</li>\n<li>Vue 将模板编译成虚拟 DOM 渲染函数；</li>\n</ul>\n</blockquote>\n<p>Vue最核心的功能：数据的双向绑定，实时同步数据，数据驱动DOM。</p>\n<ul>\n<li>\n<p>Q:数据双向绑定是哪两方数据?    </p>\n<ul>\n<li>A:HTML元素数据(表单元素)--Vue实例中的data将元素的属性与属性值分离，其值存放在Vue实例中；用v-model、v-bind将元素属性与其属性值相互绑定。</li>\n</ul>\n</li>\n<li>Vue创建的实例代理了data和method属性，所以可以直接通过实例（this.**）访问；</li>\n<li>实例属性与方法用$开头来访问，如vueApp.$el可以访问元素；</li>\n</ul>\n<h2>Vue构成</h2>\n<ol>\n<li>组件化</li>\n<li>数据驱动 &#x26; 状态管理(vuex)</li>\n<li>指令</li>\n</ol>\n<h2>计算属性 &#x26; watch</h2>\n<ol>\n<li>计算属性只能执行同步代码，计算属性根据响应式依赖进行缓存，当依赖的数据没有更新时，多次访问计算属性直接取缓存的值；</li>\n<li>watch 可以执行异步操作；</li>\n</ol>\n<h2>1. 属性</h2>\n<p><strong>1.1 分类</strong></p>\n<ul>\n<li>自定义属性props</li>\n<li>原生属性attrs</li>\n<li>插槽props</li>\n<li>特殊属性class、style</li>\n</ul>\n<p>data与props的区别？</p>\n<p>单向数据流？</p>\n<h3>Vue为什么禁止修改父组件传递进来的props， 又是如何监控到子组件修改了props?</h3>\n<ul>\n<li>因为Vue遵循单向数据流，模型(比如props数据)渲染视图，如果允许子组件修改父组件传递的值，那么同一父组件的其他子组件就会受影响，导致数据流向很混乱，所以禁止子组件修改props。可以通过父组件传递一个回调函数实现。Vue通过 <code>defineProperty</code>  定义属性的属性描述符中的<code>get</code>和<code>set</code>，当修改属性时判断是否是父组件触发的修改。</li>\n</ul>\n<h3>组件内部修改 props 的方法</h3>\n<ol>\n<li>拷贝至 data 或 计算属性，结合 emit 实现父组件更新；</li>\n<li><code>sync</code> 修饰符；</li>\n<li>将 props 包装为对象，因为 props 传递是引用；</li>\n</ol>\n<h2>2. 事件</h2>\n<ul>\n<li>事件驱动 &#x26; 数据驱动</li>\n<li>普通事件 &#x26; 修饰符事件</li>\n</ul>\n<p>在自定义组件上注册监听原生事件(如click)，使用 native 事件修饰符 <code>&#x3C;my-componenet @click.native=\"handle\">&#x3C;/my-component></code>；因为 my-component 不在DOM树上，添加的是组件内模板的代码(组件模板默认会继承非props特性)，如果没有 native 修饰，则原生的监听器(click)没有作用；注意自定义事件this.$emit不需要native修饰。</p>\n<h2>3. 插槽</h2>\n<ul>\n<li>普通插槽</li>\n<li>作用域插槽</li>\n</ul>\n<p>参考链接: <a href=\"https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&#x26;mid=2247483942&#x26;idx=1&#x26;sn=bb123cb4d34f94f79881f0fa226da26b&#x26;chksm=c06683b0f7110aa6baf6e8ab59870a10fbf9a07083910054a25e67e50d306985103570d88ca2&#x26;mpshare=1&#x26;scene=1&#x26;srcid=&#x26;key=3e64675c4af2e8c1cb87133eea4dc87d7279f068d389ab5644397f9f2d0c1e1cd7e62cc0d356a7eed5b35b508b65ab0ee65bab9587ba98854bfbffa1c964800fab1fc979d082faa5ab76ece9c4c63431&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060739&#x26;lang=zh_CN&#x26;pass_ticket=S8Ujki2fz5qcjOi%2B1GEFSYgOxjQ%2BmiRmgp17ybRU2kbGBIyFXc%2FGjUjxA3p23gkD\">详解vue组件三大核心概念</a></p>\n<h1>组件构成</h1>\n<h2>props</h2>\n<blockquote>\n<p><code>props</code>  的 key &#x26; value，类型、默认值、验证</p>\n</blockquote>\n<ul>\n<li>props属性：定义组件时，在组件实例的props选项上声明的属性；可以通过<code>this.$props</code>获取该属性，直接使用<code>v-bind=$props</code>在<code>&#x3C;template></code>中的元素上进行绑定。</li>\n<li>\n<p>非props属性：使用组件时，定义了未在props选项上声明的属性；<code>$attrs</code> 可以访问非 <code>props</code> 属性。默认情况下，所有的非props属性被组件&#x3C;template>的根元素继承；通过<code>inheritAttrs</code>设置根元素是否继承非<code>props</code>属性</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;my-component name=&quot;czl&quot; age=&quot;22&quot;&gt;&lt;/my-component&gt;\n局部注册\nnew Vue({\nel:&quot;#app&quot;,\ncomponents:{\n    myComponent:{\n        inheritAttrs:false,\t默认为true            \n        template: &#39;&lt;div id=&quot;root&quot;&gt;&lt;input v-bind=$attrs&gt;&lt;/div&gt;&#39;\n    }\n}\n})</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>无参bind</h2>\n<ul>\n<li>v-bind:参数='表达式'</li>\n<li>\n<p>使用无参的bind指令可以一次动态绑定多个值，等价于将属性名作为参数</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;MyCom v-bind=&quot;obj&quot;/&gt;\nobj: {\n\tname: &#39;czl&#39;,\n\tage: 22\n} \n// 等价于 &lt;MyCom v-bind:name=&quot;obj.name&quot; :age=&quot;obj.age&quot;&gt;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>slot</h2>\n<ul>\n<li>slot：分发<strong>内容</strong>(元素由开始标签、结束标签和<strong>内容</strong>构成)，当有多个内容需要分发时，通过指定slot.name即具名slot实现。</li>\n<li>插槽prop: 绑定在<code>&#x3C;slot></code>上的特性</li>\n</ul>\n<h2>watch监听引用数据</h2>\n<ul>\n<li>\n<p>监听复杂数据(object、array)</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">watch: {\nobj: {\n      deep: true,\n      handle: function(newValue, oldValue){\n           ...\n      }        \n  }\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>keep-alive</h2>\n<ul>\n<li>\n<p>将组件&#x3C;my-component>进行缓存，避免每次重新渲染组件(create, mounte等)，用于路由及组件切换(动态组件&#x3C;component v-bind:is=\"cmp\">)。</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;keep-alive&gt;\n &lt;my-component&gt;&lt;/my-component&gt;\n&lt;/keep-alive&gt;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>native</h2>\n<ul>\n<li>\n<p>若没有修饰符native，那下面的@click就是自定义事件click而非原生click</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;mycomponent @click.native=&#39;handleClick&#39;&gt;&lt;/mycomponent&gt;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h1>key</h1>\n<p>vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：</p>\n<ol>\n<li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。</li>\n<li>同一层级的一组节点，他们可以通过唯一的id进行区分。</li>\n</ol>\n<p>基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。</p>\n<ul>\n<li><code>key</code> 的作用是给予一个节点唯一的身份识别，有相同父元素的子元素必须有独特的 <code>key</code>，特别是列表渲染时的节点，因为相同的组件产生类似的DOM结构 。这样在使用Diff算法对新旧虚拟DOM进行比较时，计算出哪些节点是可以<strong>就地复用或者调整顺序</strong>，可以更高效的重用排序现有的元素；比较时，依次对比两个节点的类型、属性、子节点。</li>\n<li>key的作用主要是为了高效的更新虚拟DOM。</li>\n</ul>\n<h1>组件通信</h1>\n<ol>\n<li>props &#x26; emit：自定义属性和自定义事件</li>\n<li>$refs、$parent、$children</li>\n<li>provide &#x26; inject</li>\n<li>$attrs &#x26; $listeners</li>\n<li>Event Bus</li>\n<li>vuex</li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&#x26;mid=2650215866&#x26;idx=1&#x26;sn=c4cc189d145d5c358db61697ca70a82e&#x26;chksm=befe159b89899c8d4ae785b5f63063434dc1279830c020d8b60985e8e6a36a2e55f93a2ac6d4&#x26;scene=0&#x26;key=2bb12b254a1b99044f1b54db34647d49c8c06f37b302512cea302a011df276cdf11973e6bbdd41b9ebfa174ff119d5b271bd567f7bbc5eb6a01718c24400c75602ee6810ea48253930f85fd15310ff25&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060739&#x26;lang=zh_CN&#x26;pass_ticket=Ssclv0EjFV5vOJWuvp4F%2F2EaOid5lYknyYjfJDT8vOG1egweHVyv%2ByaE%2BGO8rIc8\">SegmentFault参考</a></li>\n</ol>\n<h1>Virtual DOM</h1>\n<h2>Diff 算法</h2>\n<p>Diff 算法将时间复杂度从O(n3)减少到O(n)；</p>\n<p>diff 算法包括几个步骤：</p>\n<ol>\n<li>用 JS 对象表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中；</li>\n<li>当状态变更的时候，重新构造一棵新的对象树，然后用新的树和旧的树进行比较(同层比较)，记录两棵树差异；</li>\n<li>把所记录的差异应用到所构建的真正的DOM树上，视图就更新了；</li>\n</ol>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&#x26;mid=2247484031&#x26;idx=1&#x26;sn=ece0d952f7192b3d408da5fc68a880a4&#x26;chksm=c06683e9f7110aff8b0b9f0cbbd5de34754c28c1176189964564ed5cd28a459e6f9e09be54d5&#x26;mpshare=1&#x26;scene=1&#x26;srcid=&#x26;key=3e64675c4af2e8c1434a938098a616e5abdb665d9e84903be474c86d977e282af3b8878d3952b0c28b6c2d63d63a00ed7195b0d74798baf1d7c34bd3d2ead3a110f204c293a0583dab0b48772f18fb87&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060833&#x26;lang=zh_CN&#x26;pass_ticket=WoiLyjX22pgkcex3J0Zr4C7XhoDMUgwrJ0I8gXuNREhi9k%2F0J3OO2IhX87FJPVXU\">揭秘Vue中的Virtual Dom</a></li>\n</ul>\n<h1>render &#x26; JSX &#x26; 函数组件</h1>\n<p>如何描述组件的UI和状态信息？</p>\n<ol>\n<li>字符串模板</li>\n<li><strong><code>&#x3C;template></code></strong></li>\n<li>render 函数</li>\n</ol>\n<p>这三中方法的作用都是一样的(可以相互替换)</p>\n<h2>1.render</h2>\n<p><u>render 函数</u></p>\n<ul>\n<li>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">new Vue({\nrender(h){\n  h(&#39;p&#39;, 子节点);\n  // h 即 createElemnet\n}\n})</code>\n        </deckgo-highlight-code>\n</li>\n<li></li>\n</ul>\n<p><a href=\"https://cn.vuejs.org/v2/api/#render\">Vue官网API</a></p>\n<ul>\n<li><strong>createElement</strong> 的返回值是什么?\ncreateElement的返回的不是一个实际的  DOM 元素。它更准确的名字可能是 <code>createNodeDescription</code>，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“<strong>VNode</strong>”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</li>\n</ul>\n<p><a href=\"#\">render 和 template 的关联</a></p>\n<ul>\n<li>template 模板的来源？\n当 Vue 选项对象中有 render 渲染函数时，Vue 构造函数将直接使用渲染函数渲染 DOM 树，当选项对象中没有 render 渲染函数时，Vue 构造函数首先通过将 template 模板编译生成渲染函数，然后再渲染 DOM 树，而当 Vue 选项对象中既没有 render 渲染函数，也没有 template 模板时，会通过 el 属性获取挂载元素的 outerHTML 来作为模板，并编译生成渲染函数。</li>\n</ul>\n<h2>2.函数式组件</h2>\n<p>特点：</p>\n<ol>\n<li>声明了functional: true; </li>\n<li>render(h, context);     // 由第二个参数提供状态数据, h-->createElement</li>\n</ol>\n<h2>3.JSX</h2>\n<p><strong>JSX只是JS的语法扩展，在JS文件中使用。</strong></p>\n<p><strong>插件</strong>：@vue/babel-preset-jsx @vue/babel-helper-vue-jsx-merge-props</p>\n<p><a href=\"https://github.com/vuejs/jsx#installation\">https://github.com/vuejs/jsx#installation</a></p>\n<p><strong>Demo：</strong></p>\n<ul>\n<li>\n<p>render(h, ctx)中第一个参数在某些版本下只能用名称h，详细见<strong><a href=\"%5Bhttps://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%5D(https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6)\">Vue-函数式组件</a></strong></p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;template&gt;\n\t&lt;VNode :vnodes=&quot;getJSXSpan()&quot; info=&quot;info&quot;/&gt;&lt;hr&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\ncomponents: {    \n  // 函数组件\n  VNode: {\n      functional: true,\n      \n      // 第一种使用方法\n      render: (h, ctx) =&gt; {\n          return h(&#39;div&#39;, {\n              style: {\n                  color: &#39;blue&#39;\n              },\n              attrs: {\n                  id: &quot;funCom&quot;\n              }\n          }, [ctx.props.vnodes])\n      }\n      \n      // 第二种使用方法\n      render: (h, ctx) =&gt; ctx.props.vnodes\n      \n      // 第三种使用方法\n      render: (h, ctx) =&gt; {            \n          let {type, info} = ctx.props;\n          // return h(type, ctx.data, ctx.children);\n\n          return FC();\n          \n          function FC(){\n              info = info || &#39;未定义&#39;;\n              return (\n                  &lt;type class=&quot;func-comp&quot; {...ctx.data}&gt;\n                      &lt;span&gt;{ ctx.children }&lt;/span&gt;\n                  &lt;/type&gt;\n              )                \n          }\n      }\n  }\n},\n\nmethods: {\n  getJSXSpan() {\n  \treturn &lt;span&gt;Message: {this.msg}&lt;/span&gt;;\n  },\n}\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>参考</h2>\n<h3><a href=\"https://zhuanlan.zhihu.com/p/25486761\">render 函数与模板编译：运行时构建 &#x26; 独立构建</a></h3>\n<hr>\n<p>当使用 <code>vue-loader</code> 或 <code>vueify</code> 的时候，<code>*.vue</code> 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。</p>\n<h1>vue实例</h1>\n<p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的属性加入到 Vue 的<strong>响应式系统</strong>中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的属性才是<strong>响应式</strong>的。也就是说如果你添加一个新的属性，</p>\n<h2>模板</h2>\n<ul>\n<li>\n<p>绑定的数据对象不必内联定义在模板里</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n</li>\n<li>注意这里的 <code>is=\"todo-item\"</code> 属性。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>&#x3C;ul></code> 元素内只有 <code>&#x3C;li></code> 元素会被看作有效内容。这样做实现的效果与 <code>&#x3C;todo-item></code> 相同，但是可以避开一些潜在的浏览器解析错误。查看 <a href=\"https://cn.vuejs.org/v2/guide/components.html#%E8%A7%A3%E6%9E%90-DOM-%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">DOM 模板解析说明</a> 来了解更多信息。</li>\n</ul>\n<p>需要注意的是<strong>如果我们从以下来源使用模板的话，这条限制是不存在的</strong>：</p>\n<ul>\n<li>字符串 (例如：<code>template: '...'</code>)</li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/single-file-components.html\">单文件组件 (<code>.vue</code>)</a>  </li>\n<li>\n<script type=\"text/x-template\">\n</li>\n</ul>\n<p>当直接在 DOM 中使用一个组件 (而不是在字符串模板或<a href=\"https://cn.vuejs.org/v2/guide/single-file-components.html\">单文件组件</a>) 的时候，我们强烈推荐遵循 <a href=\"https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\">W3C 规范</a>中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。</p>\n<ul>\n<li>不要在选项属性或回调上使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a>，比如 <code>created: () => console.log(this.a)</code> 或 <code>vm.$watch('a', newValue => this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止；</li>\n<li>\n<p>计算属性：基于响应式依赖进行缓存，当依赖的数据没有更新时，不会执行函数；\n计算属性默认只有getter</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">computed: {\nfullName: {\n  // getter\n  get: function () {\n    return this.firstName + &#39; &#39; + this.lastName\n  },\n  // setter\n  set: function (newValue) {\n    var names = newValue.split(&#39; &#39;)\n    this.firstName = names[0]\n    this.lastName = names[names.length - 1]\n  }\n}\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h1>vue 响应式原理</h1>\n<img src=\"assets/vue%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9B%B4%E6%96%B0.png\" alt=\"vue响应式更新\" style=\"zoom: 50%;\" />   \n<p>创建一个vue 实例时，vue 遍历data 对象的属性，并使用 defineProperty 将属性转换为 getter\\setter (vue3.0 使用 Proxy)，当属性被访问或修改时触发更新(使用了发布订阅模式)。</p>\n<p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>\n<h2>异步更新队列</h2>\n<blockquote>\n<p><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97\">vue官网</a></p>\n</blockquote>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html\">深入响应式原理-vue官网</a></li>\n</ul>","id":"ac2f3d5d-4851-517d-bdb2-db9d4bd4fd95","parent":{"__typename":"File","name":"vue基础概念","base":"vue基础概念.md","mtime":"2022-09-03T14:08:55.949Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/Vue/vue基础概念/"}},"staticQueryHashes":["3957182205"]}