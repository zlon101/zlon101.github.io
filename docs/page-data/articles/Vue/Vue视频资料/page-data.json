{"componentChunkName":"component---src-templates-post-js","path":"/articles/Vue/Vue视频资料/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/Vue/Vue视频资料/"},"html":"<h3>v-for中key的作用</h3>\n<p>大家要知道，不仅只是vue中，react中在执行列表渲染时也会要求给每个组件添加key这个属性</p>\n<p>如果想知道key的作用，不得我们得聊一下虚拟DOM的Diff算法</p>\n<p>所谓虚拟DOM的诞生，使我们可以不直接操作DOM元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的Diff算法，它的核心是基于两个简单的假设：</p>\n<ol>\n<li>\n<h6>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构</h6>\n</li>\n<li>\n<h6>同一个层级的一组节点，他们可以通过唯一的id进行区分</h6>\n</li>\n</ol>\n<p>下面这张图是react的Diff示意图：</p>\n<p><img src=\"/var/folders/7b/sz6pt5jd3y3b51q1ngm_8pph0000gn/T/abnerworks.Typora/image-20180820211848710.png\" alt=\"image-20180820211848710\"></p>\n<p>由此图我们可以看出：</p>\n<p>当页面的数据发生变化时，Diff算法只会比较同一层级的节点：</p>\n<h6>如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了</h6>\n<h6>如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新</h6>\n<p>当某一层有很多相同的界定啊时，也就是列表节点，Diff算法的更新过程默认情况下也是遵循以上原则</p>\n<p>比如下面这个情况</p>\n<p><img src=\"/var/folders/7b/sz6pt5jd3y3b51q1ngm_8pph0000gn/T/abnerworks.Typora/image-20180820212221368.png\" alt=\"image-20180820212221368\"></p>\n<p>我们希望可以在B和C之间加一个F,Diff算法默认 执行起来是这样的：</p>\n<p><img src=\"/var/folders/7b/sz6pt5jd3y3b51q1ngm_8pph0000gn/T/abnerworks.Typora/image-20180820212311533.png\" alt=\"image-20180820212311533\"></p>\n<p>既把C更新成F,D更新成C,E更新成D,最后再插入E,是不是很没有效率？</p>\n<p>所有我们<strong><em>需要使用key来给每个节点做一个唯一的标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点</em></strong></p>\n<p><img src=\"/var/folders/7b/sz6pt5jd3y3b51q1ngm_8pph0000gn/T/abnerworks.Typora/image-20180820212507408.png\" alt=\"image-20180820212507408\"></p>\n<p>所以一句话，<strong><em>key的作用主要是为了高效的更新虚拟DOM</em></strong>。另外vue的在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分他们，否则vue只会替换其内部属性而不会触发过渡效果。</p>\n<h3>$emit和$on进行组件之间的传值</h3>\n<blockquote>\n<p>注意：$emit和$on的事件必须在一个公共的实例上，才能够触发</p>\n</blockquote>\n<p>需求：</p>\n<p>​\t1.有A，B，C三个组件，同时挂载到入口组件中</p>\n<p>​\t2.将A组件中的数据传递到C组件，再将B组件中的数据传递到C组件</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot; /&gt;\n  &lt;title&gt;Vue2-单一事件管理组件通信&lt;/title&gt;\n\n  \n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;dom-a&gt;&lt;/dom-a&gt;\n    &lt;dom-b&gt;&lt;/dom-b&gt;\n    &lt;dom-c&gt;&lt;/dom-c&gt;   \n  &lt;/div&gt;\n  &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    \n\n  //准备一个空的实例对象\n  var Event = new Vue();\n  console.log(Event);\n \n  //组件A\n  var A = {\n    template: `\n      &lt;div&gt;\n        &lt;span&gt;我是A组件的数据-&gt;{{a}}&lt;/span&gt;\n        &lt;input type=&quot;button&quot; value=&quot;把A数据传给C&quot; @click = &quot;send&quot;&gt;\n      &lt;/div&gt;\n    `,\n    methods: {\n      send () {\n        alert(1);\n        console.log(this);\n        Event.$emit(&quot;a-msg&quot;, this.a);\n      }\n    },\n    data () {\n      return {\n        a: &quot;我是a组件中数据&quot;\n      }\n    }\n  };\n  //组件B\n  var B = {\n    template: `\n      &lt;div&gt;\n        &lt;span&gt;我是B组件的数据-&gt;{{a}}&lt;/span&gt;\n        &lt;input type=&quot;button&quot; value=&quot;把B数据传给C&quot; @click = &quot;send&quot;&gt;\n      &lt;/div&gt;\n    `,\n    methods: {\n      send () {\n        Event.$emit(&quot;b-msg&quot;, this.a);\n      }\n    },\n    data () {\n      return {\n        a: &quot;我是b组件中数据&quot;\n      }\n    }\n  };\n  //组件C\n  var C = {\n    template: `\n      &lt;div&gt;\n        &lt;h3&gt;我是C组件&lt;/h3&gt;\n        &lt;span&gt;接收过来A的数据为: {{a}}&lt;/span&gt;\n        &lt;br&gt;\n        &lt;span&gt;接收过来B的数据为: {{b}}&lt;/span&gt;\n      &lt;/div&gt;\n    `,\n    mounted () {\n      alert(2);\n      //接收A组件的数据\n      Event.$on(&quot;a-msg&quot;, (a)=&gt; {\n        this.a = a;\n      });\n \n      //接收B组件的数据\n      Event.$on(&quot;b-msg&quot;,  (b)=&gt; {\n        this.b = b;\n      });\n    },\n    data () {\n      return {\n        a: &quot;&quot;,\n        b: &quot;&quot;\n      }\n    }\n  };\n\n    new Vue({\n      el: &quot;#app&quot;,\n      components: {\n         &#39;dom-a&#39;:A,\n         &#39;dom-b&#39;:B,\n         &#39;dom-c&#39;:C\n      }\n    });\n  &lt;/script&gt;\n \n&lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<h3>vue-router的导航守卫之在导航完成后获取数据</h3>\n<p>需求：在导航完成之后加载数据。渲染DOM</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n\t&lt;meta charset=&quot;UTF-8&quot;&gt;\n\t&lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\t&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n\t&lt;script type=&quot;text/javascript&quot; src=&quot;vue.js&quot;&gt;&lt;/script&gt;\n\t&lt;script type=&quot;text/javascript&quot; src=&quot;vue-router.js&quot;&gt;&lt;/script&gt;\n\t&lt;script type=&quot;text/javascript&quot; src=&quot;axios.js&quot;&gt;&lt;/script&gt;\n\t&lt;script type=&quot;text/javascript&quot;&gt;\n\n\t\t// 导航完成后获取数据，这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。\n\t\tvar Index = {\n\t\t\ttemplate:`\n\t\t\t\t&lt;div&gt;我是首页&lt;/div&gt;\n\t\t\t`\n\t\t};\n\n\t\tvar Post = {\n\t\t\tdata(){\n\t\t\t\treturn {\n\t\t\t\t\tloading:false,\n\t\t\t\t\terror:null,\n\t\t\t\t\tpost:null\n\t\t\t\t}\n\t\t\t},\n\t\t\ttemplate:`\n\t\t\t\t&lt;div&gt;\n\t\t\t\t\t&lt;div class = &#39;loading&#39; v-if = &#39;loading&#39;&gt;\n\t\t\t\t\t\tloading.....\n\t\t\t\t\t&lt;/div&gt;\n\t\t\t\t\t&lt;div v-if=&quot;error&quot; class = &#39;error&#39;&gt;\n\t\t\t\t\t\t{{error}}\n\t\t\t\t\t&lt;/div&gt;\n\t\t\t\t\t&lt;div class = &#39;content&#39; v-if = &#39;post&#39;&gt;\n\t\t\t\t\t\t&lt;h2&gt;{{post.title}}&lt;/h2&gt;\n\t\t\t\t\t\t&lt;p&gt;{{post.body}}&lt;/p&gt;\n\t\t\t\t\t&lt;/div&gt;\n\t\t\t\t&lt;/div&gt;\n\t\t\t`,\n\t\t\tcreated(){\n\t\t\t\t// 组件创建完成后获取数据\n\t\t\t\t// 此时data已经被监听了\n\t\t\t\tthis.fetchData();\n\n\t\t\t},\n\t\t\twatch:{\n\t\t\t\t&#39;$route&#39;:&#39;fetchData&#39;\n\t\t\t},\n\t\t\tmethods:{\n\t\t\t\tfetchData(){\n\t\t\t\t\tthis.error = null;\n\t\t\t\t\tthis.post = null;\n\t\t\t\t\tthis.loading = true;\n\t\t\t\t\tthis.$axios.get(&#39;http://127.0.0.1:8888/post&#39;)\n\t\t\t\t\t.then(res=&gt;{\n\t\t\t\t\t\tthis.loading = false;\n\t\t\t\t\t\tconsole.log(res.data);\n\t\t\t\t\t\tthis.post = res.data;\n\t\t\t\t\t})\n\t\t\t\t\t.catch(err=&gt;{\n\t\t\t\t\t\tthis.err = err.toString();\n\t\t\t\t\t})\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar router = new VueRouter({\n\t\t\troutes:[\n\t\t\t\t{\n\t\t\t\t\tpath:&#39;/index&#39;,\n\t\t\t\t\tname:&#39;index&#39;,\n\t\t\t\t\tcomponent:Index\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpath:&#39;/post&#39;,\n\t\t\t\t\tname:&#39;post&#39;,\n\t\t\t\t\tcomponent:Post\n\t\t\t\t}\n\t\t\t]\n\t\t});\n\n\t\tvar App = {\n\t\t\ttemplate:`\n\t\t\t\t&lt;div&gt;\n\t\t\t\t\t&lt;router-link :to = &quot;{name:&#39;index&#39;}&quot;&gt;首页&lt;/router-link&gt;\n\t\t\t\t\t&lt;router-link :to = &quot;{name:&#39;post&#39;}&quot;&gt;我的博客&lt;/router-link&gt;\n\n\t\t\t\t\t\t&lt;router-view&gt;&lt;/router-view&gt;\n\n\n\t\t\t\t&lt;/div&gt;\n\t\t\t`\n\t\t};\n\t\tVue.prototype.$axios  = axios;\n\t\tnew Vue({\n\t\t\tel:&quot;#app&quot;,\n\t\t\tdata:{\n\n\t\t\t},\n\n\t\t\tcomponents:{\n\t\t\t\tApp\n\t\t\t},\n\t\t\ttemplate:`&lt;App /&gt;`,\n\t\t\trouter\n\t\t});\n\t&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<h3>vue-router的导航守卫之导航完成之前获取数据</h3>\n<p>需求：在导航完成之前获取数据，之后再渲染DOM</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;vue.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;vue-router.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;axios.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n    // 导航完成后获取数据，这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。\n\n    var vm = null;\n    var User = {\n        data() {\n            return {\n                error: null,\n                user: &#39;&#39;\n            }\n        },\n        template: `\n\t\t\t\t&lt;div&gt;\n\t\t\t\t\t&lt;div v-if=&quot;error&quot; class = &#39;error&#39;&gt;\n\t\t\t\t\t\t{{error}}\n\t\t\t\t\t&lt;/div&gt;\n\t\t\t\t\t&lt;div class = &#39;user&#39; v-if = &#39;user&#39;&gt;\n\t\t\t\t\t\t&lt;h2&gt;{{user}}&lt;/h2&gt;\n\t\t\t\t\t&lt;/div&gt;\n\t\t\t\t&lt;/div&gt;\n\t\t\t`,\n        beforeRouteEnter(to, from, next) {\n            // 在渲染该组件的对应路由被 confirm 前调用\n            // 不！能！获取组件实例 `this`\n            // 因为当守卫执行前，组件实例还没被创建\n\n\n            console.log(to);\n            axios.get(`http://127.0.0.1:8888/user/${to.params.id}`)\n                .then(res =&gt; {\n\n                    next(vm =&gt; vm.setData(res.data))\n\n                })\n                .catch(err =&gt; {\n                    console.log(err);\n                    next(vm =&gt; vm.setError(err));\n                })\n        },\n        beforeRouteUpdate(to, from, next) {\n        \t // 在当前路由改变，但是该组件被复用时调用\n\t    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n\t    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n\t    // 可以访问组件实例 `this`\n\n            this.user = null;\n            this.$axios.get(`http://127.0.0.1:8888/user/${to.params.id}`)\n                .then(res =&gt; {\n                    this.setData(res.data);\n                    next();\n                })\n                .catch(err =&gt; {\n                 \t   this.setError(err);\n                    next();\n                })\n\n\n\n        },\n        methods: {\n            setData(user) {\n                this.$nextTick(() =&gt; {\n                    this.user = user;\n                })\n            },\n            setError(err) {\n                this.err = err.toString();\n\n            }\n\n        }\n\n    }\n\n    var router = new VueRouter({\n        routes: [{\n            path: &#39;/user/:id&#39;,\n            name: &#39;user&#39;,\n            component: User,\n\n        }]\n    });\n\n    var App = {\n        template: `\n\t\t\t\t&lt;div&gt;\n\t\t\t\t\t\n\t\t\t\t\t&lt;router-link :to = &quot;{name:&#39;user&#39;,params:{id:1}}&quot;&gt;我的用户1&lt;/router-link&gt;\n\t\t\t\t\t&lt;router-link :to = &quot;{name:&#39;user&#39;,params:{id:2}}&quot;&gt;我的用户2&lt;/router-link&gt;\n\n\t\t\t\t\t\t&lt;router-view&gt;&lt;/router-view&gt;\n\n\n\t\t\t\t&lt;/div&gt;\n\t\t\t`\n    };\n    Vue.prototype.$axios = axios;\n    vm = new Vue({\n        el: &quot;#app&quot;,\n        data: {\n\n        },\n\n        components: {\n            App\n        },\n        template: `&lt;App /&gt;`,\n        router\n    });\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<h3>vue-cli2.x脚手架的使用</h3>\n<p>参考链接：<a href=\"https://github.com/vuejs/vue-cli/tree/v2#vue-cli--\">https://github.com/vuejs/vue-cli/tree/v2#vue-cli--</a></p>\n<p>安装：</p>\n<deckgo-highlight-code language=\"jade\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">npm install -g vue-cli</code>\n        </deckgo-highlight-code>\n<p>用法：</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">$ vue init &lt; template-name &gt;  &lt; project-name &gt;</code>\n        </deckgo-highlight-code>\n<p>例：</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">$ vue init webpack my-project</code>\n        </deckgo-highlight-code>\n<p>目前可用的模块包括：</p>\n<ul>\n<li><a href=\"https://github.com/vuejs-templates/webpack\">webpack</a> - 一个功能齐全的Webpack + vue-loader设置，具有热重载，linting，测试和css提取功能。</li>\n<li><a href=\"https://github.com/vuejs-templates/webpack-simple\">webpack-simple</a> - 一个简单的Webpack + vue-loader设置，用于快速原型设计。</li>\n<li><a href=\"https://github.com/vuejs-templates/browserify\">browserify</a> -全功能Browserify + vueify设置用热重装载，linting＆单元测试。</li>\n<li>browserify <a href=\"https://github.com/vuejs-templates/browserify-simple\">-simple</a> - 一个简单的Browserify + vueify设置，用于快速原型设计。</li>\n<li><a href=\"https://github.com/vuejs-templates/pwa\">pwa</a> - 基于webpack模板的vue-cli的PWA模板</li>\n<li><a href=\"https://github.com/vuejs-templates/simple\">simple</a> - 单个HTML文件中最简单的Vue设置</li>\n</ul>\n<p>相关文件和文件夹的含义：</p>\n<p><img src=\"/var/folders/7b/sz6pt5jd3y3b51q1ngm_8pph0000gn/T/abnerworks.Typora/image-20180822222713459.png\" alt=\"image-20180822222713459\"></p>\n<p><img src=\"/var/folders/7b/sz6pt5jd3y3b51q1ngm_8pph0000gn/T/abnerworks.Typora/image-20180823225043216.png\" alt=\"image-20180823225043216\"></p>\n<h3>vue-cli3x脚手架的使用</h3>\n<p>vue-cli3x的官方文档：<a href=\"https://cli.vuejs.org/\">https://cli.vuejs.org/</a></p>\n<p>Vue-cli3 中vue.config.js文件配置参考文档：<a href=\"https://cli.vuejs.org/zh/config/#integrity\">https://cli.vuejs.org/zh/config/#integrity</a></p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// vue.config.js 配置说明\n//官方vue.config.js 参考文档 https://cli.vuejs.org/zh/config/#css-loaderoptions\nmodule.exports = {\n  // 部署生产环境和开发环境下的URL。\n  // 默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上\n  //例如 https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在  \n  //https://www.my-app.com/my-app/，则设置 baseUrl 为 /my-app/。baseUrl: process.env.NODE_ENV === &quot;production&quot; ? &quot;./&quot; : &quot;/&quot;,\n \n  // outputDir: 在npm run build 或 yarn build 时 ，生成文件的目录名称（要和baseUrl的生产环境路径一致）\n  outputDir: &quot;dist&quot;,\n  //用于放置生成的静态资源 (js、css、img、fonts) 的；（项目打包之后，静态资源会放在这个文件夹下）\n  assetsDir: &quot;assets&quot;,\n    \n  //指定生成的 index.html 的输出路径  (打包之后，改变系统默认的index.html的文件名)\n  // indexPath: &quot;myIndex.html&quot;,\n  //默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。你可以通过将这个选项设为 false 来关闭文件名哈希。  \n  //(false的时候就是让原来的文件名不改变)\n  filenameHashing: false,\n \n  // lintOnSave：{ type:Boolean default:true } 问你是否使用eslint\n  lintOnSave: true,\n  //如果你想要在生产构建时禁用 eslint-loader，你可以用如下配置\n  // lintOnSave: process.env.NODE_ENV !== &#39;production&#39;,\n \n  //是否使用包含运行时编译器的 Vue 构建版本。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。(默认false)\n  // runtimeCompiler: false,\n \n  /**\n   * 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。\n   *  打包之后发现map文件过大，项目文件体积很大，设置为false就可以不输出map文件\n   *  map文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。\n   *  有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。\n   * */\n  productionSourceMap: false,\n \n  // 它支持webPack-dev-server的所有选项\n  devServer: {\n    host: &quot;localhost&quot;,\n    port: 1111, // 端口号\n    https: false, // https:{type:Boolean}\n    open: true, //配置自动启动浏览器\n    // proxy: &#39;http://localhost:4000&#39; // 配置跨域处理,只有一个代理\n \n    // 配置多个代理\n    proxy: {\n      &quot;/api&quot;: {\n        target: &quot;&lt;url&gt;&quot;,\n        ws: true,\n        changeOrigin: true\n      },\n      &quot;/foo&quot;: {\n        target: &quot;&lt;other_url&gt;&quot;\n      }\n    }\n  }\n};</code>\n        </deckgo-highlight-code>\n<h3>RESTful</h3>\n<h5>RESTful 规范</h5>\n<p>　　一种软件的架构风格，设计风格，而不是标准，为客户端和服务端的交互提供一组设计原则和约束条件。</p>\n<h5>一  面向资源编程</h5>\n<p>　　每个URL代表一种资源，URL中尽量不要用动词，要用名词，往往名词跟数据库表格相对应。</p>\n<p>​\t一般来说，数据库中的表都是同种记录的集合，所有API中的名词也应该使用复数。</p>\n<p>​\t举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">https://api.example.com/v1/zoos\nhttps://api.example.com/v1/animals\nhttps://api.example.com/v1/employees</code>\n        </deckgo-highlight-code>\n<h5>二  HTTP动词</h5>\n<p>​\t对于资源的具体操作类型，由HTTP动词表示</p>\n<p>​\t常用的HTTP动词有下面五个(括号里对应的sql命令)</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">GET（SELECT）：从服务器取出资源（一项或多项）。\nPOST（CREATE）：在服务器新建一个资源。\nPUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\nPATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\nDELETE（DELETE）：从服务器删除资源。</code>\n        </deckgo-highlight-code>\n<h5>三  在URL中体现版本</h5>\n<h5>　　<a href=\"https://www.bootcss.com/v1/\">https://www.bootcss.com/v1/</a></h5>\n<p>　　<a href=\"https://v1.bootcss.com/\">https://v1.bootcss.com/</a></p>\n<h5>四  在URL中体现是否是API</h5>\n<p>　　<a href=\"https://www.bootcss.com/api/mycss\">https://www.bootcss.com/api/mycss</a></p>\n<p>　　<a href=\"https://api.bootcss.com/mycss\">https://api.bootcss.com/mycss</a></p>\n<h5>五  在URL中的过滤条件</h5>\n<p>​\t如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">?limit=10：指定返回记录的数量\n?offset=10：指定返回记录的开始位置。\n?page=2&amp;per_page=100：指定第几页，以及每页的记录数。\n?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n?animal_type_id=1：指定筛选条件</code>\n        </deckgo-highlight-code>\n<h5>六  尽量使用HTTPS</h5>\n<p>　　<a href=\"https://www.bootcss.com/v1/mycss\">https://www.bootcss.com/v1/mycss</a></p>\n<h5>七  响应时设置状态码</h5>\n<p>　　1**   信息，服务器收到请求，需要请求者继续执行操作</p>\n<p>　　2**  成功，操作被成功接收并处理</p>\n<p>　　3**  重定向，需要进一步的操作以完成请求</p>\n<p>　　4**  客户端错误，请求包含语法错误或无法完成请求</p>\n<p>　　5**  服务器错误，服务器在处理请求的过程中发生了错误</p>\n<h5>八  返回值</h5>\n<p>　　GET请求 返回查到所有或单条数据</p>\n<p>　　POST请求  返回新增的数据</p>\n<p>　　PUT请求  返回更新数据</p>\n<p>　　PATCH请求  局部更新  返回更新整条数据</p>\n<p>　　DELETE请求  返回值为空</p>\n<h5>九  返回错误信息</h5>\n<p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">{\n    error: &quot;Invalid API key&quot;\n}</code>\n        </deckgo-highlight-code>\n<h5>十   Hypermedia API</h5>\n<p>　　如果遇到需要跳转的情况 携带调转接口的URL</p>\n<p>　Hypermedi API的设计,比如github的API就是这种设计，访问api.github.com会得到一个所有可用的API的网址列表。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}</code>\n        </deckgo-highlight-code>\n<p>从上面可以看到，如果想获取当前用户的信息，应该去访问 api.github.com/user，就会得到下面的记过</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">{\nmessage: &quot;Requires authentication&quot;,\ndocumentation_url: &quot;https://developer.github.com/v3/users/#get-the-authenticated-user&quot;\n}</code>\n        </deckgo-highlight-code>\n<h5>十一 其他</h5>\n<p>（1）API的身份认证应该使用OAuth 2.0框架</p>\n<p>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML</p>","id":"6d933445-3b06-5832-8140-3913cb896fd0","parent":{"__typename":"File","name":"Vue视频资料","base":"Vue视频资料.md","mtime":"2022-03-30T03:05:54.658Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/Vue/Vue视频资料/"}},"staticQueryHashes":["3957182205"]}