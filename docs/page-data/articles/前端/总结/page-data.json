{"componentChunkName":"component---src-templates-post-js","path":"/articles/前端/总结/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/前端/总结/"},"html":"<h4>前端路由</h4>\n<p>前端路由是通过改变URL，在不重新请求页面的情况下，更新页面视图。改变URL且不会重载页面的方式：hash &#x26; H5 history.pushState replaceState</p>\n<blockquote>\n<p>HashHistory</p>\n</blockquote>\n<ul>\n<li>hash虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变hash不会重新加载页面。</li>\n<li>\n<p>可以为hash的改变添加监听事件：</p>\n<p><code>window.addEventListener(\"hashchange\",funcRef,false)</code>  </p>\n</li>\n</ul>\n<blockquote>\n<p>TML5History</p>\n</blockquote>\n<ul>\n<li>pushState和replaceState两种方法的共同特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，重载页面，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。</li>\n<li>用户导航到新的状态，popstate事件就会被触发；</li>\n</ul>\n<h4>长列表(Table)渲染优化</h4>\n<blockquote>\n<p>方案</p>\n<ol>\n<li>\n<p>虚拟列表：固定渲染一定数据的列表项</p>\n<ul>\n<li><a href=\"https://github.com/tangbc/vue-virtual-scroll-list\">vue-virtual-scroll-list 组件</a> </li>\n<li><a href=\"https://github.com/bvaughn/react-virtualized\">react-virtualized</a>  </li>\n</ul>\n</li>\n<li>懒加载</li>\n</ol>\n</blockquote>\n<h4><a href=\"https://juejin.cn/post/6844903885505576968\">时区与JS中的Date</a></h4>\n<h4>拖拽</h4>\n<ul>\n<li><a href=\"https://juejin.im/post/6844903940706795533\">使用原生 JavaScript 实现拖放功能 - 掘金</a>\n<a href=\"https://mp.weixin.qq.com/s/4WLbV46MsDzlNWzzDep3Pw\">原生JS快速实现拖放实例效果与解析</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API\">HTML 拖放 API-| MDN</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations\">拖拽操作 - MDN</a> </li>\n<li>\n<p>拖拽元素</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function makeElMavable(el: HTMLElement) {\nfunction getStyleVal(xy: &#39;x&#39; | &#39;y&#39;) {\n  const s = xy === &#39;x&#39; ? el.style.left : el.style.top;\n  const v = parseInt(s.replace(/\\D/, &#39;&#39;));\n  return v || 0;\n}\n\nlet startX = 0;\nlet startY = 0;\nlet touchStartX = 0;\nlet touchStartY = 0;\n\nconst docMoveListener = (evt: TouchEvent) =&gt; {\n  const tch = evt.touches[0];\n  const dx = tch.screenX - touchStartX;\n  const dy = tch.screenY - touchStartY;\n  el.style.left = Math.round(startX + dx) + &#39;px&#39;;\n  el.style.top = Math.round(startY + dy) + &#39;px&#39;;\n};\n\nel.addEventListener(&#39;touchstart&#39;, (evt: TouchEvent) =&gt; {\n  const tch = evt.touches[0];\n  startX = getStyleVal(&#39;x&#39;);\n  startY = getStyleVal(&#39;y&#39;);\n  touchStartX = tch.screenX;\n  touchStartY = tch.screenY;\n  document.addEventListener(&#39;touchmove&#39;, docMoveListener);\n});\nel.addEventListener(&#39;touchmove&#39;, (evt) =&gt; {\n  evt.preventDefault();\n});\nel.addEventListener(&#39;touchend&#39;, () =&gt; {\n  document.removeEventListener(&#39;touchmove&#39;, docMoveListener);\n});\nel.addEventListener(&#39;touchcancel&#39;, () =&gt; {\n  document.removeEventListener(&#39;touchmove&#39;, docMoveListener);\n});\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h4>捕获异步错误</h4>\n<p><a href=\"https://juejin.im/post/6844903830409183239#heading-4\">https://juejin.im/post/6844903830409183239#heading-4</a>  </p>\n<p>Promise 中 throw 的错误，无论是在构造函数中的同步代码还是在 then 回调中的异步代码都只能被 promise.catch 捕获，不能被外层的 <code>try-catch</code> 捕获。</p>\n<p>reject 返回的错误也只能被 promise.catch 捕获。</p>\n<p>总之：promise 会吞掉自身产生的错误，只能通过 promise.catch 捕获这些错误。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const promiseFetch = () =&gt;\n  new Promise((reslove) =&gt; {\n    throw new Error(&quot;promise 同步&quot;);\n    // reslove();\n  });\n\nfunction main() {\n  try {\n    promiseFetch()\n      .then(() =&gt; {\n        // throw new Error(&quot;promise.then 异步&quot;); // 只能被promise.catch 捕获\n      })\n      .catch((e) =&gt; {\n        console.debug(&quot;promise.catch e:&quot;, e);\n      });\n  } catch (e) {\n    console.debug(&quot;try-catch e:&quot;, e);\n  }\n}\n\nmain();</code>\n        </deckgo-highlight-code>\n<h6>利用Promise捕获异步错误</h6>\n<blockquote>\n<p>当异步代码发生错误时，通过 reject 抛出错误，然后用 promise.catch 捕获错误。</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const p3 = () =&gt;  new Promise((reslove, reject) =&gt; {\n  setTimeout(() =&gt; {\n    reject(&#39;async error&#39;);\n  })\n});\n\np3().catch(e =&gt; console.log(e));</code>\n        </deckgo-highlight-code>\n<h4>搜索高亮</h4>\n<blockquote>\n<p><a href=\"https://www.zhangxinxu.com/wordpress/2010/06/%E7%BA%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E9%AB%98%E4%BA%AEjquery%E6%8F%92%E4%BB%B6/\">纯客户端页面关键字搜索高亮jQuery插件</a> </p>\n<p><a href=\"https://juejin.cn/post/6844903747944972295#apply\">单关键词、多关键词、多组多关键词</a> </p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/46232980/click-giving-access-denied-in-ie11\">IE 链接下载失效</a> </p>\n<h4>移动端</h4>\n<h5>设备检测</h5>\n<ul>\n<li>是否是移动端</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">isTouch = &quot;ontouchstart&quot; in window || navigator.msMaxTouchPoints;\n\nconst touchSupported = () =&gt; {\n  return !!(&#39;ontouchstart&#39; in window || window.DocumentTouch &amp;&amp; document instanceof window.DocumentTouch);\n}</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://github.com/matthewhudson/current-device\">current-device</a>  </p>\n<p><a href=\"https://github.com/etienne-martin/device-detector-js\">device-detector-js</a>  </p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2021/09/detecting-mobile-browser.html\">移动端检测方法</a>  </p>\n<h4>链接</h4>\n<ul>\n<li><a href=\"https://github.com/YvetteLau/Step-By-Step/issues/26\">异步加载js脚本的方法</a> </li>\n</ul>\n<h4><a href=\"https://mp.weixin.qq.com/s/fepgCR4hikmMwIG3Fbb9gQ\">时间国际化-格式化</a></h4>","id":"a3d9a0aa-7338-5718-a7f0-b48837083b6c","parent":{"__typename":"File","name":"总结","base":"总结.md","mtime":"2022-03-30T03:12:22.858Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/前端/总结/"}},"staticQueryHashes":["3957182205"]}