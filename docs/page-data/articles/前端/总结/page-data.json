{"componentChunkName":"component---src-templates-post-js","path":"/articles/前端/总结/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/前端/总结/"},"html":"<h1>前端路由</h1>\n<p>前端路由是通过改变URL，在不重新请求页面的情况下，更新页面视图。改变URL且不会重载页面的方式：hash &#x26; H5 history.pushState replaceState</p>\n<blockquote>\n<p>HashHistory</p>\n</blockquote>\n<ul>\n<li>\n<p>hash虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变hash不会重新加载页面。</p>\n</li>\n<li>\n<p>可以为hash的改变添加监听事件：</p>\n<p><code>window.addEventListener(\"hashchange\",funcRef,false)</code></p>\n</li>\n</ul>\n<blockquote>\n<p>TML5History</p>\n</blockquote>\n<ul>\n<li>pushState和replaceState两种方法的共同特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，重载页面，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。</li>\n<li>用户导航到新的状态，popstate事件就会被触发；</li>\n</ul>\n<h1>长列表(Table)渲染优化</h1>\n<blockquote>\n<p>方案</p>\n</blockquote>\n<ol>\n<li>虚拟列表：固定渲染一定数据的列表项</li>\n</ol>\n<p><a href=\"https://github.com/tangbc/vue-virtual-scroll-list\">vue-virtual-scroll-list 组件</a>\n<a href=\"https://github.com/bvaughn/react-virtualized\">react-virtualized</a></p>\n<ol start=\"2\">\n<li>懒加载</li>\n</ol>\n<h1><a href=\"https://juejin.cn/post/6844903885505576968\">时区与JS中的Date</a></h1>\n<h1>跨域访问</h1>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\">同源策略</a></p>\n</blockquote>\n<p>来源于某个 Origin 的 document(html) 或 脚本能否访问其他 Origin 的资源（localStoreage、Cookie、静态资源、xhr接口等）。</p>\n<p>“同源” -- 两个源相同，哪两个源？脚本所在的源和脚本要访问的资源所在的源。</p>\n<blockquote>\n<p>跨域网络访问</p>\n</blockquote>\n<ol>\n<li>静态资源访问</li>\n<li>XMLHttpRequest 请求</li>\n</ol>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">跨域资源共享</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">CORS-博客</a></p>\n</blockquote>\n<p>CORS is a part of <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/HTTP\">HTTP</a> that lets servers specify any other hosts from which a browser should permit loading of content.</p>\n<p>出于安全性，浏览器限制脚本内发起的跨源 HTTP 请求。 例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。</p>\n<p>Web页面或应用部署(运行在A服务器/PC上)，用户浏览器请求A服务器上的页面进行访问，A服务器响应请求并返回页面，浏览器显示页面。</p>\n<p>页面中的JS通过XMLHttpRequest请求A服务器上的数据时，浏览器不会阻止。但请求B服务器上(第三方)的数据时，浏览器会根据 B 服务器上的跨域配置判断是否运行当前页面获取资源。</p>\n<p>浏览器安全策略会阻止该请求，B服务器甚至没有看到页面发出的请求。跨域是浏览器的限制，chrome 可以允许跨域，并且不需要修改服务端配置。</p>\n<p>域名与对应的 ip之间通信也算跨域，因为一个ip对应的主机可以有多个网站，对应多个域名。</p>\n<blockquote>\n<p>相关的响应头部字段</p>\n</blockquote>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy_(CORP)\">Corss-Origin-Resource-Policy</a> : 跨域策略，可选值为: <code>same-origin</code>、<code>same-site</code>、<code>cross-origin</code>\n<ul>\n<li>As this policy is expressed via a <em><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Response_header\">response header</a></em>, the actual request is not prevented—rather, the browser prevents the <em>result</em> from being leaked by stripping the response body.</li>\n<li>During a cross-origin resource policy check, if the header is set, the browser will deny <code>no-cors</code> requests issued from a different origin/site.</li>\n</ul>\n</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\">Access-Control-Allow-Origin</a>: 允许某个源或所有源访问\n<ul>\n<li>响应头部字段，标识 response 可以被哪些请求所在 Origin 访问。</li>\n<li>服务端收到请求时，检查 request header 的 Origin, 如果允许该 Origin，则设置响应中的 Access-Control-Allow-Origin 值为该请求的 Origin。</li>\n<li>请求中没有 <code>credentials</code> 字段时，服务端响应的 <code>Access-Control-Allow-Origin: *</code> 才有效。</li>\n<li>当请求是 <code>credentialed requests</code> 时，服务端必须指定 <code>Access-Control-Allow-Origin</code> 的值为 <code>*</code> 之外的明确值。</li>\n<li>如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。</li>\n</ul>\n</li>\n<li>Access-Control-Allow-Credentials\n<ul>\n<li>将 XMLHttpRequest 的 withCredentials 标志设置为 true，从而向服务器发送 Cookies。如果服务器端的响应中未携带 <code>Access-Control-Allow-Credentials: true</code>，浏览器将不会把响应内容返回给请求的发送者。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>实际测试</p>\n</blockquote>\n<ul>\n<li>正常的浏览器\n<ul>\n<li>【http-http】用 XSwitch 可以成功将一个 <a href=\"http://serve-a/x.js\">http://serve-a/x.js</a> 资源重定向到公网的 <a href=\"http://serve-b/x.js\">http://serve-b/x.js</a> 上，并且 <code>serve-b/x.js</code> 设置了 <code>Corss-Origin-Resource-Policy: same-origin</code>，但是不能重定向到本地的 Js 文件。</li>\n<li>【https-http】用 XSwitch 不能将 <a href=\"https://serve-a/x.js\">https://serve-a/x.js</a> 资源重定向到公网的 <a href=\"http://serve-b/x.js\">http://serve-b/x.js</a> 上，报错为：<code>This request has been blocked; the content must be served over HTTPS.</code>。</li>\n<li>【https-https】若 <a href=\"https://serve-b/x.js\">https://serve-b/x.js</a> 没有配置跨域的响应头部，XSwitch 可以将 <a href=\"https://serve-a/x.js\">https://serve-a/x.js</a> 可以重定向到 <a href=\"https://serve-b/x.js\">https://serve-b/x.js</a></li>\n</ul>\n</li>\n<li>命令行启动浏览器并允许跨域\n<ul>\n<li>【https-http】用 XSwitch 可以将 <a href=\"https://serve-a/x.js\">https://serve-a/x.js</a> 资源重定向到本地的 <a href=\"http://127.0.0.1:9001/x.js\">http://127.0.0.1:9001/x.js</a> 上</li>\n</ul>\n</li>\n</ul>\n<p><code>Access-Control-Allow-Headers: 'Origin, X-Requested-With, Content-Type, Accept'</code></p>\n<blockquote>\n<p>正常浏览器测试场景</p>\n</blockquote>\n<p><strong>(1).</strong> nginx 没有配置跨域相关的 header</p>\n<ul>\n<li>公网 139.xx 服务获取 <a href=\"http://127.0.0.1:123/demo.js\">http://127.0.0.1:123/demo.js</a> （失败，报错\"CORS\"，用命令行启动浏览器可以解决）</li>\n<li>公网 139.xx 服务获取 <a href=\"http://47.xx:8010/demo.js\">http://47.xx:8010/demo.js</a>  <strong>（成功）</strong></li>\n<li>127 服务获取公网 <a href=\"http://139.xx.xx/demo.js\">http://139.xx.xx/demo.js</a> （成功）</li>\n<li>test.dev.host 服务获取 <a href=\"http://139.xx.xx/demo.js\">http://139.xx.xx/demo.js</a>   test.dev.host 解析到127（成功）</li>\n<li>总结\n<ul>\n<li>本地127 或配置域名的 web 服务可以获取其他公网上的 Js 文件，公网不能获取本地 Js 文件，但另一位公网 Nginx 没有配置CORS时，从一个公网可以访问另一个公网的 Js 文件。</li>\n<li>一个公网访问跨域获取另一个公网服务商的图像</li>\n</ul>\n</li>\n</ul>\n<p><strong>(2).</strong> nginx 配置跨域相关的 header</p>\n<p>只配置 <code>Corss-Origin-Resource-Policy: same-origin</code> 没什么变化</p>\n<blockquote>\n<p>解决方案</p>\n</blockquote>\n<ol>\n<li>JSONP：Js 文件可以跨域访问。通过动态创建 script，再请求一个带参网址实现跨域通信，通过 <code>&#x3C;script></code> 标签，在 url 中指定 callback 回调函数，当响应到来时调用回调函数，数据就是传递给回调函数的实参。</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function handle(response){\n  console.log(response);\n}\nlet script = document.createElement(&#39;script&#39;);\nscript.src = &#39;http://xxx.com/?callback=handle&#39;;\ndocument.body.insertBefore(script, docuent.body.firstChild);</code>\n        </deckgo-highlight-code>\n<p>缺点：只支持 GET请求</p>\n<ol start=\"2\">\n<li>\n<p>CORS：跨域资源共享(Cross-origin resource sharing)，服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带 cookie 请求，前后端都需要设置。\nCORS 支持所有类型的请求方法；</p>\n</li>\n<li>\n<p>postMessage 跨域：可以跨域操作的window属性之一，配合 iframe。</p>\n</li>\n<li>\n<p>代理跨域：起一个代理服务器，实现数据的转发；</p>\n</li>\n<li>\n<p>document.domain + iframe 跨域：两个页面都通过 JS 强制设置 document.domain 为基础主域，就实现了同域。\n只支持主域相同，子域不同；</p>\n</li>\n<li>\n<p>location.hash + iframe 跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用 iframe 的 location.hash传值，相同域之间直接js访问来通信。</p>\n</li>\n<li>\n<p>window.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。</p>\n</li>\n</ol>\n<blockquote>\n<p>参考</p>\n</blockquote>\n<ul>\n<li><a href=\"https://juejin.im/entry/59feae9df265da43094488f6\">跨域，你需要知道的全在这里</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解 - 阮一峰的网络日志</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\">浏览器同源策略-postMessage</a></li>\n<li><a href=\"https://harttle.land/2016/12/28/cors-with-cookie.html#\">CORS 跨域发送 cookie</a>\n<ol>\n<li>客服端：withCredentials=true;</li>\n<li>服务端：Access-Control-Allow-Credentials=true; Access-Control-Allow-Origin: 单一域名</li>\n</ol>\n</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">access-control-allow-credentials: true\naccess-control-allow-headers: Content-Type\naccess-control-allow-origin: https://127.0.0.1:8087</code>\n        </deckgo-highlight-code>\n<h1><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\">cookie</a></h1>\n<h1><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API\">Web Storage</a></h1>\n<blockquote>\n<p>Web 全局存储、通信</p>\n</blockquote>\n<h1><a href=\"https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events\">自定义事件</a></h1>\n<blockquote>\n<p>postMessage  CustomEvent  initEvent</p>\n</blockquote>\n<h1>拖拽</h1>\n<ul>\n<li>\n<p><a href=\"https://juejin.im/post/6844903940706795533\">使用原生 JavaScript 实现拖放功能 - 掘金</a>\n<a href=\"https://mp.weixin.qq.com/s/4WLbV46MsDzlNWzzDep3Pw\">原生JS快速实现拖放实例效果与解析</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API\">HTML 拖放 API-| MDN</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations\">拖拽操作 - MDN</a></p>\n</li>\n<li>\n<p>拖拽元素</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function makeElMavable(el: HTMLElement) {\n  function getStyleVal(xy: &#39;x&#39; | &#39;y&#39;) {\n    const s = xy === &#39;x&#39; ? el.style.left : el.style.top;\n    const v = parseInt(s.replace(/\\D/, &#39;&#39;));\n    return v || 0;\n  }\n  \n  let startX = 0;\n  let startY = 0;\n  let touchStartX = 0;\n  let touchStartY = 0;\n  \n  const docMoveListener = (evt: TouchEvent) =&gt; {\n    const tch = evt.touches[0];\n    const dx = tch.screenX - touchStartX;\n    const dy = tch.screenY - touchStartY;\n    el.style.left = Math.round(startX + dx) + &#39;px&#39;;\n    el.style.top = Math.round(startY + dy) + &#39;px&#39;;\n  };\n  \n  el.addEventListener(&#39;touchstart&#39;, (evt: TouchEvent) =&gt; {\n    const tch = evt.touches[0];\n    startX = getStyleVal(&#39;x&#39;);\n    startY = getStyleVal(&#39;y&#39;);\n    touchStartX = tch.screenX;\n    touchStartY = tch.screenY;\n    document.addEventListener(&#39;touchmove&#39;, docMoveListener);\n  });\n  el.addEventListener(&#39;touchmove&#39;, (evt) =&gt; {\n    evt.preventDefault();\n  });\n  el.addEventListener(&#39;touchend&#39;, () =&gt; {\n    document.removeEventListener(&#39;touchmove&#39;, docMoveListener);\n  });\n  el.addEventListener(&#39;touchcancel&#39;, () =&gt; {\n    document.removeEventListener(&#39;touchmove&#39;, docMoveListener);\n  });\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h1>捕获异步错误</h1>\n<p><a href=\"https://juejin.im/post/6844903830409183239#heading-4\">https://juejin.im/post/6844903830409183239#heading-4</a></p>\n<p>Promise 中 throw 的错误，无论是在构造函数中的同步代码还是在 then 回调中的异步代码都只能被 promise.catch 捕获，不能被外层的 <code>try-catch</code> 捕获。</p>\n<p>reject 返回的错误也只能被 promise.catch 捕获。</p>\n<p>总之：promise 会吞掉自身产生的错误，只能通过 promise.catch 捕获这些错误。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const promiseFetch = () =&gt; {\n  return new Promise(reslove =&gt; {\n    throw new Error(&#39;promise 同步&#39;);\n    // reslove();\n  });\n};\n\nfunction main() {\n  try {\n    promiseFetch().then(() =&gt; {\n      // throw new Error(&quot;promise.then 异步&quot;); // 只能被promise.catch 捕获\n    }).catch(e =&gt; {\n      console.debug(&#39;promise.catch e:&#39;, e);\n    });\n  } catch (e) {\n    console.debug(&#39;try-catch e:&#39;, e);\n  }\n}\n\nmain();\n</code>\n        </deckgo-highlight-code>\n<h3>利用Promise捕获异步错误</h3>\n<blockquote>\n<p>当异步代码发生错误时，通过 reject 抛出错误，然后用 promise.catch 捕获错误。</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const p3 = () =&gt;  new Promise((reslove, reject) =&gt; {\n  setTimeout(() =&gt; {\n    reject(&#39;async error&#39;);\n  })\n});\n\np3().catch(e =&gt; console.log(e));</code>\n        </deckgo-highlight-code>\n<h1>搜索高亮</h1>\n<blockquote>\n<p><a href=\"https://www.zhangxinxu.com/wordpress/2010/06/%E7%BA%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E9%AB%98%E4%BA%AEjquery%E6%8F%92%E4%BB%B6/\">纯客户端页面关键字搜索高亮jQuery插件</a></p>\n<p><a href=\"https://juejin.cn/post/6844903747944972295#apply\">单关键词、多关键词、多组多关键词</a></p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/46232980/click-giving-access-denied-in-ie11\">IE 链接下载失效</a></p>\n<h1>移动端</h1>\n<h2>设备检测</h2>\n<ul>\n<li>是否是移动端</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">isTouch = &quot;ontouchstart&quot; in window || navigator.msMaxTouchPoints;\n\nconst touchSupported = () =&gt; {\n  return !!(&#39;ontouchstart&#39; in window || window.DocumentTouch &amp;&amp; document instanceof window.DocumentTouch);\n}</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://github.com/matthewhudson/current-device\">current-device</a></p>\n<p><a href=\"https://github.com/etienne-martin/device-detector-js\">device-detector-js</a></p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2021/09/detecting-mobile-browser.html\">移动端检测方法</a></p>\n<h1>链接</h1>\n<ul>\n<li><a href=\"https://github.com/YvetteLau/Step-By-Step/issues/26\">异步加载js脚本的方法</a></li>\n</ul>\n<h1><a href=\"https://mp.weixin.qq.com/s/fepgCR4hikmMwIG3Fbb9gQ\">时间国际化-格式化</a></h1>\n<h1>可视化</h1>\n<ul>\n<li><a href=\"https://antv.vision/zh/\">数据可视化 拓扑图</a></li>\n</ul>","id":"a3d9a0aa-7338-5718-a7f0-b48837083b6c","parent":{"name":"总结","base":"总结.md","mtime":"2022-09-07T04:15:03.260Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/前端/总结/"}},"staticQueryHashes":["3957182205"]}