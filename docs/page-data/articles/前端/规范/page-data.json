{"componentChunkName":"component---src-templates-post-js","path":"/articles/前端/规范/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/前端/规范/"},"html":"<h1>命名规则</h1>\n<h2>文件夹及文件</h2>\n<ul>\n<li>全部用小写字母，单词之间用横线隔开，此规范可以避免文件名大小写在不同文件系统下的行为不一致，</li>\n<li>命名格式：time-picker、split-button、common-utils</li>\n</ul>\n<h2>组件/标识符/name</h2>\n<ul>\n<li>命名格式，大驼峰【首字母大写】：TimePicker</li>\n<li>类别[区分+类别]：Button / SplitButton / MenuButton</li>\n<li>带功能组件【名词+动词】：TimePicker / TreeSelect / NumberPicker</li>\n<li>禁止导出没有名字的组件</li>\n</ul>\n<h2>强制命名规则</h2>\n<ul>\n<li>给组件根元素增加类名，className</li>\n<li>搜索关键字，keyword</li>\n<li>响应类事件回调以on开头，后面跟具体的响应类似</li>\n</ul>\n<h1>开发规范</h1>\n<ul>\n<li>数据向下，事件向上，一切变化都是可追溯的。可预测的</li>\n<li>第三方外部链接(eg:<a href=\"https://www.google.com)%E8%B7%B3%E8%BD%AC%E4%B8%80%E5%BE%8B%E7%94%A8a%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%90%8C%E6%97%B6%E5%BF%85%E9%A1%BB%E6%96%B0%E6%A0%87%E7%AD%BE%E6%89%93%E5%BC%80%EF%BC%8C%E8%AE%BE%E7%BD%AErel=%22noreferrer\">https://www.google.com)跳转一律用a标签，同时必须新标签打开，设置rel=\"noreferrer</a> noopener\" 属性</li>\n</ul>\n<h1>前端代码规范</h1>\n<blockquote>\n<p><a href=\"https://juejin.cn/post/7038143752036155428\">前端工程化</a>（git规范）\r\n<a href=\"https://segmentfault.com/a/1190000040283335\">前端规范</a></p>\n</blockquote>\n<ul>\n<li>区分开发、提交代码、生产环境</li>\n<li><a href=\"https://editorconfig.org/\">EditorConfig</a>: 跨编辑器和IDE编写代码，保持一致的简单编码风格。某些编辑器已默认集成对EditorConfig的支持，比如常用的：Webstorm、IntelliJ IDEA等；而另一些编辑器则需要借助安装对应的插件来支持：比如 Visual Studio Code、Atom等（EditorConfig for vs code）。配置文件 <code>editorconfig</code></li>\n<li>ESLint：作代码质量检测、编码风格约束等；</li>\n<li>Prettier: 专注于代码格式化的工具，美化代码；</li>\n<li>git commit 检查</li>\n<li>cli 脚手架集成 <a href=\"https://mp.weixin.qq.com/s/FRU-zpSS3JgN5SXnq4K_kA\">脚手架集成</a></li>\n</ul>\n<h2>eslint 和 prettier 配置</h2>\n<blockquote>\n<p>VSCode 中安装的是在编辑器里面用的，如果项目根目录下有 eslintrc 和 prettierrc 配置文件，VSCode 插件会自动读取配置文件中的配置检查你的代码和格式化文件，npm 安装的是在命令行中运行的。如果你只安装 npm 包，VSCode 是不会有 lint 提示的，只能通过命令行，在小黑窗查看不符合 lint 规则的检测信息。安装 npm 包最主要的原因是可以通过 git hook 强制提交代码前 lint 和格式化代码保证代码仓库的代码风格统一。</p>\n<p>ESLint 进行语法检查，Prettier 只格式化代码，不要在 ESLint 中去配置代码风格相关的规则，避免 eslint 和 prettier 冲突。</p>\n</blockquote>\n<p>在项目目录下安装 eslint prettier</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 安装eslint\r\nnpm i eslint -D\r\nnpx eslint --init // 生成eslint配置文件\r\nnpx eslint xx.js // 语法检查\r\n\r\n// 安装prettier并解决 eslint 和 prettier 冲突\r\nnpm i prettier eslint-config-prettier eslint-plugin-prettier -D\r\n// 在.eslintrc 的 extend 中添加 &quot;prettier&quot; 解决 eslint 和 prettier 的冲突\r\n\r\n// 格式检查\r\nnpx prettier</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>eslint 配置集</p>\n<p>eslint-plugin-prettier: 先使用 prettier 对代码进行格式化\r\neslint-config-prettier: 使用这个配置集，会关闭一些可能与 prettier 冲突的规则\r\neslint-config-airbnb: Airbnb 公司提供的配置集\r\neslint-config-vue: vuejs 使用的配置集</p>\n</blockquote>\n<p>安装 eslint 包后可以在命令行校验文件，但是编辑器不会提示，在编辑器安装 eslint 插件后编辑器才会有报错提示，并且可以配置编辑器保存文件时自动修复报错。</p>\n<h2>git 规范</h2>\n<p>如果你正在使用GIt做项目代码管理，那么则可以借助 husky + lint-staged + prettier 在 Git 提交时，自动强制校验并格式化且修复代码，而且只处理自己<strong>本次改动提交的文件</strong>。</p>\n<p>lint-staged 的概念是在git中暂存的文件上运行配置好的linter任务（或其他任务）。lint-staged总是将<strong>所有暂存文件</strong>的列表传递给任务，如果想让 linter 的某个任务忽略某些文件，应该在这个任务的配置文件中进行配置（如不对第三方库进行 eslint 和 prettier 处理，应该配置 .eslintignore 和 .prettierignore）。</p>\n<blockquote>\n<p><a href=\"https://www.npmjs.com/package/husky\">husky</a>: 操作 git 钩子的工具，在 git 钩子中执行命令\r\n<a href=\"https://www.npmjs.com/package/lint-staged\">lint-staged</a>: 对本地暂存区文件进行检查（eslint、prettier），它的实现涉及到 git pre-commit hooks。\r\ncommitlint: commit 信息校验\r\ncommitizen: 辅助 commit 信息，交互式</p>\n</blockquote>\n<p><a href=\"https://juejin.cn/post/7005459733427519501\">安装并配置 lint-staged</a></p>\n<p>方法（1），在安装 eslint 和 prettier 的前提下根据 package.json 的依赖自动安装</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">npx mrm@2 lint-staged</code>\n        </deckgo-highlight-code>\n<p>方法（2）</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">npm install --save-dev husky lint-staged</code>\n        </deckgo-highlight-code>\n<p>package.json 中的配置</p>\n<deckgo-highlight-code language=\"json\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// package.json \r\n// husky v4版本，husky@4.3.8 版本更稳定\r\n{\r\n  &quot;husky&quot;: {\r\n    &quot;hooks&quot;: {\r\n      &quot;pre-commit&quot;: &quot;lint-staged&quot;,\r\n      &quot;pre-commit&quot;: &quot;lint-staged &amp;&amp; pretty-quick --staged&quot;\r\n    }\r\n  },\r\n  &quot;lint-staged&quot;: {\r\n    &quot;*.js&quot;: &quot;eslint  --fix&quot;,\r\n    &quot;src/**/*.{js,jsx,vue,json,css,less,scss,sass}&quot;: [\r\n      &quot;eslint --fix&quot;, // 先检查语法\r\n      &quot;prettier --write&quot;, // 再格式化\r\n    ],\r\n    &quot;*.{ts,json,yml,yaml,md}|examples/*.md&quot;: [\r\n      &quot;prettier --check&quot;\r\n    ],\r\n    &quot;*.md|{.github,benchmark,bin,examples,hot,lib,schemas,setup,tooling}/**/*.{md,yml,yaml,js,json}&quot;: [\r\n      &quot;cspell&quot;\r\n    ]\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<h2>git commit规范</h2>\n<blockquote>\n<p><a href=\"https://github.com/conventional-changelog/commitlint\">commitlint</a>: 格式检查\r\n<a href=\"https://github.com/commitizen/cz-cli#making-your-repo-commitizen-friendly\">commitizen</a>: 交互式提示信息</p>\n</blockquote>\n<h2>Git CI 集成</h2>\n<blockquote>\n<p><code>git hooks</code> 可以绕过，但 CI(持续集成) 是绝对绕不过的，因为它在服务端校验。使用 <code>gitlab CI</code> 做持续集成，配置文件 <code>.gitlab-ci.yaml</code> 如下所示</p>\n</blockquote>\n<deckgo-highlight-code language=\"json\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// .gitlab-ci.yaml\r\nlint:\r\nstage:lint\r\nonly:\r\n -/^feature\\/.*$/\r\nscript:\r\n -npmlint</code>\n        </deckgo-highlight-code>","id":"456a9a15-41c8-50e2-bf61-37287a4750b5","parent":{"name":"规范","base":"规范.md","mtime":"2023-03-08T03:39:20.589Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/前端/规范/"}},"staticQueryHashes":["3957182205"]}