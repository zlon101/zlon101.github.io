{"componentChunkName":"component---src-templates-post-js","path":"/articles/前端/JS/总结/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/前端/JS/总结/"},"html":"<h1>页面生命周期</h1>\n<ul>\n<li>\n<p>window.onload</p>\n</li>\n<li>\n<p>window.onunload</p>\n</li>\n<li>\n<p>window.onbeforeunload</p>\n</li>\n<li>\n<p>document.addEventListener(\"DOMContentLoaded\", fn);  DOMContentLoaded 只能用addEventListener监听</p>\n</li>\n<li>\n<p>document.addEventListener('readystatechange', fn);</p>\n<ul>\n<li>对应 document.readyState 属性，取值：loading | interactive | complete</li>\n<li>Loading: html 加载中</li>\n<li>interactive: html加载完成, dom 解析完成，可以操作dom，但是js、图像等资源还在加载，触发 DOMContentLoaded 事件</li>\n<li>complete: 资源完全加载，触发 window.onload</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>参考 <a href=\"https://zh.javascript.info/onload-ondomcontentloaded\">javascript.info</a></p>\n</blockquote>\n<h1>viewport | 视口</h1>\n<p>缩放改变的是 <code>window.devicePixelRatio</code></p>\n<ul>\n<li>\n<p>布局视口：渲染后页面的实际大小，包含滚动情况下溢出的区域，页面缩放时（调整缩放级别）大小不变。</p>\n</li>\n<li>\n<p>可见视口：页面可见的部分，缩放时尺寸不变的部分（地址栏、书签栏）都不算可见视口的区域。</p>\n<ul>\n<li>可见视口大小与窗口大小和缩放级别有关</li>\n<li>如何读写？</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let pageWidth = window.innerWidth;\r\nlet pageHeight = window.innerHeight;\r\nif (typeof pageWidth !== &#39;number&#39;) {\r\n  if (document.compatMode === &#39;CSS1Compat&#39;) {\r\n    pageWidth = document.documentElement.clientWidth;\r\n    pageHeight = document.documentElement.clientHeight;\r\n  } else {\r\n    // 混杂模式\r\n    pageWidth = document.body.clientWidth;\r\n    pageHeight = document.body.clientHeight;\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>window.screen.availHeight\\Width\\Left\\Top</code></li>\n<li>网页缩放时布局视口、可见视口的变化？</li>\n<li><a href=\"https://zh.javascript.info/popup-windows#yi-dong-he-tiao-zheng-da-xiao\">https://zh.javascript.info/popup-windows#yi-dong-he-tiao-zheng-da-xiao</a></li>\n</ul>\n<blockquote>\n<p>旧文档</p>\n</blockquote>\n<ul>\n<li>\n<p>布局视窗可以通过 <code>&#x3C;meta></code> 标签设置 viewport 来修改。每个浏览器默认都会有一个设置，例如iOS，Android这些机型设置布局视窗宽度为980px，所以PC上的网页基本能在手机上呈现，只不过元素看上去很小，一般可以通过手指动双击缩放网页。</p>\n</li>\n<li>\n<p>控制放大和缩小的就是视窗Viewport</p>\n</li>\n<li>\n<p>window.screen.width：获取屏幕的宽度，等于系统设置里面的屏幕分辨率，和页面没有关系（包括resize 、缩放）</p>\n</li>\n<li>\n<p>什么是 viewport 视口</p>\n<ul>\n<li>可视区域，不包含滚动之外的内容</li>\n<li>视口 === 布局视口 === document.documentElement.clientWidth</li>\n<li>layout viewport | visual viewport (布局视口)</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Viewport\">https://developer.mozilla.org/en-US/docs/Glossary/Viewport</a></li>\n</ul>\n</li>\n<li>\n<p><code>window.innerWidth</code>: visual viewport 的宽度。页面缩放会影响该值，放大时值变小。</p>\n</li>\n<li>\n<p><code>window.outerWidth</code>: 整个浏览器窗口的尺寸，包含从标签页顶部的尺寸</p>\n</li>\n<li>\n<p>获取文档尺寸</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const scrollHeight = Math.max(\r\n  document.body.scrollHeight, document.documentElement.scrollHeight,\r\n  document.body.offsetHeight, document.documentElement.offsetHeight,\r\n  document.body.clientHeight, document.documentElement.clientHeight\r\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>获取浏览器视口大小</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function getViewportSize() {\r\n  // 混杂模式\r\n  if (document.compatMode === &#39;BackCompat&#39;) {\r\n    return {\r\n      width: document.body.clientWidth,\r\n      height: document.body.clientHeight,\r\n    };\r\n  }\r\n  return {\r\n    width: document.documentElement.clientWidth,\r\n    height: document.documentElement.clientHeight,\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<h1>DOM操作</h1>\n<h2>元素尺寸</h2>\n<blockquote>\n<p>clientHeight  offsetHeight   scrollHeight</p>\n</blockquote>\n<p>clientWidth、offsetWidth、scrollWidth 都是只读属性，而且每次访问这些属性时都会重新计算。</p>\n<img src=\"/dc828b194f6c868af738144cf344c946/DOM元素尺寸.svg\" alt=\"DOM元素尺寸\" style=\"zoom:67%;\"> \n<ul>\n<li><code>clientHeight</code> 内容区域加内边距，不包含滚动条和 border，可用于内容的文档的可见部分的 width/heigh，<code>inline</code> 元素获取的 clientWidth 和 clientHeight 为 0 ；</li>\n<li><code>offsetWidth</code> 包含边框和滚动条的宽度，不包含伪元素 (::before、::after)</li>\n<li><code>scrollHeight</code> 包含滚动隐藏尺寸，包含伪元素，如果元素没有溢出，该值等于 clientHeight</li>\n</ul>\n<blockquote>\n<p>getBoundingClientRect</p>\n</blockquote>\n<p><strong>计算元素相对于视口的位置</strong></p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/0af0c7d38022ec66861c3884bac8f339/ad997/image-20210702112944679.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 77%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACb0lEQVQ4y5WUC4+bOBSF8/9/0u5WlbZPrbadziSThDdkCAFDEhKwMQ/zVSHtqBlNpV2kT9ey0PG510eenZw3yOR+ok7uUNkSJdb/kxVN4VI6fzI7B+/om5Je7unqHKMrGAdMrzF9+x/RjONIHX9hdg7fYwZNr08MXYUMF9T7LUNzpFeHHxxf4fDMoPac9imn8COzyn8PjWasz5gspv78BtXqyeVPRtPfMlzqAGa8Akg9UG2/Mau8v2mPB/LIpwss1PIttVhxTpack8cJJexpRk3h0OQOTeEh0zmt8DGn4yRYS00Vf2VWbT5PG9dzoNm75ElEttux2z6RJjF91/Py62SOzhzG6vSL4B2zKvp0FTRmGqzOLbI4YBP6xJHPU+jhO2u2m5BN4OJZS5I4pq0FrXAZz78THM3VYW4RBxaR7xL5DvbyAd9e4dlLAtcicNeILEOf00mwDyyG2KM6nn7M8KWgsIj9NaFnE14EnPVzvbgNPYtcCOQxps09zI3Dr685tPHWC1zbwlmvCDwXz7ZYP86xV0tca0Wxv8bmZoaqpdq+0rISS/LonjSckwb37PxvpOHDVLNojtgs6OpLyxFq9YEhtBnMwFMYUW3+fSE4Ql9s6TKPXvh0wp9qn4f0eXBdC58289DWPwxlAWZAnkoKUSDsd7/e8jBhqpKxUYxKwiXgqr4OPo0Zm2baH3WDiX2MrKa4TSG/tH1p+eB/QHUgmxbZdEjdIztDrXuKsqasG2QlkUojW4NsB1Q3kogDfXubT5UumJXOX8h0Rb1bPCN3C87bBxLrI4fwy/Sa1LvHm3/KzR1yN7++TunjFLfS/oPvG1RtFeTMZYoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image-20210702112944679\" title=\"image-20210702112944679\" src=\"/static/0af0c7d38022ec66861c3884bac8f339/5a190/image-20210702112944679.png\" srcset=\"/static/0af0c7d38022ec66861c3884bac8f339/772e8/image-20210702112944679.png 200w,\n/static/0af0c7d38022ec66861c3884bac8f339/e17e5/image-20210702112944679.png 400w,\n/static/0af0c7d38022ec66861c3884bac8f339/5a190/image-20210702112944679.png 800w,\n/static/0af0c7d38022ec66861c3884bac8f339/ad997/image-20210702112944679.png 1012w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span> \n<ul>\n<li>viewport 内(以可视区域的左上角为坐标原点)，盒模型左上角和右小脚的坐标（x, y）</li>\n<li>ie 不支持 element.getBoundingClientRect().x</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const rect = ele.getBoundingClientRect();\r\nrect.right - rect.left === rect.width === ele.offsetWidth; // 三者相等</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\">https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect</a>\r\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements\">确定元素的尺寸-MDN</a></p>\n<ul>\n<li>getBoundingClientRect 无法使用时计算 <code>element.left</code> 和 <code>element.top</code></li>\n</ul>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 相对于 viewport 的偏移\r\nfunction getElementLeft(ele, left = 0, top = 0) {\r\n  if (!ele) return { left, top };\r\n  const { offsetLeft, offsetTop } = ele;\r\n  return getElementLeft(ele.offsetParent, left + offsetLeft, top + offsetTop)\r\n}</code>\n        </deckgo-highlight-code>\n<h2>元素位置</h2>\n<ul>\n<li>Element.clientTop/Element.clientLeft:  左/上边框的宽度，包含滚动条宽度，不含 margin、padding。</li>\n<li>Element.offsetTop:  元素的边框相对于最近的定位祖先元素的边框的距离</li>\n<li>Element.scrollTop:  元素内容区域滚动的距离</li>\n</ul>\n<h2>监听元素变化</h2>\n<ul>\n<li>监听DOM元素变化: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\">MutationObserver</a> <a href=\"https://zh.javascript.info/mutation-observer\">https://zh.javascript.info/mutation-observer</a></li>\n<li>监听DOM元素尺寸变化: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\">ResizeObserver</a> 、<a href=\"https://github.com/juggle/resize-observer\">Polyfill</a></li>\n<li>监听DOM元素是否可见: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver\">IntersectionObserver</a></li>\n<li>DOMSubtreeModified DOMNodeInserted DOMNodeRemoved  DOMNodeInsertedIntoDocument  DOMNodeRemovedFromDocument DOMAttrModified DOMCharacterDataModified</li>\n</ul>\n<h2>滚动</h2>\n<ul>\n<li>\n<p><code>window.pageYOffset</code>\r\n以左上角为坐标原点，页面水平、垂直滚动的距离，只读</p>\n</li>\n<li>\n<p><code>window.scrollBy()</code>  和 <code>window.scrollTo()</code>\r\n<code>window.scrollBy(x, y)</code> 相对于当前位置滚动，<code>window.scrollTo(x, y)</code> 相对于文档左上角滚动</p>\n</li>\n<li>\n<p><code>document.documentElement.scrollTop</code> 和 <code>document.body.scrollTop/Left</code>（safari）、<code>ele.scrollTop</code>\r\n垂直滚动距离，可读可写</p>\n</li>\n<li>\n<p><code>ele.scrollIntoView</code></p>\n</li>\n<li>\n<p><code>element.focus()</code> 也会导致页面滚动并显示获得焦点的元素</p>\n</li>\n<li>\n<p>判断是否溢出</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">  ele.clientWidth &lt; ele.scrollWidth || ele.clientHeight &lt; ele.scrollHeight</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p><a href=\"https://zh.javascript.info/size-and-scroll-window\">现代JS文档: size-and-scroll-window</a>\r\n<a href=\"https://www.runoob.com/jqueryui/example-resizable.html\">Jquery 拖拽 resize</a></p>\n</blockquote>\n<h1>Web Worker</h1>\n<p>浏览器中 JavaScript 引擎是单线程执行的。也就是在同一时间内只能有一段代码被 JavaScript 引擎执行。如果同一时间还有其它代码需要执行的话，则这些代码需要等待 JavaScript 引擎执行完成当前的代码之后才有可能获得被执行的机会。正常情况下，JavaScript 引擎会顺序执行页面上的所有 JavaScript 代码。当页面加载完成之后，JavaScript 引擎会进入空闲状态。用户在页面上的操作会触发一些事件，这些事件的处理方法会交给 JavaScript 引擎来执行。由于 JavaScript 引擎的单线程特性，一般会在内部维护一个待处理的事件队列。每次从事件队列中选出一个事件处理方法来执行。如果在执行过程中，有新的事件发生，则新事件的处理方法只会被加入到队列中等待执行。如果当前正在执行的事件处理方法非常耗时，则队列中的其它事件处理方法可能长时间无法得到执行，造成用户界面失去响应，严重影响用户的使用体验。</p>\n<ul>\n<li>\n<p>主线程<strong>异步</strong>创建 web worker，主线程代码不会阻塞在这里等待 worker 线程去加载、执行指定的脚本文件，而是会立即向下继续执行后面代码。</p>\n</li>\n<li>\n<p>Web Worker 自身是由 webkit(浏览器内核) 多线程实现，但它并没有为 JavaScript 语言带来多线程编程特性，我们现在仍然不能在 JavaScript 代码中创建并管理一个线程，或者主动控制线程间的同步与锁等特性。</p>\n</li>\n</ul>\n<p>在我看来，Web Worker 是 worker 编程模型在浏览器端 JavaScript 语言中的应用。浏览器的运行时, 同其他 GUI 程序类似，核心逻辑像是下面这个无限循环:</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">while(true){  \r\n  // 1 更新数据和对象状态  \r\n  // 2 渲染可视化UI  \r\n}</code>\n        </deckgo-highlight-code>\n<p>在 Web Worker 之前，JavaScript 执行引擎只能在一个单线程环境中完成这两项任务。而在其他典型 GUI 框架，如前文 Swing 库中，早已引入了 Swing Worker 来解决大量计算对 UI 渲染的阻塞问题。Web Worker 的引入，是借鉴了 worker 编程模型，给单线程的 JavaScript 带来了后台计算的能力。</p>\n<blockquote>\n<p>参考</p>\n</blockquote>\n<ul>\n<li><a href=\"http://www.alloyteam.com/2015/11/deep-in-web-worker/#prettyPhoto\">腾讯全端 AlloyTeam-Web Worker</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/web/1105_chengfu_jsworker/index.html\">JS 工作线程实现方式-setTimeout &#x26; web worker</a>\r\nsetTimeout &#x26; setInterval 执行过程；</li>\n</ul>\n<h1>实现动画的方法</h1>\n<ol>\n<li>css:  transition animation</li>\n<li>js: setTimeout、setInterval、requestAnimationFrame</li>\n<li><strong>html5: canvas ?</strong></li>\n</ol>\n<blockquote>\n<p>参考</p>\n</blockquote>\n<ul>\n<li><a href=\"https://threejs.org/examples/#webgl_decals\">三维动画库</a></li>\n<li><a href=\"https://www.cnblogs.com/coco1s/p/15009605.html\">带圆角的三角形-动画</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations\">Animation</a></li>\n</ul>\n<h1>特殊运算符</h1>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">可选链 空值运算符</a></p>\n</blockquote>\n<blockquote>\n<p>void 0 &#x26; undefined</p>\n</blockquote>\n<p>undefined 不是 JS 中的保留字，而是全局对象的一个属性，在 ES5 之前是可修改的（<code>undefined = 1</code>），ES5 之后修改为只读属性，但是在局部作用域内依然可以覆盖 undefined 的值，如：<code>const undefined = 1;</code>。</p>\n<blockquote>\n<p>new this</p>\n</blockquote>\n<p>使用 <code>new</code> 实例化对象时构造函数内部<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#description\">执行步骤</a></p>\n<ul>\n<li>若执行 new Foo()，过程如下：</li>\n</ul>\n<p>1）创建新对象 o；\r\n2）给新对象的内部属性赋值，关键是给[[Prototype]]属性赋值，构造原型链（如果构造函数的原型是 Object 类型，则指向构造函数的原型；不然指向 Object 对象的原型）；\r\n3）执行函数 Foo，执行过程中内部 this 指向新创建的对象 o；\r\n4）如果 Foo 内部显式返回对象类型数据，则返回该数据；否则返回新创建的对象 o。</p>\n<ul>\n<li>在 Person 函数体中判断函数是否已 <code>new</code> 调用</li>\n</ul>\n<ol>\n<li><code>this instanceof Person</code></li>\n<li>ES6 环境下: <code>new.target === Person</code></li>\n</ol>\n<h1>String</h1>\n<blockquote>\n<p>概念</p>\n</blockquote>\n<p>16位 Unicode 字符 | 双字节字符</p>\n<p>UTF-16 最多能表示 2^16=65536 个字符， 这 65536 个字符称为 basic multilingual plane (BMP) 字符集，可以用 <code>\\uxxxx</code> 表示。</p>\n<p>Unicode code points range from 0 to 1114111 (0x10FFFF). The first 128 Unicode code points are a direct match of the ASCII character encoding.</p>\n<p>Unicode 字符集远大于 65536，超过的字符就用两个 UTF-16 编码单元(4字节)表示，这两个编码单元每个的取值在 0xD800 - 0xDFFF 范围。</p>\n<p>每个 Unicode 字符由一个或两个 UTF-16 编码单元表示，又称 <strong>Unicode code point</strong>，用 <code>\\u{xxxx}</code> 1到6位16进制数表示。</p>\n<p>\"unicode\": \"2764 FE0F\",\r\n\"icon\": \"❤️\"</p>\n<p>\"unicode\": \"1F525\",\r\n\"icon\": \"🔥\"</p>\n<ul>\n<li>\n<p>😀</p>\n<ul>\n<li>length: 2</li>\n<li>uncode: [\\uD83D, \\uDE00] => [55357, 56832]</li>\n<li>转义表示:  \\u{1f600}</li>\n</ul>\n</li>\n<li>\n<p>a</p>\n<ul>\n<li>ASCII:  97  0x60</li>\n<li>转义表示: \\u0061 或 \\u{61}</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>方法</p>\n</blockquote>\n<ul>\n<li>String.prototype.charCodeAt  String.fromCharCode  ==> UTF-16 code unit</li>\n<li>String.prototype.codePointAt  String.fromCodePoint  ==> Unicode code point</li>\n<li>btoa  atob <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/btoa\">https://developer.mozilla.org/en-US/docs/Web/API/btoa</a></li>\n</ul>\n<blockquote>\n<p>参考</p>\n</blockquote>\n<p><a href=\"https://zh.javascript.info/unicode\">Unicode-javascript.info</a></p>\n<h1>Number</h1>\n<p>在内部，数字是以 64 位格式 IEEE-754 表示的，所以正好有 64 位可以存储一个数字：1个符号位、11个指数位（exponent）、52个小数位（mantissa）。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/28b1da248e48f3dd5f49a2498e66a2eb/efb68/image-20230215135713259.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABFElEQVQoz42RbWvCMBCA+///0PbNzZf229gLsjmrQ6ct1dk2aUzbpOkzqigbCtvBQ+4S7ni4eLY2ZEnKZpVwLXZSskquv7Vte3HnLbYRt/MeN/Me7w8+0TBg7QesRj7rkc+iP+Dj7p7ID/gcjoiCgGV/QPL0jHPtYehPvDjd8CpCXrIJy/EjxcsYOZshwhAxDZHh7Ew+nR7PyRtpGNK27tKwkAUqK9BSk8cJRbJBaI3Y75FaU5TlGVVVyLKmsCAqkKpCSoGUkizL0FrjlWXJLk3Zfm3JhUAqRZ7nKKWwxlDXNeYXBmMajHXYxmGtPWCMoWkavFPSNXbDT7Vz7urS/wqva+6MOuU4jg9mQoijobXn3/wv32ouGVizdFUVAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20230215135713259\"\n        title=\"image-20230215135713259\"\n        src=\"/static/28b1da248e48f3dd5f49a2498e66a2eb/5a190/image-20230215135713259.png\"\n        srcset=\"/static/28b1da248e48f3dd5f49a2498e66a2eb/772e8/image-20230215135713259.png 200w,\n/static/28b1da248e48f3dd5f49a2498e66a2eb/e17e5/image-20230215135713259.png 400w,\n/static/28b1da248e48f3dd5f49a2498e66a2eb/5a190/image-20230215135713259.png 800w,\n/static/28b1da248e48f3dd5f49a2498e66a2eb/c1b63/image-20230215135713259.png 1200w,\n/static/28b1da248e48f3dd5f49a2498e66a2eb/29007/image-20230215135713259.png 1600w,\n/static/28b1da248e48f3dd5f49a2498e66a2eb/efb68/image-20230215135713259.png 2032w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><code>e</code> 等于 11 位指数位表示的数，最大为 2^11-1-1=1023，最小为1</p>\n<p>11 位指数有两个特殊情况\r\n1）全为0：当52位小数全为0时表示正负0，否则表示非规范化浮点数\r\n2）全为1：当52位小数全为0时表示正负无穷大，否则表示 NaN</p>\n<p>Integers can only be represented without loss of precision in the range  <code>-2^53 + 1 to 2^53 - 1</code>。<span style=\"color:red\">实际测试为 -2^53 到 2^53</span></p>\n<p>最大安全整数：Number.MAX_SAFE_INTEGER = 2^53</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Double-precision_floating-point_format\">双精度浮点数-Wiki</a></p>\n<p>最大整数\r\n精度丢失\r\nisNaN\r\nisFinite</p>\n<blockquote>\n<p>解决精度问题</p>\n</blockquote>\n<p><a href=\"https://github.com/josdejong/mathjs/\">mathjs</a>\r\n<a href=\"https://github.com/nefe/number-precision\">number-precision</a></p>\n<h1>eval</h1>\n<p>参数：预期是字符串\r\n返回值：若参数是字符串，返回值就是字符串执行的结果，否则返回值是输入参数本身</p>\n<p>两种调用方式：\r\n直接调用：eval()\r\n间接调用：eval?.()、别名、对象属性、表达式</p>\n<p>直接调用、间接调用的区别：</p>\n<ul>\n<li>\n<p>是否继承上级作用域的 strict 模式</p>\n<ul>\n<li>间接调用不继承上级作用域的 'use strict' 模式，比如在一个声明了 'use strict' 的函数中以间接的方式调用 eval，eval 中代码是在非严格模式下执行</li>\n<li>直接调用会继承 strict 模式</li>\n</ul>\n</li>\n<li>\n<p>执行环境（作用域）</p>\n<ul>\n<li>间接调用的执行作用域为全局作用域，eval 中的 script 不能访问局部作用域中的变量</li>\n<li>直接调用的作用域为？</li>\n<li>直接调用的 eval 可以访问访问其他上下文中的变量【危险，可能修改局部变量】</li>\n</ul>\n</li>\n<li>\n<p>变量声明和函数声明</p>\n<ul>\n<li>在非 strict 模式下，对于直接调用形式，var声明的变量和函数属于上级作用域(surrounding scope)，eval 中的代码可能修改外部的变量值；对于间接调用，var声明的变量和函数属于全局作用域</li>\n<li>在 strict 模式下，var声明的变量和函数属于局部作用域，和调用方式无关</li>\n<li>let 和 const 声明的变量始终属于局部作用域</li>\n<li>直接 eval 会读取和修改周围作用域中的绑定，这可能导致外部输入破坏本地数据。</li>\n</ul>\n</li>\n</ul>","id":"c25ec6c8-d550-5d61-8697-c3189c91dbe3","parent":{"name":"总结","base":"总结.md","mtime":"2023-03-14T03:35:18.000Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/前端/JS/总结/"}},"staticQueryHashes":["3957182205"]}