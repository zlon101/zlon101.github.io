{"componentChunkName":"component---src-templates-post-js","path":"/articles/前端/JS/ES6/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/前端/JS/ES6/"},"html":"<blockquote>\n<p><a href=\"https://es6.ruanyifeng.com/#docs/class\">ES6入门-阮一峰</a></p>\n</blockquote>\n<h1>变量声明</h1>\n<blockquote>\n<p>var 特点</p>\n</blockquote>\n<p>声明函数作用域或全局作用域变量</p>\n<p>可以重复声明</p>\n<p>存在声明提升</p>\n<blockquote>\n<p><a href=\"https://github.com/febobo/web-interview/issues/34\">const let 特点</a></p>\n</blockquote>\n<ol>\n<li>const 和 let 都不存在变量提升，都存在暂时性死区</li>\n</ol>\n<p><strong>暂时性死区</strong>：let 和 const 声明的变量从进入块级作用域就绑定了，不能在 let 或 const 声明语句之前使用 var 或者 没有 var 声明及使用该变量。因此在 let 和 const 声明语句之前(死区)不能以任何形式出现该变量，并且 typeof 也不是一定安全的操作(在没有 let 和 const 之前，typeof 一定不会产生错误)。</p>\n<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>\n<ol start=\"2\">\n<li>\n<p>不能重复声明</p>\n</li>\n<li>\n<p>var 声明的全局变量作为顶层对象( window\\global )的属性，let 和 const 声明的变量不会；</p>\n</li>\n<li>\n<p>块级作用域中的函数声明</p>\n</li>\n</ol>\n<p>ES5 规定函数声明只能在全局或函数作用域中，不能在块级作用域(ES5 没有块级作用域)，但浏览器没有遵守该规定，ES5 环境下，在块级作用域中声明的函数存在声明提升，等同于函数表达式(声明提升，值为 undefined)；</p>\n<p>ES6 引入块级作用域，允许在块级作用域中声明函数；</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// ES6严格模式\r\n&#39;use strict&#39;;\r\nif (true) {\r\n function f() {}\r\n}\r\n// 不报错</code>\n        </deckgo-highlight-code>\n<p>ES6 规定块级作用域中的函数声明语句的行为类似于 let，在块级作用域之外不可引用；</p>\n<p>为了减少兼容性问题，浏览器可以不遵守 ES6 的规定，在 ES6 环境下的浏览器中的行为方式：</p>\n<p>可以在块级作用域中声明函数，但会像对待 var 语句一样(而不是 let)，将函数的声明提升至函数作用域的顶部(只是声明，尚未赋值)；在块级作用域中该函数都是可用的。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// ES6的浏览器环境, 此处为全局作用域\r\nfunction f() { \r\n console.log(&#39;I am outside!&#39;);\r\n}\r\n(function () {\r\n // 此处为函数作用域\r\n // var f = undefined; 该语句是块级作用域中的函数声明部分提升至此;\r\n typeof f;           // undefined\r\n if (true) {\r\n   // 此处为块级作用域, 在该作用域中函数是可以访问的;\r\n   f();             // 输出 xx indide\r\n   function f() { console.log(&#39;I am inside!&#39;); }\r\n }\r\n f();               // 输出 inside\r\n}());</code>\n        </deckgo-highlight-code>\n<p><strong>总结：</strong></p>\n<ul>\n<li>避免在块级作用域中声明函数，如果要声明也建议使用函数表达式而不是函数声明语句；</li>\n<li>ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</li>\n</ul>\n<ol start=\"4\">\n<li>const 声明复杂数据类型</li>\n</ol>\n<p>const 声明复合类型的变量，变量名指向数据的地址，因此 const 只保证该地址不会改变，但地址中的数据可以被改变；</p>\n<p>使用 Object.freeze(obj) 冻结 obj 对象；</p>\n<h1>全局对象 &#x26; 顶层对象</h1>\n<blockquote>\n<p>获取全局对象的三种方式：window、global、self</p>\n</blockquote>\n<ol>\n<li>global 只在 node 中才支持；</li>\n<li>window 只在浏览器环境中支持；</li>\n<li>self 在浏览器和 web worker 中支持；</li>\n</ol>\n<blockquote>\n<p>不同环境中 this 的指向：</p>\n</blockquote>\n<ol>\n<li>全局环境 this 指向全局对象，</li>\n<li>node 模块和 ES6 模块中，this 指向当前模块；</li>\n<li>函数中，指向调用对象或顶层对象、undefined(严格模式)；</li>\n</ol>\n<blockquote>\n<p>勉强能获取不同环境中的 全局对象</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function getGlobal() {\r\n  return global || self;\r\n}</code>\n        </deckgo-highlight-code>\n<p>在语言标准层面引入 global 作为顶层对象，即在所有环境中都存在 global 对象，垫片库<a href=\"https://github.com/ljharb/System.global\"><code>system.global</code></a>模拟了该方法，可以在所有环境拿到 <code>global</code>。</p>\n<h1>变量的解构赋值</h1>\n<ul>\n<li>从引用类型变量中提取部分数据(数组元素、对象属性值)赋值给新的变量；</li>\n<li>变量：复杂数据类型的变量(数组、对象)，要求是可遍历的结构，具有 Iterator 接口；</li>\n<li>赋值遵守模式匹配；</li>\n</ul>\n<p>数组和对象的解构赋值是一种<strong>模式匹配</strong>，要求等号两边的模式相匹配。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let {bar: bar, foo: foo} = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };\r\n// 简写为\r\nlet { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };\r\nimport {xx} from &#39;xxx&#39;;\r\nlet { log, sin, cos } = Math;\r\n\r\nlet foo;\r\n({foo} = {foo: 1});     // 成功, 必须用()包裹, 否则将被解析为代码块而不是赋值语句;只有不将大括号写在行首，避免JavaScript将其解释为代码块\r\n\r\nvar obj = {\r\n  p: [\r\n    &#39;Hello&#39;,\r\n    { y: &#39;World&#39; }\r\n  ]\r\n};\r\nvar { p: [x, { y }] } = obj;  // x: &quot;Hello&quot;, y: &quot;World&quot;</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>应用</p>\n</blockquote>\n<ol>\n<li>交换变量的值</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">[x, y] = [y, x];</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>函数返回多个值</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function example() {\r\n return [1, 2, 3];\r\n}\r\nvar [a, b, c] = example();</code>\n        </deckgo-highlight-code>\n<ol start=\"3\">\n<li>函数参数</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 参数是一组无次序的值\r\nfunction f({x, y, z}) { ... }\r\nf({z: 3, y: 2, x: 1});\r\n\r\nfunction ({mapState, content}){\r\n   // ...\r\n}</code>\n        </deckgo-highlight-code>\n<ol start=\"4\">\n<li>函数默认参数</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">jQuery.ajax = function (url, {\r\n  async = true,\r\n  beforeSend = function () {},\r\n  cache = true,\r\n  complete = function () {},\r\n  crossDomain = false,\r\n  global = true,\r\n  // ... more config\r\n}) {\r\n  // ... do stuff\r\n};</code>\n        </deckgo-highlight-code>\n<ol start=\"5\">\n<li>导入模块的指定方法</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code>\n        </deckgo-highlight-code>\n<h1>扩展运算符</h1>\n<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组；</p>\n<ul>\n<li>数组合并</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let arr1 = [1,2];\r\nlet arr2 = [3,4];\r\nlet arr3 = [...arr1, ...arr2];\r\n// arr3 = [1,2,3,4]</code>\n        </deckgo-highlight-code>\n<ul>\n<li>和解构赋值同时使用</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let arr = [1,2,3];\r\nlet [first, ...rest] = arr;\r\n// first = 1; rest = [2,3]</code>\n        </deckgo-highlight-code>\n<h1>标签模板</h1>\n<p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为【标签模板】功能（tagged template）。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">alert`123`;  // 调用alert 处理后面的字符串; 弹出 123;\r\n\r\n// styled-components\r\nstyled.dic`\r\n\tmargin: 0 auto;\r\n`;</code>\n        </deckgo-highlight-code>\n<h1>数组扩展</h1>\n<p><strong>类数组对象</strong>：本质特征就是要有 length 属性；</p>\n<ul>\n<li>将类数组对象和可遍历对象转换为数组</li>\n</ul>\n<ol>\n<li>\n<p>Array.from：可以转换类数组对象和可遍历对象；</p>\n</li>\n<li>\n<p><strong>扩展运算符</strong>：将数组转换为逗号分隔的列表，背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换；<code>[...arguments]</code>，扩展运算符后面跟的一定是数组(或类数组)；</p>\n</li>\n<li>\n<p>像 <code>{length: 2}</code> 这个对象就只能使用 <code>Array.from</code> 转换；</p>\n</li>\n</ol>\n<ul>\n<li>得到初始化的数组</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">Array.from({length: 5}, (v, i) =&gt; i);   // [0,1,2,3,4]\r\nArray.from({length: 3}, ele=&gt;0);        // [0,0,0]\r\nnew Array(3).fill(0);  // // [0,0,0]</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>数组扩展的内容</p>\n</blockquote>\n<ol>\n<li>Array.from</li>\n<li>Array.of</li>\n<li>实例的 copyWithin</li>\n<li>实例的 find() 、 findIndex() 和 fill();</li>\n<li>实例的 keys()、values() 和 entries()；返回遍历器对象；</li>\n<li>实例的 includes()</li>\n<li>数组的空位</li>\n</ol>\n<p>参考：<a href=\"http://caibaojian.com/es6/array.html\">数组扩展</a></p>\n<h1>函数的扩展</h1>\n<ol>\n<li>参数的默认值</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 写法一\r\nfunction m1({x = 0, y = 0} = {}) {\r\n  return [x, y];\r\n}\r\n\r\n// 写法二\r\nfunction m2({x, y} = { x: 0, y: 0 }) {\r\n  return [x, y];\r\n}\r\n// 推荐第一种\r\nm1({x: 1});  // [1, 0]\r\nm2({x: 1});  // [1, undefined]</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>length 属性：默认参数之前的参数的个数(预期传入的参数的个数)</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function fn(a, b=0, c){\r\n    //...\r\n}\r\n// fn.length: 1</code>\n        </deckgo-highlight-code>\n<ol start=\"3\">\n<li>剩余参数：必须位于参数列表的最后</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function fn(...args){\r\n  // args 是一个数组    \r\n}</code>\n        </deckgo-highlight-code>\n<ol start=\"4\">\n<li>箭头函数</li>\n</ol>\n<p>部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const pipeline = (...funcs) =&gt; initVal =&gt; funcs.reduce((acc, cur) =&gt; cur(acc), initVal);\r\n\r\nconst plus1 = a =&gt; a + 1;\r\nconst mult2 = a =&gt; a * 2;\r\nconst addThenMult = pipeline(plus1, mult2);\r\n\r\nconsole.log( addThenMult(2) ); // 6</code>\n        </deckgo-highlight-code>\n<ol start=\"5\">\n<li>函数绑定运算符(::)</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">foo::bar(...arguments);\r\n// 等同于\r\nbar.apply(foo, arguments);\r\n// 运算符左侧是指定的 this 对象, 右侧是函数</code>\n        </deckgo-highlight-code>\n<ol start=\"6\">\n<li>严格模式</li>\n</ol>\n<p>《ECMAScript 2016标准》规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。严格模式下也不能使用 arguments 和 callers</p>\n<ol start=\"7\">\n<li>尾调用优化</li>\n</ol>\n<p>ES6 下的<strong>尾调用优化</strong>只在严格模式下才有效；</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 将调用函数的操作放到当前函数执行的最后一步\r\nfunction fn(){\r\n    &quot;use strict&quot;\r\n    return g();\r\n}\r\nfunction fn(){\r\n    // 当前函数满足尾调用\r\n    if(xx){\r\n        return g();\r\n    }\r\n    else  return w();\r\n}\r\n\r\n// 下式不是尾调用优化, 因为函数默认 return undefined;\r\nfunction fn(){\r\n    g();\r\n    // return undefined;\r\n}</code>\n        </deckgo-highlight-code>\n<p>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行【尾调用优化】。下面的函数无法实现尾调用优化。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function addOne(a){\r\n  var one = 1;\r\n  function inner(b){\r\n    return b + one;\r\n  }\r\n  return inner(a);\r\n}</code>\n        </deckgo-highlight-code>\n<p><strong>尾递归优化示例</strong></p>\n<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 1. 阶乘\r\nfunction factorial(n) {\r\n  if (n === 1) return 1;\r\n  return n * factorial(n - 1);\r\n}\r\n// 优化后\r\nfunction factorial(n, total) {\r\n  if (n === 1) return total;\r\n  return factorial(n - 1, n * total);\r\n}\r\n\r\n// 2. fibonacci \r\nfunction Fibonacci (n) {\r\n  if ( n &lt;= 1 ) {return 1};\r\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\r\n}\r\n// 优化后\r\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\r\n  if( n &lt;= 1 ) {return ac2};\r\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\r\n}</code>\n        </deckgo-highlight-code>\n<p><a href=\"http://caibaojian.com/es6/function.html\">函数扩展</a></p>\n<h1>Class</h1>\n<blockquote>\n<p>例子</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class Person{\r\n  static staticProA = &#39;xxx&#39;;\r\n  static staticMethodA() {\r\n    // this 指向 Person，而不是实例\r\n  }\r\n  constructor(name, age){\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n  getName(){\r\n    return this.name;\r\n  }\r\n}\r\n/*\r\n* this 指向实例对象,\r\n* 类的方法(getName)定义在类的prototype(Person.prototype)上, 并且不可枚举;\r\n* 方法之间不需要逗号,\r\n*/</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>constructor</p>\n</blockquote>\n<p>类必须有一个 constructor 方法，若没有显示定义，默认的 constructor 为 <code>constructor(){}</code></p>\n<blockquote>\n<p>super</p>\n</blockquote>\n<ol>\n<li>在super方法调用前，不能使用this，因为 ES6 是先创建父类实例；</li>\n<li>作为函数调用，super 代表父类的构造函数，此时父类构造函数中的 <code>new.target</code> 为子类构造函数，并且作为函数调用时只能出现在子类的构造函数中；</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class A {}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    // 相当于 A.prototype.constructor.call(this);\r\n  }\r\n }</code>\n        </deckgo-highlight-code>\n<ol start=\"3\">\n<li>作为对象时，super 指向父类的原型，ES6 规定通过 <code>super</code> 调用父类的方法时，<code>super</code> 会绑定子类的<code>this</code>。</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class A {\r\n  p() {\r\n    return 2;\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    this.name = &#39;czl&#39;;\r\n    console.log(super.p()); // 调用 A的 方法, 该方法中的this 指向子类的实例,可以访问 this.name\r\n  }\r\n  p(){\r\n \t\treturn 100;\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>静态属性和静态方法</p>\n</blockquote>\n<p>父类中的静态属性和静态方法可以被子类继承</p>\n<blockquote>\n<p>私有属性</p>\n</blockquote>\n<p>私有属性不能被继承</p>\n<p>私有属性名必须在类实例和类本身上是唯一标识</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields</a></p>\n<p><a href=\"https://zh.javascript.info/private-protected-properties-methods\">https://zh.javascript.info/private-protected-properties-methods</a></p>\n<blockquote>\n<p>ES6 中Class 与 ES5 的区别</p>\n</blockquote>\n<ul>\n<li>函数存在声明提升，Class 不会；</li>\n<li>类内部默认开启严格模式；</li>\n<li>ES5 继承先创建子类实例，再调用父类构造函数，将属性和方法添加到子类实例上；ES6 是先创建父类实例，再通过子类的构造函数修改 this；</li>\n<li>Class 定义在原型上的方法是不可枚举的；</li>\n<li>Class 实现了子类的构造函数继承父类的构造函数（继承静态属性和方法）</li>\n</ul>\n<h1>Proxy</h1>\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种<strong>元编程</strong>，即对编程语言进行编程。<strong>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</strong>。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n<ol>\n<li>get(target, propKey, receiver)\r\n拦截对象属性的读取；</li>\n<li>set(target, propKey, value, receiver)\r\n拦截对象属性的赋值操作；</li>\n<li>has(target, propKey)\r\n拦截<code>propKey in proxy</code>的操作；</li>\n<li>apply(target, object, args)\r\n<code>apply</code>方法拦截函数的调用、call和apply操作；</li>\n</ol>\n<blockquote>\n<p>this 指向</p>\n</blockquote>\n<p>使用 Proxy 代理的情况下，目标对象内部的 <code>this</code> 关键字会指向 Proxy 代理。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const target = {\r\n  m: function () {\r\n    console.log(this === proxy);\r\n  }\r\n};\r\nconst handler = {};\r\nconst proxy = new Proxy(target, handler);\r\n\r\ntarget.m() // false\r\nproxy.m()  // true</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>使用 Proxy 实现观察者模式</p>\n</blockquote>\n<p>观察者模式（Observer mode）指的是观察者(函数)自动观察被观察者(数据对象)，一旦对象有变化，函数就会自动执行。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const person = observable({\r\n  name: &#39;张三&#39;,\r\n  age: 20\r\n});\r\nfunction print() {\r\n  console.log(`${person.name}, ${person.age}`)\r\n}\r\n\r\nobserve(print);\r\nperson.name = &#39;李四&#39;;  // // 李四, 20\r\n\r\n/*\r\n* observable 和 observe 实现;\r\n* observable 注册被观察者(数据对象);\r\n* obsere 注册观察者(数据更新时执行的函数);\r\n*/ \r\n\r\n// 观察者(函数)\r\nconst queuedObservers = new Set();\r\n\r\nconst observe = fn =&gt; queuedObservers.add(fn);\r\nconst observable = obj =&gt; new Proxy(obj, {set});\r\n\r\nfunction set(target, key, value, receiver) {\r\n  const result = Reflect.set(target, key, value, receiver);\r\n  queuedObservers.forEach(observer =&gt; observer());\r\n  return result;\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p><a href=\"https://github.com/GoogleChrome/proxy-polyfill\">proxy-polyfill</a></p>\n</blockquote>\n<h1>Reflect</h1>\n<blockquote>\n<p>使用 Reflect 来将操作转发给原始对象</p>\n</blockquote>\n<p><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code> 怎么修改默认行为，你总可以在 <code>Reflect</code> 上获取默认行为。</p>\n<p><strong>对于每个可被 <code>Proxy</code> 捕获的内部方法，在 <code>Reflect</code> 中都有一个对应的方法，其名称和参数与 <code>Proxy</code> 捕捉器相同。</strong></p>\n<h1>Iterator &#x26; 遍历器</h1>\n<p>遍历器生成函数接收一个可选的数据结构(如数组)，返回一个遍历器对象，该对象必须要有 <code>next</code> 方法，调用该函数会返回指定的数据结构中的下一个元素。for...of 根据遍历器对象依次访问元素。</p>\n<ul>\n<li>\n<p><strong>可遍历数据</strong>：部署了 iterator 接口，原生的数组、部分类数组对象、Set、Map的 <code>Symbol.iterator</code> 属性就是遍历器生成函数，最简单的实现方式就是 generator 函数。</p>\n</li>\n<li>\n<p>for...of、扩展运算符、解构赋值。</p>\n</li>\n</ul>\n<h1>Promise</h1>\n<ul>\n<li>\n<p>Promise是异步编程的一种解决方案，比传统的解决方案—<strong>回调函数和事件</strong>更合理和更强大；</p>\n</li>\n<li>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。Promise提供then方法加载回调函数，使用then方法以后，异步任务的两段执行看得更清楚了；</p>\n</li>\n<li>\n<p>Promise就是为了解决回调地狱而提出的，它不是新的语法功能，而是一种<strong>新的写法</strong>，允许将回调函数的嵌套，改成链式调用；</p>\n</li>\n<li>\n<p>Promise 创建后会立即执行</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let promise = new Promise(function(resolve, reject) {\r\n  // 需要执行的异步操作, 立即执行\r\n  // 异步操作失败时执行 reject, 成功执行 resolve,\r\n  // resolve 和 reject 会将数据以实参的形式传递出去;\r\n  console.log(&#39;Promise&#39;);\r\n  setTimeout(resolve, ms, &#39;done&#39;);  \r\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>then</code> 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</li>\n</ul>\n<h2>Promise 读取文件</h2>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let read = require(&#39;read-file&#39;);\r\nfunction readFile(name) {\r\n  return new Promise((resolve, reject) =&gt; {\r\n    // 1. 第1步\r\n    read(name, &#39;utf-8&#39;, (error, data) =&gt; {\r\n      if (error) reject(error);\r\n      else resolve(data);\r\n    });\r\n  });\r\n}\r\n\r\nreadFile(&#39;name2.txt&#39;)\r\n\t// 2. 第2步\r\n  .then(data =&gt; readFile(data))\r\n\t// 3. 第3步\r\n  .then(data =&gt; {  \t\t\r\n      console.log(`1-s: ${data}`);\r\n      return 123;\r\n    },\r\n    error =&gt; {\r\n      console.log(`1-e: ${error}`);\r\n      return 0;\r\n    })\t\r\n  .then(data =&gt; console.log(`2-s: ${data}`),\r\n    error =&gt; console.log(`2-e: ${error}`))\r\n  .then(data =&gt; console.log(`3-s: ${data}`),\r\n    error =&gt; console.log(`3-e: ${error}`));\r\n/*\r\n 执行流程\r\n 1. 执行第一步, 通过 resolve(data) 或 reject(error) 传递数据, 并且返回一个 promise 实例;\r\n 2. 执行第二步, 根据上一步是成功或失败, 执行 then 的成功回调或失败回调; 如果上一步返回的是 promise 实例,\r\n    则回调函数的参数来自于 resolve(data) 或 reject(error) 的实参;\r\n    如果上一步返回的不是 promise 实例, 则回调函数的参数来自于上一步 return 的值。 \r\n*/</code>\n        </deckgo-highlight-code>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&#x26;mid=2247484260&#x26;idx=1&#x26;sn=0bc8a7aed8b15d3cc7e75c76394b648a&#x26;chksm=c06682f2f7110be41b29ce0eabc441fba11e1ab306ca40e4e7d81d338b4af7e35721573d1cca&#x26;mpshare=1&#x26;scene=1&#x26;srcid=&#x26;sharer_sharetime=1566171898757&#x26;sharer_shareid=c0fa4bb765d12545f4439ab827814978&#x26;key=56eb82a42460d979c3afc63a4f31177e13db16329cf4763c707bf96642e8906b81d68c0b03fa52eaabde20326b79c31368a9de23b389122e084df4a3c4aa327001973a319a1020fe8e99f6a26930b5b9&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060833&#x26;lang=zh_CN&#x26;pass_ticket=D8igzih7KnA8%2F5LHQdRG6th5IVXvvQD7ukUD5HSt%2FLcfZ7gOforYJWqBjo9rYF%2FC\">你了解Promise吗-segmentfault</a></li>\n<li><a href=\"https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4\">Promse A+ 规范</a></li>\n<li><a href=\"https://juejin.im/post/5b83cb5ae51d4538cc3ec354\">Promise 实现原理-掘金</a></li>\n</ul>\n<h1>Generator</h1>\n<p>Generator函数是ES6提供的一种异步编程解决方案，执行Generator函数会返回一个<strong>遍历器对象</strong>，即 Generator 是迭代器生成函数。</p>\n<p>从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>\n<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>\n<p>Generator函数有多种理解角度：</p>\n<ul>\n<li>\n<p>Generator函数是一个状态机，封装了多个内部状态。</p>\n</li>\n<li>\n<p>形式上，Generator函数是一个普通函数，但是有两个特征。</p>\n<ol>\n<li><code>function</code> 关键字与函数名之间有一个星号；</li>\n<li>函数体内部使用 <strong>yield</strong> 语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。</li>\n</ol>\n</li>\n<li>\n<p>例如</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function* foo(x) {\r\n  log(&#39;start&#39;);\r\n  var y = 2 * (yield (x + 1));\r\n  var z = yield (y);\r\n  return (x + y + z);\r\n}\r\nvar hw = foo(1);  // 执行该行不会输出 start\r\nhw.next();   // { value: 2, done: false }\r\nhw.next(3);  // { value: 6, done: false }</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>yield</p>\n</blockquote>\n<ul>\n<li>遇到 <code>yield</code> 语句，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值。</li>\n<li>yield 表达式(如：yield(x+1)) 的返回值是 undefined，通过 hw.next(val)可以设置上次 yield 表达式的返回值；</li>\n</ul>\n<p style=\"color:red;font-weight:bold\">核心：yield 暂停执行，next 继续执行</p>\n<blockquote>\n<p>返回值: iterator 遍历器对象</p>\n</blockquote>\n<p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的<code>prototype</code>对象上的方法。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function* g() {};\r\ng.prototype.hello = function () {\r\n  return &#39;hi!&#39;;\r\n};\r\n\r\nlet iter = g();\r\n\r\niter instanceof g // true\r\niter.hello()      // &#39;hi!&#39;\r\n// 生成器函数g()返回的迭代器对象 iter 是 g 的实例，并且继承了 g.prototype 上的方法;\r\n// g() 类似于构造函数, 但又不是，g() 返回的不是 this, this === global;</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>将 Generator 封装为构造函数并 在 Generator 中使用 this</p>\n</blockquote>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function* gen() {\r\n  this.a = 1;\r\n  yield this.b = 2;\r\n  yield this.c = 3;\r\n}\r\n\r\nfunction F() {\r\n  return gen.call(gen.prototype);\r\n}\r\n\r\nvar f = new F();\r\n\r\nf.next();  // Object {value: 2, done: false}\r\nf.next();  // Object {value: 3, done: false}\r\nf.next();  // Object {value: undefined, done: true}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p><code>yield*</code></p>\n</blockquote>\n<p><code>yield*</code> 遍历遍历器对象，任何有 Iterator 接口的数据结构都可以被 <code>yield*</code> 遍历</p>\n<p>用来在一个Generator函数里面执行另一个Generator函数。</p>\n<h2>异步 Generator</h2>\n<p>异步 Generator 生成 异步的 Iterator ，异步 Iterator 的 next() 方法返回的是一个 Promise</p>\n<p>异步 Generator 的 yield 产出的是 Promise 对象或 Thunk ，即异步生成器创建的迭代器的 next() 方法返回的是 Promise</p>\n<h2>应用</h2>\n<ol>\n<li>异步操作的同步表达；</li>\n<li>控制流管理；</li>\n<li>部署 Iterator 接口；</li>\n<li>作为数据结构：类数组结构</li>\n</ol>\n<blockquote>\n<p>遍历二叉树</p>\n</blockquote>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 下面是二叉树的构造函数，\r\n// 三个参数分别是左树、当前节点和右树\r\nfunction Tree(left, label, right) {\r\n  this.left = left;\r\n  this.label = label;\r\n  this.right = right;\r\n}\r\n\r\n// 下面是中序（inorder）遍历函数。\r\n// 由于返回的是一个遍历器，所以要用generator函数。\r\n// 函数体内采用递归算法，所以左树和右树要用yield*遍历\r\nfunction* inorder(t) {\r\n  if (t) {\r\n    yield* inorder(t.left);\r\n    yield t.label;\r\n    yield* inorder(t.right);\r\n  }\r\n}\r\n\r\n// 下面生成二叉树\r\nfunction make(array) {\r\n  // 判断是否为叶节点\r\n  if (array.length == 1) return new Tree(null, array[0], null);\r\n  return new Tree(make(array[0]), array[1], make(array[2]));\r\n}\r\nlet tree = make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]);\r\n\r\n// 遍历二叉树\r\nvar result = [];\r\nfor (let node of inorder(tree)) {\r\n  result.push(node);\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>参考</p>\n</blockquote>\n<p><a href=\"http://caibaojian.com/es6/generator.html\">Generatot函数</a></p>\n<h1>async &#x26; await</h1>\n<p><strong>async 函数就是 Generator 函数的语法糖</strong>。用 <code>async</code> 替换 Generator 函数声明中的 <code>*</code>，用 <code>await</code> 替换 <code>yield</code></p>\n<p>await 命令只能出现在 async 函数中，await 表达式会暂停当前 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\"><code>async function</code></a> 的执行，等待其后面表达式的结果，像 Generateor 函数一样将执行权转让给其他程序；</p>\n<ul>\n<li>async 定义一个通过事件循环异步执行的异步函数，该函数隐式返回一个 Promise 对象，可以用<code>then</code>方法指定下一步的操作。</li>\n<li><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数；</li>\n<li><code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</li>\n<li><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，才会执行<code>then</code>方法指定的回调函数，除非遇到<code>return</code>语句或者抛出错误。</li>\n</ul>\n<blockquote>\n<p>result = await 表达式</p>\n</blockquote>\n<p>When an <code>await</code> is encountered in code (either in an async function or in a module), the awaited expression is executed, while all code that depends on the expression's value is paused and pushed into the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\">microtask queue</a>. The main thread is then freed for the next task in the event loop. This happens even if the awaited value is an already-resolved promise or not a promise.</p>\n<p>当在 async 函数或 module 顶层中遇到 await 运算符，await 后面的表达式立即执行，await 语句后面的语句加入到【微任务】队列中，即使 await 表达式是 already-resolved promise or not a promise。</p>\n<ul>\n<li>\n<p>await 等待一个Promise对象，await 表达式的值就是 Promise 处理的结果，若表达式不是 Promise，</p>\n</li>\n<li>\n<p>则返回表达式本身的值；</p>\n</li>\n<li>\n<p>await 会暂停异步函数(async 函数)的执行（无论表示的是否是 Promise-like），调用async函数的上层函数会继续执行(收到异步函数返回的隐式Promise)</p>\n</li>\n<li>\n<p>若 await 后面的表达式的值不是 Promise 或 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables\">thneables</a> ，则用 Promise.resolve() 包装\r\nIf the value is not a <code>Promise</code>, <code>await</code> converts the value to a resolved <code>Promise</code>, and waits for it.</p>\n</li>\n<li>\n<p>若 await 后面的表达式的值是Promise，且 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\"><code>async function</code></a>。</p>\n</li>\n<li>\n<p>若 await 后面的表达式的值是Promise，且  Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。所以最好将await命令放在<code>try catch</code>中</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">async function myFunction() {\r\n  try {\r\n    await somethingThatReturnsAPromise();\r\n  } catch (err) {\r\n    console.log(err);\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>async 实现</p>\n</blockquote>\n<p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function spawn(genF) {\r\n  return new Promise(function (resolve, reject) {\r\n    const gen = genF();\r\n    function step(nextF) {\r\n      let next;\r\n      try {\r\n        next = nextF();\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      if (next.done) {\r\n        return resolve(next.value);\r\n      }\r\n      Promise.resolve(next.value).then(\r\n        function (v) {\r\n          step(function () {\r\n            return gen.next(v);\r\n          });\r\n        },\r\n        function (e) {\r\n          step(function () {\r\n            return gen.throw(e);\r\n          });\r\n        }\r\n      );\r\n    }\r\n    \r\n    step(function () {\r\n      return gen.next(undefined);\r\n    });\r\n  });\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>参考</p>\n</blockquote>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\">MDN-aync</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await\">MDN-await</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000007535316\">理解 JavaScript 的 async/await</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&#x26;mid=2650215577&#x26;idx=1&#x26;sn=0edb4be37430e17ba1029ab3b1a36a57&#x26;chksm=befe14b889899daea69684da9ac22613cfef5e534f920a194a640f21ab5ec839d498642ed455&#x26;scene=0&#x26;key=6deb43fc298651d2935752bd2c9f8fa907d71cfcf410807341a1a420ced46efe20f453fa8f835874ef05bec5deefb1be9a1a136a7027e798b32030bded88d257b46b8f1442a2b56ac165cfaa80db49f5&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060720&#x26;lang=zh_CN&#x26;pass_ticket=Pn9cJyIWK2xt%2BmQltkMddf4S5oGoplFdiJ%2B16Yj6gD8L9Zd0WMlQ1u32%2FRJtZE1p\">async &#x26; await 面试题</a></li>\n<li><a href=\"https://gongchenghuigch.github.io/2019/09/14/awat/\">setTimeout promise async</a></li>\n</ul>\n<h1>异步编程</h1>\n<p>ES6诞生以前，异步编程的方法，大概有下面四种：回调、事件监听、Promise对象</p>\n<p><a href=\"http://caibaojian.com/es6/async.html\">异步编程</a></p>\n<h1>模块</h1>\n<ul>\n<li>import 命令具有提升效果，import 是在编译阶段执行的，在代码运行之前。</li>\n<li><code>import</code>语句会执行所加载的模块</li>\n<li><code>import</code>语句是 Singleton 模式，多次import 同一个模块只会导入一次，也只会执行一次模块中的全局代码</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">import {A} from &#39;mode&#39;\r\nimport {A} from &#39;mode&#39;\r\n\r\n// 等价于 \r\nimport {A, B} from &#39;mode&#39;</code>\n        </deckgo-highlight-code>","id":"54e78853-7239-5f71-8710-e7305ca33bf5","parent":{"name":"ES6","base":"ES6.md","mtime":"2023-04-09T14:01:38.000Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/前端/JS/ES6/"}},"staticQueryHashes":["3957182205"]}