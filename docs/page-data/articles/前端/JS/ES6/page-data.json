{"componentChunkName":"component---src-templates-post-js","path":"/articles/前端/JS/ES6/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/前端/JS/ES6/"},"html":"<h5><a href=\"https://es6.ruanyifeng.com/#docs/class\">ES6入门-阮一峰</a></h5>\n<h5>const let</h5>\n<ol>\n<li>\n<p>const 和 let 都不存在变量提升；都存在暂时性死区；</p>\n<ul>\n<li>暂时性死区：在块级作用域中被 let 和 const 声明的变量从进入块级作用域就绑定了，不能在 let 或 const 声明语句之前使用 var 或者 没有 var 声明及使用该变量；因此在 let 和 const 声明语句之前(死区)不能以任何形式出现该变量，并且 typeof 也不是一定安全的操作(在没有 let 和 const 之前，typeof 一定不会产生错误)。</li>\n<li>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</li>\n</ul>\n</li>\n<li>不能重复声明；</li>\n<li>var 声明的全局变量作为顶层对象( window\\global )的属性，let 和 const 声明的变量不会；</li>\n<li>\n<p>块级作用域中的函数声明</p>\n<ul>\n<li>ES5 规定函数声明只能在全局或函数作用域中，不能在块级作用域(ES5 没有块级作用域)；但浏览器没有遵守该规定，ES5 环境下，在块级作用域中声明的函数存在声明提升，等同于函数表达式(声明提升，值为 undefined)；</li>\n<li>ES6 引入块级作用域，允许在块级作用域中声明函数；</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// ES6严格模式\n&#39;use strict&#39;;\nif (true) {\n  function f() {}\n}\n// 不报错</code>\n        </deckgo-highlight-code>\n<p> ES6 规定块级作用域中的函数声明语句的行为类似于 let，在块级作用域之外不可引用；</p>\n<ul>\n<li>为了减少兼容性问题，浏览器可以不遵守 ES6 的规定，在 ES6 环境下的浏览器中的行为方式：</li>\n<li>可以在块级作用域中声明函数，但会像对待 var 语句一样(而不是 let)，将函数的声明提升至函数作用域的顶部(只是声明，尚未赋值)；在块级作用域中该函数都是可用的。</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// ES6的浏览器环境, 此处为全局作用域\nfunction f() { \n  console.log(&#39;I am outside!&#39;); \n}\n(function () {\n  // 此处为函数作用域  \n  // var f = undefined; 该语句是块级作用域中的函数声明部分提升至此;\n  typeof f;           // undefined \n  if (true) {\n    // 此处为块级作用域, 在该作用域中函数是可以访问的;\n    f();             // 输出 xx indide  \n    function f() { console.log(&#39;I am inside!&#39;); }\n  }\n  f();               // 输出 inside\n}());</code>\n        </deckgo-highlight-code>\n<ul>\n<li>总结：</li>\n<li>避免在块级作用域中声明函数，如果要声明也建议使用函数表达式而不是函数声明语句；</li>\n<li>ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</li>\n</ul>\n</li>\n<li>\n<p>const 声明复杂数据类型</p>\n<ul>\n<li>const 声明复合类型的变量，变量名指向数据的地址，因此 const 只保证该地址不会改变，但地址中的数据可以被改变；</li>\n<li>使用 Object.freeze(obj) 冻结 obj 对象；</li>\n</ul>\n</li>\n</ol>\n<h5>全局对象 &#x26; 顶层对象</h5>\n<ul>\n<li>\n<p>获取全局对象的三种方式：window、global、self</p>\n<ol>\n<li>global 也只在 node 中才支持；</li>\n<li>window 只在浏览器环境中支持；</li>\n<li>self 在浏览器和 web worker 中支持；</li>\n</ol>\n</li>\n<li>\n<p>不同环境中 this 的指向：</p>\n<ol>\n<li>全局环境 this 指向全局对象，</li>\n<li>node 模块和 ES6 模块中，this 指向当前模块；</li>\n<li>函数中，指向调用对象或顶层对象、undefined(严格模式)；</li>\n</ol>\n</li>\n<li>\n<p>勉强能获取不同环境中的 全局对象</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 方法1\n(typeof window !== &#39;undefined&#39;\n ? window\n : (typeof process === &#39;object&#39; &amp;&amp;\n    typeof require === &#39;function&#39; &amp;&amp;\n    typeof global === &#39;object&#39;)\n   ? global\n   : this);\n// 方法2\nvar getGlobal = function () {\nif (typeof self !== &#39;undefined&#39;) { return self; }\nif (typeof window !== &#39;undefined&#39;) { return window; }\nif (typeof global !== &#39;undefined&#39;) { return global; }\nthrow new Error(&#39;unable to locate global object&#39;);\n};</code>\n        </deckgo-highlight-code>\n<ul>\n<li>在语言标准层面引入 global 作为顶层对象，即在所有环境中都存在 global 对象，垫片库<a href=\"https://github.com/ljharb/System.global\"><code>system.global</code></a>模拟了该方法，可以在所有环境拿到 <code>global</code>。</li>\n</ul>\n</li>\n</ul>\n<h5>变量的解构赋值</h5>\n<ul>\n<li>从复杂数据变量中提取部分数据(数组元素、对象属性值)赋值给新的变量；</li>\n<li>变量：复杂数据类型的变量(数组、对象)，要求是可遍历的结构，具有 Iterator 接口；</li>\n<li>赋值遵守模式匹配；</li>\n</ul>\n<p>数组和对象的解构赋值是一种<strong>模式匹配</strong>，要求等号两边的模式相匹配。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let {bar: bar, foo: foo} = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };\n// 简写为\nlet { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };\nimport {xx} from &#39;xxx&#39;;\nlet { log, sin, cos } = Math;\n\nlet foo;\n({foo} = {foo: 1});     // 成功, 必须用()包裹, 否则将被解析为代码块而不是赋值语句;只有不将大括号写在行首，避免JavaScript将其解释为代码块\n\nvar obj = {\n  p: [\n    &#39;Hello&#39;,\n    { y: &#39;World&#39; }\n  ]\n};\nvar { p: [x, { y }] } = obj;  // x: &quot;Hello&quot;, y: &quot;World&quot;</code>\n        </deckgo-highlight-code>\n<p><strong>用途</strong>：</p>\n<ol>\n<li>\n<p>交换变量的值</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">[x, y] = [y, x];</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数返回多个值</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function example() {\n return [1, 2, 3];\n}\nvar [a, b, c] = example();</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数参数</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n\nfunction ({mapState, content}){\n   // ...\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数默认参数</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">jQuery.ajax = function (url, {\n async = true,\n beforeSend = function () {},\n cache = true,\n complete = function () {},\n crossDomain = false,\n global = true,\n // ... more config\n}) {\n // ... do stuff\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>导入模块的指定方法</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code>\n        </deckgo-highlight-code>\n</li>\n</ol>\n<h5>扩展运算符</h5>\n<blockquote>\n<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组；</p>\n</blockquote>\n<ul>\n<li>\n<p>demo\n数组合并</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let arr1 = [1,2];\nlet arr2 = [3,4];\nlet arr3 = [...arr1, ...arr2];\n// arr3 = [1,2,3,4]</code>\n        </deckgo-highlight-code>\n<p>和解构赋值同时使用</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let arr = [1,2,3];\nlet [first, ...rest] = arr;\n// first = 1; rest = [2,3]</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5>字符串扩展</h5>\n<h6>标签模板</h6>\n<p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">alert`123`;  // 调用alert 处理后面的字符串; 弹出 123;\n\n// styled-components\nstyled.dic`\n\tmargin: 0 auto;\n`;</code>\n        </deckgo-highlight-code>\n<h5>数组扩展</h5>\n<p><strong>类数组对象</strong>：本质特征就是要有 length 属性；</p>\n<ul>\n<li>\n<p>将类数组对象和可遍历对象转换为数组</p>\n<ol>\n<li>Array.from：可以转换类数组对象和可遍历对象；</li>\n<li><strong>扩展运算符</strong>：将数组转换为逗号分隔的列表，背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换；<code>[...arguments]</code>，扩展运算符后面跟的一定是数组(或类数组)；</li>\n<li>像 <code>{length: 2}</code> 这个对象就只能使用 <code>Array.from</code> 转换；</li>\n</ol>\n</li>\n<li>\n<p>得到初始化的数组</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">Array.from({length: 5}, (v, i) =&gt; i);   // [0,1,2,3,4]\nArray.from({length: 3}, ele=&gt;0);        // [0,0,0]\nnew Array(3).fill(0);  // // [0,0,0]</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p><strong>数组扩展的内容：</strong></p>\n<ol>\n<li>Array.from</li>\n<li>Array.of</li>\n<li>实例的 copyWithin</li>\n<li>实例的 find() 、 findIndex() 和 fill();</li>\n<li>实例的 keys()、values() 和 entries()；返回遍历器对象；</li>\n<li>实例的 includes()</li>\n<li>数组的空位</li>\n</ol>\n<p>参考：<a href=\"http://caibaojian.com/es6/array.html\">数组扩展</a></p>\n<h5>函数的扩展</h5>\n<ol>\n<li>\n<p>参数的默认值</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 写法一\nfunction m1({x = 0, y = 0} = {}) {\n return [x, y];\n}\n\n// 写法二\nfunction m2({x, y} = { x: 0, y: 0 }) {\n return [x, y];\n}\n// 推荐第一种\nm1({x: 1});  // [1, 0]\nm2({x: 1});  // [1, undefined]</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>length 属性：默认参数之前的参数的个数(预期传入的参数的个数)</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function fn(a, b=0, c){\n   //...\n}\n// fn.length: 1</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>剩余参数：必须位于参数列表的最后</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function fn(...args){\n   // args 是一个数组    \n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>箭头函数\n部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const pipeline = (...funcs) =&gt;\n   initVal =&gt; funcs.reduce((a, b) =&gt; b(a), initVal);\n\nconst plus1 = a =&gt; a + 1;\nconst mult2 = a =&gt; a * 2;\nconst addThenMult = pipeline(plus1, mult2);\n\nconsole.log( addThenMult() );  // 12</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>函数绑定运算符(::)</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">foo::bar(...arguments);\n// 等同于\nbar.apply(foo, arguments);\n// 运算符左侧是指定的 this 对象, 右侧是函数</code>\n        </deckgo-highlight-code>\n</li>\n<li>严格模式\n《ECMAScript 2016标准》规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。严格模式下也不能使用 arguments 和 callers</li>\n<li>\n<p>尾调用优化</p>\n<p>ES6 下的<strong>尾调用优化</strong>只在严格模式下才有效；</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 将调用函数的操作放到当前函数执行的最后一步\nfunction fn(){\n   &quot;use strict&quot;\n   return g();\n}\nfunction fn(){\n   // 当前函数满足尾调用\n   if(xx){\n       return g();\n   }\n   else  return w();\n}\n\n// 下式不是尾调用优化, 因为函数默认 return undefined;\nfunction fn(){\n   g();\n   // return undefined;\n}</code>\n        </deckgo-highlight-code>\n<p>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行 “尾调用优化”。下面的函数无法实现尾调用优化。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function addOne(a){\n var one = 1;\n function inner(b){\n   return b + one;\n }\n return inner(a);\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>尾递归优化示例\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 1. 阶乘\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n// 优化后\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\n// 2. fibonacci \nfunction Fibonacci (n) {\n  if ( n &lt;= 1 ) {return 1};\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n// 优化后\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n &lt;= 1 ) {return ac2};\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n}</code>\n        </deckgo-highlight-code>\n<p>参考：<a href=\"http://caibaojian.com/es6/function.html\">函数扩展</a></p>\n</li>\n</ol>\n<h5>Class</h5>\n<ul>\n<li>\n<p>例子</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class Person{\nconstructor(name, age){\n  this.name = name;\n  this.age = age;\n}\ngetName(){\n  return this.name;\n}\n}\n/*\n* this 指向实例对象,\n* 类的方法(getName)定义在类的prototype(Person.prototype)上, 并且不可枚举;\n* 方法之间不需要逗号,\n*/</code>\n        </deckgo-highlight-code>\n</li>\n<li>constructor\n类必须有一个 constructor 方法，若没有显示定义，默认的 constructor 为 <code>constructor(){}</code></li>\n<li>\n<p>super</p>\n<ol>\n<li>在super方法调用前，不能使用this，因为 ES6 是先创建父类实例；</li>\n<li>作为函数调用，super 指向父类的构造函数，并且作为函数调用时只能出现在子类的构造函数中；</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class A {}\n\nclass B extends A {\n  constructor() {\n    super();\n    // 相当于 A.prototype.constructor.call(this);\n  }\n}</code>\n        </deckgo-highlight-code>\n<ol start=\"3\">\n<li>作为对象时，super 指向父类的原型；ES6 规定，通过 <code>super</code> 调用父类的方法时，<code>super</code> 会绑定子类的<code>this</code>。</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">class A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.name = &#39;czl&#39;;\n    console.log(super.p()); // 调用 A的 方法, 该方法中的this 指向子类的实例,可以访问 this.name\n  }\n  p(){\n \t\treturn 100;\n  }\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>ES6 中Class 与 ES5 的区别</p>\n<ul>\n<li>函数存在声明提升，Class 不会；</li>\n<li>类内部默认开启严格模式；</li>\n<li>ES5 继承先创建子类实例，再调用父类构造函数，将属性和方法添加到子类实例上；ES6 是先创建父类实例，再通过子类的构造函数修改 this；</li>\n<li>Class 定义在原型上的方法是不可枚举的；</li>\n<li>Class 实现了子类的构造函数继承父类的构造函数；</li>\n</ul>\n</li>\n</ul>\n<h5>Proxy &#x26; Reflect</h5>\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种<strong>元编程</strong>，即对编程语言进行编程。<strong>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</strong>Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n<ol>\n<li>get(target, propKey, receiver)\n拦截对象属性的读取；</li>\n<li>set(target, propKey, value, receiver)\n拦截对象属性的赋值操作；</li>\n<li>has(target, propKey)\n拦截<code>propKey in proxy</code>的操作；</li>\n<li>apply(target, object, args)\n<code>apply</code>方法拦截函数的调用、call和apply操作；</li>\n</ol>\n<p><strong>this 指向</strong>：</p>\n<ul>\n<li>\n<p>使用 Proxy 代理的情况下，目标对象内部的 <code>this</code> 关键字会指向 Proxy 代理。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const target = {\nm: function () {\n  console.log(this === proxy);\n}\n};\nconst handler = {};\nconst proxy = new Proxy(target, handler);\n\ntarget.m() // false\nproxy.m()  // true</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h6>Reflect</h6>\n<p><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code> 怎么修改默认行为，你总可以在 <code>Reflect</code> 上获取默认行为。</p>\n<h5>使用 Proxy 实现观察者模式</h5>\n<p>观察者模式（Observer mode）指的是观察者(函数)自动观察被观察者(数据对象)，一旦对象有变化，函数就会自动执行。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const person = observable({\n  name: &#39;张三&#39;,\n  age: 20\n});\nfunction print() {\n  console.log(`${person.name}, ${person.age}`)\n}\n\nobserve(print);\nperson.name = &#39;李四&#39;;  // // 李四, 20\n\n/*\n* observable 和 observe 实现;\n* observable 注册被观察者(数据对象);\n* obsere 注册观察者(数据更新时执行的函数);\n*/ \n\n// 观察者(函数)\nconst queuedObservers = new Set();\n\nconst observe = fn =&gt; queuedObservers.add(fn);\nconst observable = obj =&gt; new Proxy(obj, {set});\n\nfunction set(target, key, value, receiver) {\n  const result = Reflect.set(target, key, value, receiver);\n  queuedObservers.forEach(observer =&gt; observer());\n  return result;\n}</code>\n        </deckgo-highlight-code>\n<h5>Iterator &#x26; 遍历器</h5>\n<p>遍历器生成函数接收一个可选的数据结构(如数组)，返回一个遍历器对象，该对象必须要有 <code>next</code> 方法，且 <code>next</code> 属性的值是一个函数，调用该函数会返回指定的数据结构中的下一个元素。for...of 根据遍历器对象依次访问元素。</p>\n<ul>\n<li><strong>可遍历数据</strong>：部署了 iterator 接口，原生的数组、部分类数组对象、Set、Map的 <code>Symbol.iterator</code> 属性就是遍历器生成函数，最简单的实现方式就是 generator 函数。</li>\n<li>for...of、扩展运算符、解构赋值；</li>\n</ul>\n<h5>Generator</h5>\n<p>Generator函数是ES6提供的一种异步编程解决方案，执行Generator函数会返回一个<strong>遍历器对象</strong>；</p>\n<p>Generator函数有多种理解角度：</p>\n<ul>\n<li>Generator函数是一个状态机，封装了多个内部状态。</li>\n<li>\n<p>形式上，Generator函数是一个普通函数，但是有两个特征。</p>\n<ol>\n<li><code>function</code> 关键字与函数名之间有一个星号；</li>\n<li>函数体内部使用 <strong>yield</strong> 语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。</li>\n</ol>\n</li>\n<li>\n<p>例如</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function* foo(x) {\nvar y = 2 * (yield (x + 1));\nvar z = yield (y);\nreturn (x + y + z);\n}\nvar hw = foo(1);\nhw.next();   // { value: 2, done: false }\nhw.next(3);  // { value: 6, done: false }</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p><strong>yield：</strong></p>\n<ul>\n<li>遇到 <code>yield</code> 语句，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值。</li>\n<li>yield 表达式(如：yield(x+1)) 的返回值是 undefined，通过 hw.next(val)可以设置上次 yield 表达式的返回值；</li>\n</ul>\n<p><strong>this &#x26; 原型对象：</strong></p>\n<ul>\n<li>\n<p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的<code>prototype</code>对象上的方法。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function* g() {}\ng.prototype.hello = function () {\nreturn &#39;hi!&#39;;\n};\n\nlet iter = g();\n\niter instanceof g // true\niter.hello()      // &#39;hi!&#39;\n// 生成器函数g()生成的迭代器对象 iter 是 g 的实例，并且继承了 g.prototype 上的方法;\n// g() 类似于构造函数, 但又不是;g() 返回的不是 this, this === global;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h6>异步Generator</h6>\n<blockquote>\n<p>异步 Generator 生成 异步的 Iterator ，异步 Iterator 的 next() 方法返回的是一个 Promise；</p>\n<p>异步 Generator 的 yield 产出的是 Promise 对象或 Thunk ，即异步生成器创建的迭代器的 next() 方法返回的是 Promise；</p>\n</blockquote>\n<h6>应用</h6>\n<ol>\n<li>异步操作的同步表达；</li>\n<li>控制流管理；</li>\n<li>部署 Iterator 接口；</li>\n<li>作为数据结构； </li>\n</ol>\n<h6>参考：</h6>\n<ul>\n<li><a href=\"http://caibaojian.com/es6/generator.html\">Generatot函数</a></li>\n</ul>\n<h5>Promise</h5>\n<ul>\n<li>Promise是异步编程的一种解决方案，比传统的解决方案—<strong>回调函数和事件</strong>更合理和更强大；</li>\n<li>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。Promise提供then方法加载回调函数，使用then方法以后，异步任务的两段执行看得更清楚了；</li>\n<li>Promise就是为了解决回调地狱而提出的，它不是新的语法功能，而是一种<strong>新的写法</strong>，允许将回调函数的嵌套，改成链式调用；</li>\n<li>\n<p>Promise 创建后会立即执行</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let promise = new Promise(function(resolve, reject) {\n// 需要执行的异步操作, 立即执行\n// 异步操作失败时执行 reject, 成功执行 resolve,\n// resolve 和 reject 会将数据以实参的形式传递出去;\nconsole.log(&#39;Promise&#39;);\nsetTimeout(resolve, ms, &#39;done&#39;);  \n});</code>\n        </deckgo-highlight-code>\n</li>\n<li><code>then</code> 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</li>\n</ul>\n<h6>Promise 读取文件</h6>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let read = require(&#39;read-file&#39;);\nfunction readFile(name) {\n  return new Promise((resolve, reject) =&gt; {\n    // 1. 第1步\n    read(name, &#39;utf-8&#39;, (error, data) =&gt; {\n      if (error) reject(error);\n      else resolve(data);\n    });\n  });\n}\n\nreadFile(&#39;name2.txt&#39;)\n\t// 2. 第2步\n  .then(data =&gt; readFile(data))\n\t// 3. 第3步\n  .then(data =&gt; {  \t\t\n      console.log(`1-s: ${data}`);\n      return 123;\n    },\n    error =&gt; {\n      console.log(`1-e: ${error}`);\n      return 0;\n    })\t\n  .then(data =&gt; console.log(`2-s: ${data}`),\n    error =&gt; console.log(`2-e: ${error}`))\n  .then(data =&gt; console.log(`3-s: ${data}`),\n    error =&gt; console.log(`3-e: ${error}`));\n/*\n 执行流程\n 1. 执行第一步, 通过 resolve(data) 或 reject(error) 传递数据, 并且返回一个 promise 实例;\n 2. 执行第二步, 根据上一步是成功或失败, 执行 then 的成功回调或失败回调; 如果上一步返回的是 promise 实例,\n    则回调函数的参数来自于 resolve(data) 或 reject(error) 的实参;\n    如果上一步返回的不是 promise 实例, 则回调函数的参数来自于上一步 return 的值。 \n */</code>\n        </deckgo-highlight-code>\n<h6>Promise 实现 Ajax请求</h6>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">var getJSON = function(url) {\n  var promise = new Promise(function(resolve, reject){\n    var client = new XMLHttpRequest();\n    client.open(&quot;GET&quot;, url);\n    client.onreadystatechange = handler;\n    client.responseType = &quot;json&quot;;\n    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);\n    client.send();\n\n    function handler() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n  });\n\n  return promise;\n};\n\ngetJSON(&quot;/posts.json&quot;).then(function(json) {\n  \t// json 是异步操作成功后, resolve(this.response)传递过来的\n  \tconsole.log(&#39;Contents: &#39; + json);\n\t}, \n  function(error) {\n    console.error(&#39;出错了&#39;, error);\n  });\n\n// then 返回一个新的 Promise,\ngetJSON(&quot;/posts.json&quot;)\n\t.then(function(json) {\n  \treturn json.post;\n\t})\n  .then(function(post) {\n  \t// 该回调函数接收上一个回调函数的返回值(return json.post)作为参数\n\t});</code>\n        </deckgo-highlight-code>\n<h6>手写 Promise</h6>\n<p>理解浏览器的事件循环（Event loop），一句话即Promise是先同步处理then、catch函数再异步处理executor函数，接着通过resolve或reject触发then、catch的参数。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 因为会立即执行这个执行器函数\nfunction MyPromise(executor){\n  let self = this\n  self.status = &#39;pending&#39; // 默认promise状态是pending\n  function resolve(value){\n    self.status = &#39;resolved&#39; // 成功状态\n    self.onSuccess(value);\n  }\n  function reject(reason){\n    self.status = &#39;rejected&#39; //失败状态\n    self.onFail(reason);\n  }\n  executor(resolve, reject) \n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n\tthis.onSuccess = onFulfilled;\n  this.onFail = onRejected;\n} \n\n// 使用MyPromise\nlet p = new MyPromise((resolve, reject) =&gt; {\n  let timer = setTimeout( ()=&gt;{\n    console.log(&#39;开始异步执行!&#39;);\n    resolve(timer);\n  }, 2000);\n})\np.then(data=&gt;{\n  console.log(`异步执行完成!  data:${data}`);\n  clearTimeout(data);\n})\n.catch(error=&gt;console.log(error));\n\nconsole.log(&#39;同步代码执行完成!&#39;);</code>\n        </deckgo-highlight-code>\n<h6>参考</h6>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&#x26;mid=2247484260&#x26;idx=1&#x26;sn=0bc8a7aed8b15d3cc7e75c76394b648a&#x26;chksm=c06682f2f7110be41b29ce0eabc441fba11e1ab306ca40e4e7d81d338b4af7e35721573d1cca&#x26;mpshare=1&#x26;scene=1&#x26;srcid=&#x26;sharer_sharetime=1566171898757&#x26;sharer_shareid=c0fa4bb765d12545f4439ab827814978&#x26;key=56eb82a42460d979c3afc63a4f31177e13db16329cf4763c707bf96642e8906b81d68c0b03fa52eaabde20326b79c31368a9de23b389122e084df4a3c4aa327001973a319a1020fe8e99f6a26930b5b9&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060833&#x26;lang=zh_CN&#x26;pass_ticket=D8igzih7KnA8%2F5LHQdRG6th5IVXvvQD7ukUD5HSt%2FLcfZ7gOforYJWqBjo9rYF%2FC\">你了解Promise吗-segmentfault</a></li>\n<li><a href=\"https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4\">Promse A+ 规范</a> </li>\n<li><a href=\"https://juejin.im/post/5b83cb5ae51d4538cc3ec354\">Promise 实现原理-掘金</a></li>\n</ul>\n<h5>async &#x26; await</h5>\n<p><strong>async 函数就是 Generator 函数的语法糖。</strong>  </p>\n<p>await 命令只能出现在 async 函数中，await 表达式会暂停当前 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\"><code>async function</code></a> 的执行，等待其后面表达式的结果，像 Generateor 函数一样将执行权转让给其他程序；</p>\n<ul>\n<li>async 定义一个通过事件循环异步执行的异步函数，该函数隐式返回一个 Promise 对象，可以用<code>then</code>方法指定下一步的操作。</li>\n<li><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数；</li>\n<li><code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</li>\n<li><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，才会执行<code>then</code>方法指定的回调函数，除非遇到<code>return</code>语句或者抛出错误。</li>\n</ul>\n<p>result = await 表达式</p>\n<ul>\n<li>await 等待一个Promise对象，await 表达式的值就是 Promise 处理的结果，若表达式不是 Promise，则返回表达式本身的值；</li>\n<li>await 会暂停异步函数(async 函数)的执行，调用async函数的上层函数会继续执行(收到异步函数返回的隐式Promise)</li>\n<li>若 await 后面的表达式是Promise，且 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\"><code>async function</code></a>。</li>\n<li>\n<p>若 await 后面的表达式是Promise，且  Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。所以最好将await命令放在<code>try catch</code>中</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">async function myFunction() {\ntry {\n  await somethingThatReturnsAPromise();\n} catch (err) {\n  console.log(err);\n}\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p><strong>async 实现</strong></p>\n<p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function spawn(genF) {\n  return new Promise(function (resolve, reject) {\n    const gen = genF();\n    function step(nextF) {\n      let next;\n      try {\n        next = nextF();\n      } catch (e) {\n        return reject(e);\n      }\n      if (next.done) {\n        return resolve(next.value);\n      }\n      Promise.resolve(next.value).then(\n        function (v) {\n          step(function () {\n            return gen.next(v);\n          });\n        },\n        function (e) {\n          step(function () {\n            return gen.throw(e);\n          });\n        }\n      );\n    }\n    \n    step(function () {\n      return gen.next(undefined);\n    });\n  });\n}</code>\n        </deckgo-highlight-code>\n<p><strong>参考</strong></p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\">MDN-aync</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await\">MDN-await</a>  </li>\n<li><a href=\"https://segmentfault.com/a/1190000007535316\">理解 JavaScript 的 async/await</a> </li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&#x26;mid=2650215577&#x26;idx=1&#x26;sn=0edb4be37430e17ba1029ab3b1a36a57&#x26;chksm=befe14b889899daea69684da9ac22613cfef5e534f920a194a640f21ab5ec839d498642ed455&#x26;scene=0&#x26;key=6deb43fc298651d2935752bd2c9f8fa907d71cfcf410807341a1a420ced46efe20f453fa8f835874ef05bec5deefb1be9a1a136a7027e798b32030bded88d257b46b8f1442a2b56ac165cfaa80db49f5&#x26;ascene=1&#x26;uin=Mjc2NDI1NDU2NA%3D%3D&#x26;devicetype=Windows+7&#x26;version=62060720&#x26;lang=zh_CN&#x26;pass_ticket=Pn9cJyIWK2xt%2BmQltkMddf4S5oGoplFdiJ%2B16Yj6gD8L9Zd0WMlQ1u32%2FRJtZE1p\">async &#x26; await 面试题</a> </li>\n<li><a href=\"https://gongchenghuigch.github.io/2019/09/14/awat/\">setTimeout promise async</a> </li>\n</ul>\n<h5>异步编程</h5>\n<ul>\n<li>\n<p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>\n<ul>\n<li>回调、事件监听、Promise对象</li>\n</ul>\n</li>\n</ul>\n<h4>模块</h4>\n<ul>\n<li>import 命令具有提升效果，import 是在编译阶段执行的，在代码运行之前。</li>\n<li><code>import</code>语句会执行所加载的模块</li>\n<li>\n<p><code>import</code>语句是 Singleton 模式，多次import 同一个模块只会导入一次，也只会执行一次模块中的全局代码</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">import {A} from &#39;mode&#39;\nimport {A} from &#39;mode&#39;\n\n// 等价于 \nimport {A, B} from &#39;mode&#39;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>","id":"0a994316-668a-5210-add5-c78d7a4fa51d","parent":{"__typename":"File","name":"ES6","base":"ES6.md","mtime":"2022-03-30T03:12:22.865Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/前端/JS/ES6/"}},"staticQueryHashes":["3957182205"]}