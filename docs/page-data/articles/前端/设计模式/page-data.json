{"componentChunkName":"component---src-templates-post-js","path":"/articles/前端/设计模式/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/前端/设计模式/"},"html":"<blockquote>\n<p>所有设计模式的实现都遵循一条原则：找出程序中变化的部分，并将变化封装起来。</p>\n<p>分辨模式的关键是目标(应用场景、解决什么问题)</p>\n</blockquote>\n<h1>原型模式</h1>\n<p>JS 中所有对象都是从另一个对象克隆得到的。所以 JS 中必须有一个根对象(<code>Object.prototype</code>)，从这个根对象开始克隆生成其他对象。</p>\n<p>拆分变化和不变的部分。复用不变的部分，可以是行为、结构</p>\n<h1>闭包和高阶函数</h1>\n<p>闭包的形成与<strong>变量的作用域</strong>和变量的<strong>生存周期</strong>密切相关。</p>\n<ul>\n<li>变量的作用域：变量的有效范围，分为全局作用域、函数作用域和块级作用域(仅<code>let</code>、<code>const</code>)</li>\n<li>生存周期：从创建到被回收</li>\n</ul>\n<h2>高阶函数</h2>\n<ul>\n<li>分时函数</li>\n<li>惰性加载函数</li>\n</ul>\n<h3>柯里化</h3>\n<blockquote>\n<p>作用：将一个函数拆分为多个函数，将多参形式转为单参形式，预先设置函数的参数；</p>\n<p>形式：函数的封装，一个函数返回另一个函数；</p>\n</blockquote>\n<ul>\n<li>\n<p>判断数据类型</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const checkType = type =&gt; {\n  return data =&gt; Object.prototype.toString.call(data) === `[object ${type}]`;\n}\nlet types = [&#39;Number&#39;, &#39;String&#39;, &#39;Boolean&#39;];\nlet utils = {};\ntypes.forEach( type =&gt; utils[`is${type}`]=checkType(type) );\n\n// 使用\nutils.isNumber(12);</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h3>节流</h3>\n<ul>\n<li>\n<p>对计算复杂度较高的函数，限制其在一定时间内的执行次数，如1秒内调用多次，但只执行一次；比如 <code>onresize</code> 事件。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">window.onresize = throttle(handleResize, 1000);\nfunction throttle(fn, time) {\n  let timer;\n  return (...args) =&gt; {\n    timer &amp;&amp; clearTimeout(timer);\n    timer = setTimeout(() =&gt; fn(...args), time);\n  }\n}\nfunction handleResize(e) {\n  print(e.currentTarget.innerWidth);\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h1>单例模式</h1>\n<p><u>定义</u>：一个类只有一个实例</p>\n<h1>策略模式</h1>\n<p><u>定义</u>：定义一系列算法，并把每个算法封装起来，使他们可以相互替换。</p>\n<p>策略模式可以消除分支较多的 <code>if</code> 语句。</p>\n<h1>代理模式</h1>\n<p>常见的代理模式有：</p>\n<ul>\n<li>\n<p>缓存代理：缓存计算的结果，如果下次的输入相同直接返回缓存的结果，\ndemo</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function generateProxy(fn){\n  let cache = {};\n  return (...args)=&gt;{\n    let k = args.join(&#39;,&#39;);\n    if( k in cache ){\n      return cache[k];\n    }\n    return cache[k] = fn(...args);\n  }\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>导出组件内部的数据(状态)，比如一个表单，在表单组件的外层获取到所有表单字段的值</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// use-form-context.tsx\nexport default function useFormContext(config = {}) {\n  const [formContext, setFormContext] = useState(Object.assign({}, initState, config));\n  // 增删改查\n  const operate = {\n    setValue: (key, value) =&gt; {\n      let newState = {\n        ...formContext,\n        [key]: value,\n      };\n      setFormContext(newState);\n    },\n    getValue: (key) =&gt; {\n      return formContext[key];\n    },\n    addState: (key, value = &#39;&#39;) =&gt; {\n      let newState;\n      if (Array.isArray(key)) {\n        let obj = {};\n        key.forEach((k, idx) =&gt; (obj[k] = value[idx]));\n        newState = { ...formContext, ...obj };\n      } else {\n        newState = { ...formContext, [key]: value[idx] };\n      }\n      setFormContext(newState);\n    },\n  };\n  // 导出所有的值\n  _setAllValues(formContext);\n  return [formContext, operate, validateRule];\n}\n\nconst _setAllValues = (function () {\n  let data = {};\n  return (value = null) =&gt; {\n    value !== null &amp;&amp; (data = value);\n    return () =&gt; data;\n  };\n})();\n\nexport const getAllValues = () =&gt; {\n  return _setAllValues()();\n};\n\n// index.tsx\nimport {getAllValues} from &#39;use-form-context&#39;;\nconsole.log( getAllValues() );</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>写时复制代理\n<strong>Vue3.0 中通过代理实现数据绑定</strong></p>\n</li>\n</ul>\n<h1>发布订阅模式(观察者)</h1>\n<p>作用：解耦，避免使用硬编码。</p>\n<p>JavaScript 中使用事件模型代替传统的发布订阅模式。</p>\n<p>利用消息队列实现组件通信：改变数据的组件发送一个消息，使用数据的组件监听这个消息并在响应函数中触发<code>setState</code>来改变组件状态。本质上这是<strong>观察者模式的实现</strong>。</p>\n<h1>中介者模式</h1>\n<blockquote>\n<p>使对象和对象之间解耦，用中介者和多个对象的一对多关系取代了对象和对象之间的多对多关系。</p>\n</blockquote>\n<h1>装饰者模式</h1>\n<blockquote>\n<p>装饰者模式可以动态给某个对象添加功能(职责)。装饰者也称为包装器。</p>\n<p>高阶组件是一种特殊的函数，该函数接收一个组件作为参数并且返回一个新的组件。高阶组件的实现本质上是<strong>装饰者设计模式</strong>。</p>\n</blockquote>\n<ul>\n<li>\n<p>demo\n使用高阶函数传递 context 给组件，避免层层传递 props，部分代码如下，完整代码请查看 <a href=\"https://codesandbox.io/s/react-test-project-mm27e?file=/src/App.tsx\">https://codesandbox.io/s/react-test-project-mm27e?file=/src/App.tsx</a></p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// context.tsx\nexport const FormContext = React.createContext({});\nexport const HOCWithFormContext = (Component: any) =&gt; {\n  return (\n    &lt;FormContext.Consumer&gt;\n      {(context) =&gt; &lt;Component {...context}&gt;&lt;/Component&gt;}\n    &lt;/FormContext.Consumer&gt;\n  );\n};\n\n// App.tsx\nconst selectorWithContext = HOCWithFormContext(SelectorWrap);\nfunction ParentWrap(props: IParentWrap) {\n  return (\n    &lt;div className=&quot;flex-left&quot;&gt;\n      {selectorWithContext}\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>","id":"ebbff72d-951e-5a9d-b4df-f54700560ee5","parent":{"name":"设计模式","base":"设计模式.md","mtime":"2022-09-07T04:15:03.263Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/前端/设计模式/"}},"staticQueryHashes":["3957182205"]}