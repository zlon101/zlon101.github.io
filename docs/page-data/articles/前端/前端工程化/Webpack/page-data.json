{"componentChunkName":"component---src-templates-post-js","path":"/articles/前端/前端工程化/Webpack/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/前端/前端工程化/Webpack/"},"html":"<p><a href=\"https://webpack.docschina.org/concepts/\">webpack文档</a> </p>\n<h1>目的</h1>\n<blockquote>\n<ul>\n<li>命名chunk: <code>output.chunkFilename: '[name].[hash:8].js'</code></li>\n<li>webpack 提高编译速度: <code>rulesp[0].include = [paht.resolve(__dirname, 'src')]</code> </li>\n<li>性能优化: <code>cfg.optimization.splitChunks.chunks = \"all\"</code> </li>\n</ul>\n</blockquote>\n<blockquote>\n<p>前端项目配置</p>\n<ul>\n<li>开发环境/生产环境</li>\n<li>环境变量</li>\n<li>mock</li>\n<li>webpack-dev-server</li>\n<li>开发环境公共样式分离为单独的css文件</li>\n<li>生产环境需要压缩 HTML/CSS/JS 代码</li>\n<li>生产环境需要压缩图片</li>\n<li>开发环境需要生成 sourcemap 文件</li>\n<li>开发环境需要打印 debug 信息</li>\n<li>开发环境需要 live reload 或者 hot reload 的功能</li>\n</ul>\n</blockquote>\n<h1>概念</h1>\n<p>webpack 的应用场景主要是 SPA (单页面富应用)，而 SPA 的核心是前端路由，那怎么算是SPA？在前后端分离的基础上加一层前端路由。通俗的讲，路由就是网址；专业的讲就是：每次GET、POST在服务器端有一个专门的正则配置列表，然后匹配到具体的路径后，分发到不同的Controller，进行各种操作，最后将HTML或数据返回给前端，这就完成了一次IO。</p>\n<ul>\n<li>目前多数网站都是后端路由，也就是多页面，页面可以在服务端渲染好直接返回给浏览器，不用等待加载JS和CSS文件就能显示网页。缺点在于模本由后端维护或改写，前端开发需要安装整套的后端服务，必要时还需运用PHP、JAVA这类的非前端语言来改写HTML结构，所以HTML和数据、逻辑混为一谈。</li>\n<li>然后就有了前后端分离的开发模式，后端只提供API返回数据，前端通过Ajax获取数据后，再用一定的方式渲染页面，这样后端专注于数据，前端专注于交互和可视化。缺点在于首屏渲染需要时间加载JS和CSS文件，这种开发模式被多数公司认同，也出现了很多前端技术栈，比如JQuary+artTemplate+Seajs(requirejs)+gulp 为主的开发模式可谓是万金油。</li>\n<li>在Node出现后，这种现象得到了改善，即所谓的大前端，得益于Node和JavaScript的语言特性，HTML模本可以完全由前端控制，同步或异步渲染完全由前端自由决定，并由前端维护模板。</li>\n</ul>\n<blockquote>\n<ul>\n<li>webpack 是用来处理模块间的依赖关系，并对他们进行打包。</li>\n<li>webpack基于node，在node环境下运行，可以使用ES6的模块加载方法;</li>\n<li>npm命令根据package.json配置文件执行，在该文件中设置webpack使用的命令及哪个配置文件；</li>\n<li><code>entry</code> 可以有多个，但<code>output</code> 只能有一个</li>\n</ul>\n</blockquote>\n<h2>webpack结构</h2>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4a13074e2332f71cf38630efa31ee205/38f6f/webpack%E7%BB%93%E6%9E%84.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAQBAgMF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB6l1JMxcP/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIAAxIxEf/aAAgBAQABBQJTDy7oc+baWsdf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQcYH/2gAIAQEABj8CiwU4f//EABwQAQABBAMAAAAAAAAAAAAAAAEAESExQVGRof/aAAgBAQABPyFGhqhGlkuZIyTXEaGfI8X6T//aAAwDAQACAAMAAAAQaO//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxAn/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Qp//EAB4QAQACAgIDAQAAAAAAAAAAAAEAETFRIUFhcYHR/9oACAEBAAE/EBiGlVHgjB+nU4cWjrPLMW49Neo52cafktE8Aw2z/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"webpack结构\" title=\"webpack结构\" src=\"/static/4a13074e2332f71cf38630efa31ee205/4b190/webpack%E7%BB%93%E6%9E%84.jpg\" srcset=\"/static/4a13074e2332f71cf38630efa31ee205/e07e9/webpack%E7%BB%93%E6%9E%84.jpg 200w,\n/static/4a13074e2332f71cf38630efa31ee205/066f9/webpack%E7%BB%93%E6%9E%84.jpg 400w,\n/static/4a13074e2332f71cf38630efa31ee205/4b190/webpack%E7%BB%93%E6%9E%84.jpg 800w,\n/static/4a13074e2332f71cf38630efa31ee205/e5166/webpack%E7%BB%93%E6%9E%84.jpg 1200w,\n/static/4a13074e2332f71cf38630efa31ee205/38f6f/webpack%E7%BB%93%E6%9E%84.jpg 1366w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>  \n<h2>构建流程</h2>\n<p>从启动webpack构建到输出结果经历了一系列过程，它们是：</p>\n<ol>\n<li>解析webpack配置参数，合并从shell传入和<code>webpack.config.js</code>文件里配置的参数，生产最后的配置结果。</li>\n<li>注册所有配置的插件，好让插件监听 webpack 构建生命周期的事件节点，以做出对应的反应。</li>\n<li>从配置的 <code>entry</code> 入口文件开始解析文件构建 AST 语法树，找出每个文件所依赖的文件，递归下去。</li>\n<li>在解析文件递归的过程中根据文件类型和 loader 配置找出合适的 loader 用来对文件进行转换。</li>\n<li>递归完后得到每个文件的最终结果，根据 <code>entry</code> 配置生成代码块 <code>chunk</code>。</li>\n<li>输出所有 <code>chunk</code> 到文件系统。</li>\n<li>需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如 <code>UglifyJsPlugin</code> 会在 loader 转换递归完后对结果再使用 <code>UglifyJs</code> 压缩覆盖之前的结果。</li>\n</ol>\n<h1>loader</h1>\n<ul>\n<li>webpack 只能理解 <strong>JS</strong> 和 <strong>JSON</strong> 文件，其他类型的文件需要用 loader 处理并被 loader 转换为有效的模块，然后添加到依赖图中。</li>\n<li>loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 <code>import</code> CSS 文件！</li>\n<li>webpack 的其中一个强大的特性就是能通过 <code>import</code> 导入任何类型的模块（例如 <code>.css</code> 文件），</li>\n<li>所有的 loader 按照<strong>前置 -> 行内 -> 普通 -> 后置</strong>的顺序执行</li>\n</ul>\n<h2>常用loader</h2>\n<ul>\n<li>css文件处理：style-loader css-loader</li>\n<li>\n<p>字体和静态图像:  file-loader</p>\n<deckgo-highlight-code language=\"json\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">{\ntest: /\\.(png|svg|jpg|gif)$/,\nuse: [\n\t&#39;file-loader&#39;,\n],\n},</code>\n        </deckgo-highlight-code>\n</li>\n<li>压缩图像: <a href=\"https://github.com/tcoopman/image-webpack-loader\">image-webpack-loader</a>、<a href=\"https://webpack.docschina.org/loaders/url-loader\">url-loader</a>（图像转为base64） </li>\n</ul>\n<h2>自定义loader</h2>\n<p><a href=\"https://webpack.js.org/contribute/writing-a-loader/\">编写loader</a>  </p>\n<h2>loader 和 plugin的区别</h2>\n<ul>\n<li>webpakc中每个文件都视为一个模块，webpack 核心只能处理JS文件(模块)，所以需要loader对非JS文件进行转换，loader不影响构建流程；</li>\n<li>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程。【导出为函数的模块，对匹配的文件进行转换；】</li>\n<li>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后。webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务，包括：打包优化，资源管理，注入环境变量。【带有apply方法的对象，apply方法被webpack的编译器调用；扩展webpack的功能，在构建过程中注入钩子函数实现；】</li>\n<li><a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308\">webpack 中 loader 和 plugin 的区别是什么</a></li>\n</ul>\n<h1>插件</h1>\n<blockquote>\n<p>常用插件</p>\n<ul>\n<li>生成html文件: html-webpack-plugin</li>\n<li>压缩js代码: uglifyjs-webpack-plugin</li>\n<li>定义环境变量: DefinePlugin，内置插件<code>webpack.DefinePlugin</code></li>\n<li>分离单独的css文件: extract-text-webpack-plugin</li>\n<li>分离单独的css文件: <a href=\"https://webpack.docschina.org/plugins/mini-css-extract-plugin/#minimizing-for-production\">MiniCssExtractPlugin</a> 插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载</li>\n</ul>\n</blockquote>\n<h2>自定义插件</h2>\n<blockquote>\n<p>webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 webpack compiler 调用，并且在 整个 编译生命周期都可以访问 compiler 对象。</p>\n</blockquote>\n<blockquote>\n<p>如何自定义webpack插件</p>\n</blockquote>\n<ul>\n<li>JavaScript 命名函数</li>\n<li>在插件函数prototype 上定义一个apply 方法</li>\n<li>定义一个绑定到webpack 自身的hook</li>\n<li>处理webpack内部特定数据</li>\n<li>功能完成后调用webpack 提供的回调</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// ConsoleLogOnBuildWebpackPlugin.js\nconst pluginName = &#39;ConsoleLogOnBuildWebpackPlugin&#39;;\n\nclass ConsoleLogOnBuildWebpackPlugin {\n  apply(compiler) {\n    compiler.hooks.run.tap(pluginName, (compilation) =&gt; {\n      console.log(&#39;webpack 构建正在启动！&#39;);\n    });\n  }\n}\n\nmodule.exports = ConsoleLogOnBuildWebpackPlugin;</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://www.webpackjs.com/contribute/writing-a-plugin/\">https://www.webpackjs.com/contribute/writing-a-plugin/</a> </p>\n<h1>webpack配置</h1>\n<blockquote>\n<p><a href=\"https://createapp.dev/webpack/vue--babel--typescript\">自定义配置UI</a> </p>\n</blockquote>\n<ol>\n<li>\n<p>package.json</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">{\n   ...\n   &quot;script&quot;: {\n       &quot;build&quot;: &quot;webpack --config 配置文件webpack.config.js&quot;,\n        &quot;dev&quot;: &quot;webpack --config 配置文件&quot;\n   }\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>webpack.config.js </p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">module.exports = {\n  entry: {\n      &quot;main&quot;: &quot;./main.js&quot;\n  },\n  output: {\n      filename: &quot;./dist/build.js&quot;\n  },\n  devtool: &quot;source-map&quot;,\n  // watch: 监听文件的变化，当文件改动时，自动执行构建,输出build.js\n  watch: true,\n  module: {\n      rules: [\n          // 对css文件，webpack先用css-loader解析css文件，  \n          // 解析完成后再用style-loader将css代码用style标签嵌入到&lt;head&gt;标签里\n          {\n              test: /\\.css$/,\n              use: &#39;style-loader!css-loader&#39;\n              // use: [&#39;style-loader&#39;, &#39;css-loader&#39;] 先用css-loader处理，在用style-loader处理\n          },\n          // 处理less文件\n          {\n              test: /\\.less$/,\n              use: &#39;style-loader!css-loader!less-loader&#39;\n          },\n          // 处理ES5，ES6,ES7等\n          {\n              test: /\\.js$/,\n              loader: &#39;babel-loader&#39;,\n              exclude: &#39;/node_modules/&#39;,\n              options: {\n                  presets: [&#39;env&#39;],\t// 处理关键字es5，es6，env等\n                  plugins: [&#39;transform-runtime&#39;]\t // 处理函数\n              }\n          }\n      ]\n  },\n  plugins: []\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ol>\n<h1>自动加载组件|路由</h1>\n<blockquote>\n<p>require.context</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">var requireComponent = require.context(&quot;./src&quot;, true, /^Base[A-Z]/)\nrequireComponent.keys().forEach(function (fileName) {\n  var cfg = requireComponent(fileName)\n  cfg = cfg.default || cfg\n  var componentName = cfg.name || fileName.replace(/^.+\\//, &#39;&#39;).replace(/\\.\\w+$/, &#39;&#39;);\n  Vue.component(componentName, cfg)\n})</code>\n        </deckgo-highlight-code>\n<h1>svg处理</h1>\n<blockquote>\n<ol>\n<li>读取 svg 文件</li>\n<li>压缩svg\nsvgo-loader</li>\n<li>生成组件</li>\n</ol>\n</blockquote>\n<h1>问题</h1>\n<ul>\n<li>代码分离，路由懒加载，如果资源（组件）文件不在 <code>src</code> 目录下，使用动态 <code>import</code> 不会打包为多个 chunk</li>\n<li><code>entry.page</code></li>\n<li>contenthash: 根据资源内容创建出唯一 hash，但是资源没有变化，每次build时hash还是会变化。因为webpack 在入口 chunk 中，包含了某些 boilerplate(引导模板)，特别是 runtime 和 manifest。（译注：boilerplate 指 webpack 运行时的引导代码）。</li>\n<li>我们将 <code>lodash</code> 安装为 <code>devDependencies</code> 而不是 <code>dependencies</code>，因为我们不需要将其打包到我们的库中，否则我们的库体积很容易变大。</li>\n<li>现在，如果执行 <code>webpack</code>，你会发现创建了一个体积相当大的文件。如果你查看这个文件，会看到 lodash 也被打包到代码中。在这种场景中，我们更倾向于把 <code>lodash</code> 当作 <code>peerDependency</code>。也就是说，consumer(使用者) 应该已经安装过 <code>lodash</code> 。因此，你就可以放弃控制此外部 library ，而是将控制权让给使用 library 的 consumer</li>\n<li><a href=\"https://webpack.docschina.org/guides/author-libraries/\">创建library</a> </li>\n</ul>\n<h1>参考</h1>\n<p><a href=\"https://www.kancloud.cn/sllyli/webpack/1242347\">webpack定制前端开发环境</a> </p>","id":"6aa91597-0ad8-5877-a08d-7a589b751ab3","parent":{"__typename":"File","name":"Webpack","base":"Webpack.md","mtime":"2022-09-03T14:08:55.931Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/前端/前端工程化/Webpack/"}},"staticQueryHashes":["3957182205"]}