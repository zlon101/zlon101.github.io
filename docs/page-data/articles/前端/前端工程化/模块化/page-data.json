{"componentChunkName":"component---src-templates-post-js","path":"/articles/前端/前端工程化/模块化/","result":{"data":{"markdownRemark":{"fields":{"articlePath":"/articles/前端/前端工程化/模块化/"},"html":"<h4>模块化规范</h4>\n<ol>\n<li>应用环境：服务端 &#x26; 客服端</li>\n<li>加载时期：编译时加载 &#x26; 运行时加载</li>\n<li>加载原理</li>\n<li>区别</li>\n</ol>\n<p><strong>CommonJS--->AMD--->CMD--->ESModule</strong></p>\n<h5>CommonJS</h5>\n<p>同步加载，应用于服务端；API：module.export require</p>\n<p>CommonJS 运行时加载并执行，输出值的拷贝(快照)，在内存中生成一个带有export、id等属性的对象，export属性就是模块导出的值，重复加载时只会执行一次，从缓存中取值；一个文件就是一个模块，module变量对象就代表当前模块，导出的值挂载到module.export 上，</p>\n<ul>\n<li>CommonJS 暴露的模块到底是什么? CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。\n<code>console.log(module.exports === exports) // true</code></li>\n<li>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象</li>\n<li>\n<p>加载并执行模块时生成的对象结构：</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">{\nid: &#39;...&#39;, // 模块名\nexports: { ... }, // 模块输出的各个接口, 也就是通过 module.exports = {...} 或者 exports[&#39;xxx&#39;] 赋值 的内容\nloaded: true, // 表示该模块的脚本是否执行完毕\n\n// ...还有很多其他属性\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5>AMD</h5>\n<p>异步加载，依赖前置，提前执行，不能按需加载</p>\n<p>requireJS</p>\n<ul>\n<li>\n<p>定义模块</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">define([依赖], 回调);</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>加载模块</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">require([依赖], 回调);</code>\n        </deckgo-highlight-code>\n</li>\n<li>定义模块和加载模块时，可选的依赖加载完成后执行回调函数；</li>\n</ul>\n<h5>CMD</h5>\n<p>异步加载，依赖就近，按需加载，应用于浏览器端</p>\n<ul>\n<li>\n<p>定义模块</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">define(function (require, exports, module)){\n\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>加载模块</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\"></code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h5>ESModule</h5>\n<p><u>加载原理</u>:</p>\n<ul>\n<li>编译时加载，静态分析，import 命令提前，生成只读引用，运行时再根据引用到模块中取值；接口与模块内部的值是动态绑定；多次加载只会执行一次；</li>\n</ul>\n<p><u>ESModule 与 CommonJS 关系：</u>在 Webpack 构建之后，都是 CommonJS 格式</p>\n<ul>\n<li>CommonJS 模块输出的是一个值的「拷贝」，ES6 模块输出的是值的「引用」。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>CommonJS 模块是「运行时」加载，ES6 模块是「编译时」输出接口。</li>\n<li>CommonJS 加载的是一个对象（ 即 module.exports 属性 ），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>\n</ul>\n<h5>参考</h5>\n<ul>\n<li><a href=\"https://blog.lbinin.com/frontEnd/JavaScript/Module-Import.html#esmodule\">ESModule</a> </li>\n</ul>","id":"e1349376-5d7d-5b8e-bb96-de8e61f793b5","parent":{"__typename":"File","name":"模块化","base":"模块化.md","mtime":"2022-03-30T03:12:22.884Z","sourceInstanceName":"markdown"}}},"pageContext":{"articlePath":"/articles/前端/前端工程化/模块化/"}},"staticQueryHashes":["3957182205"]}