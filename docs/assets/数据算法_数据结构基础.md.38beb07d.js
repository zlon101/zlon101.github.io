import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.cbe154cb.js";const o="/assets/1563431526213.f8d24141.png",p="/assets/1563673731524.b753ae45.png",h=JSON.parse('{"title":"树","description":"","frontmatter":{},"headers":[],"relativePath":"数据算法/数据结构基础.md","filePath":"数据算法/数据结构基础.md"}'),e={name:"数据算法/数据结构基础.md"},t=l(`<blockquote><p>递归本质上就是一个栈结构</p></blockquote><h1 id="树" tabindex="-1">树 <a class="header-anchor" href="#树" aria-label="Permalink to &quot;树&quot;">​</a></h1><h2 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h2><blockquote><p>二叉树：子节点个数最多为 2 个；</p></blockquote><h2 id="满树" tabindex="-1">满树 <a class="header-anchor" href="#满树" aria-label="Permalink to &quot;满树&quot;">​</a></h2><div class="language-markdown"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">d</span></span>
<span class="line"><span style="color:#A6ACCD;">    /   \\</span></span>
<span class="line"><span style="color:#A6ACCD;">   b      f</span></span>
<span class="line"><span style="color:#A6ACCD;">  / \\    / \\</span></span>
<span class="line"><span style="color:#A6ACCD;"> a   c  e   g</span></span></code></pre></div><h2 id="完全二叉树" tabindex="-1">完全二叉树 <a class="header-anchor" href="#完全二叉树" aria-label="Permalink to &quot;完全二叉树&quot;">​</a></h2><ol><li>除最后一层外，其他每层节点都是满的，最后一层从左向右填满二叉树</li><li>如果树的深度为h，那么除了第 h 层，其他层的节点数都是满的，第 h 层有的节点数在 1 和 2h−1 之间。</li></ol><div class="language-markdown"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">1</span></span>
<span class="line"><span style="color:#A6ACCD;">    /   \\</span></span>
<span class="line"><span style="color:#A6ACCD;">   2     3</span></span>
<span class="line"><span style="color:#A6ACCD;">  / \\    /</span></span>
<span class="line"><span style="color:#A6ACCD;"> 4   5  6</span></span></code></pre></div><h2 id="平衡二叉树" tabindex="-1">平衡二叉树 <a class="header-anchor" href="#平衡二叉树" aria-label="Permalink to &quot;平衡二叉树&quot;">​</a></h2><blockquote><p>任意节点的左右子树的高度之差不大于1；</p></blockquote><h2 id="二叉查找树" tabindex="-1">二叉查找树 <a class="header-anchor" href="#二叉查找树" aria-label="Permalink to &quot;二叉查找树&quot;">​</a></h2><p>二叉查找树：特殊的二叉树，左节点的值比其父节点的值小；此特性使二叉查找树的查找效率很高。</p><p>遍历顺序：</p><ol><li>先序：先访问根节点---&gt;左节点---&gt;右节点；</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">preOrder</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">node</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">list</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">node</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#A6ACCD;">list</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">val</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#82AAFF;">preOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">left</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">list</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#82AAFF;">preOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">right</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">list</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><ol start="2"><li>中序：先访问左节点---&gt;根节点(根节点在中间)---&gt;右节点；</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">inOrder</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">node</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">node</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">inOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">left</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">print</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">val</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">inOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">right</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 使用循环</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">inOrder</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">root</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">cur</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">root</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">arr</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> []</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">stack</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> []</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">cur</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#89DDFF;">&gt;</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">cur</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">      </span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#A6ACCD;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">cur</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#A6ACCD;">cur</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">cur</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">left</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#A6ACCD;">cur</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pop</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#A6ACCD;">arr</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">cur</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">val</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#A6ACCD;">cur</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">cur</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">right</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">arr</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><ol start="3"><li>后序：先访问左节点---&gt;右节点---&gt;根节点；</li></ol><h2 id="红黑树" tabindex="-1">红黑树 <a class="header-anchor" href="#红黑树" aria-label="Permalink to &quot;红黑树&quot;">​</a></h2><p>红黑树（Red-Black Tree）是一种自平衡二叉搜索树，它通过在每个节点上添加一个存储位来确保树的平衡。这个存储位被称为“颜色”，它可以是红色或黑色。红黑树满足以下几个性质：</p><ol><li>每个节点都有一个颜色，要么是红色，要么是黑色。</li><li>根节点是黑色的。</li><li>每个叶子节点（NIL节点，空节点）都是黑色的。</li><li>如果一个节点是红色的，则它的两个子节点都是黑色的。</li><li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。</li></ol><p>这些性质确保了红黑树具有良好的平衡性，使得其各种操作的时间复杂度都能够保持在 O(log n) 级别，其中 n 是树中节点的数量。因此，红黑树常常被用作实现集合、映射等数据结构的基础。</p><h1 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h1><p>堆是具有以下性质的<strong>完全二叉树</strong>：每个结点的值都大于或等于其左右子结点的值，称为大顶堆；</p><p>或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><h1 id="排序" tabindex="-1">排序 <a class="header-anchor" href="#排序" aria-label="Permalink to &quot;排序&quot;">​</a></h1><p>排序一个长度为 n 的数组的时间复杂度是 O(nlogn)；</p><ul><li>冒泡、选择、插入排序的耗时比较：冒泡 &gt; 选择 &gt; 插入；</li><li>高阶算法：希尔、归并、快速排序：</li><li>空间消耗、平均时间复杂度、最差时间复杂度；</li></ul><p><a href="https://blog.csdn.net/yushiyi6453/article/details/76407640" target="_blank" rel="noreferrer">排序算法-动态图</a></p><h1 id="查找" tabindex="-1">查找 <a class="header-anchor" href="#查找" aria-label="Permalink to &quot;查找&quot;">​</a></h1><ul><li>二分查找、哈希表查找、二叉查找树查找；</li><li>哈希表(散列表查找的时间复杂度是 O(1))</li></ul><h1 id="方法总结" tabindex="-1">方法总结 <a class="header-anchor" href="#方法总结" aria-label="Permalink to &quot;方法总结&quot;">​</a></h1><ol><li>查找二维数组上的搜索路径：<strong>回溯法</strong>；</li><li>某个问题的最优解，且该问题可以分解为多个子问题，子问题也存在最优解，如果将每个小问题的最优解组合可以得到目标问题的最优解，这类情况可以考虑使用<strong>动态规划</strong>；</li><li>在某种特殊情况下可以得到目标问题的最优解：<strong>贪心算法</strong>；</li></ol><img src="`+o+'" style="padding:0;margin:10px 0 0;"><img src="'+p+'" style="padding:0;margin:10px 0 0;">',36),r=[t];function c(y,F,i,D,A,C){return a(),n("div",null,r)}const u=s(e,[["render",c]]);export{h as __pageData,u as default};
