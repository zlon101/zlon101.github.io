# 前端路由

前端路由是通过改变URL，在不重新请求页面的情况下，更新页面视图。改变URL且不会重载页面的方式：hash & H5 history.pushState replaceState

> HashHistory

- hash虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变hash不会重新加载页面。

- 可以为hash的改变添加监听事件：

  `window.addEventListener("hashchange",funcRef,false)`  

> TML5History

- pushState和replaceState两种方法的共同特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，重载页面，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。
- 用户导航到新的状态，popstate事件就会被触发；


# 长列表(Table)渲染优化

> 方案

1. 虚拟列表：固定渲染一定数据的列表项

[vue-virtual-scroll-list 组件](https://github.com/tangbc/vue-virtual-scroll-list) 
[react-virtualized](https://github.com/bvaughn/react-virtualized) 

2. 懒加载

# [时区与JS中的Date](https://juejin.cn/post/6844903885505576968)  

# 跨域访问

> [同源策略](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) 

来源于某个 Origin 的 document(html) 或 脚本能否访问其他 Origin 的资源（localStoreage、Cookie、静态资源、xhr接口等）。

“同源” -- 两个源相同，哪两个源？脚本所在的源和脚本要访问的资源所在的源。

> 跨域网络访问

1. 静态资源访问
2. XMLHttpRequest 请求

> [跨域资源共享](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) 
>
> [CORS-博客](http://www.ruanyifeng.com/blog/2016/04/cors.html) 

CORS is a part of [HTTP](https://developer.mozilla.org/en-US/docs/Glossary/HTTP) that lets servers specify any other hosts from which a browser should permit loading of content.



出于安全性，浏览器限制脚本内发起的跨源 HTTP 请求。 例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。



Web页面或应用部署(运行在A服务器/PC上)，用户浏览器请求A服务器上的页面进行访问，A服务器响应请求并返回页面，浏览器显示页面。

页面中的JS通过XMLHttpRequest请求A服务器上的数据时，浏览器不会阻止。但请求B服务器上(第三方)的数据时，浏览器会根据 B 服务器上的跨域配置判断是否运行当前页面获取资源。



浏览器安全策略会阻止该请求，B服务器甚至没有看到页面发出的请求。跨域是浏览器的限制，chrome 可以允许跨域，并且不需要修改服务端配置。



域名与对应的 ip之间通信也算跨域，因为一个ip对应的主机可以有多个网站，对应多个域名。

> 相关的响应头部字段

- [Corss-Origin-Resource-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy_(CORP)) : 跨域策略，可选值为: `same-origin`、`same-site`、`cross-origin` 
  - As this policy is expressed via a *[response header](https://developer.mozilla.org/en-US/docs/Glossary/Response_header)*, the actual request is not prevented—rather, the browser prevents the *result* from being leaked by stripping the response body.
  - During a cross-origin resource policy check, if the header is set, the browser will deny `no-cors` requests issued from a different origin/site.
- [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin): 允许某个源或所有源访问
  - 响应头部字段，标识 response 可以被哪些请求所在 Origin 访问。
  - 服务端收到请求时，检查 request header 的 Origin, 如果允许该 Origin，则设置响应中的 Access-Control-Allow-Origin 值为该请求的 Origin。
  - 请求中没有 `credentials` 字段时，服务端响应的 `Access-Control-Allow-Origin: *` 才有效。
  - 当请求是 `credentialed requests` 时，服务端必须指定 `Access-Control-Allow-Origin` 的值为 `*` 之外的明确值。
  - 如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。
- Access-Control-Allow-Credentials
  - 将 XMLHttpRequest 的 withCredentials 标志设置为 true，从而向服务器发送 Cookies。如果服务器端的响应中未携带 `Access-Control-Allow-Credentials: true`，浏览器将不会把响应内容返回给请求的发送者。
  

> 实际测试

- 正常的浏览器
  - 【http-http】用 XSwitch 可以成功将一个 http://serve-a/x.js 资源重定向到公网的 http://serve-b/x.js 上，并且 `serve-b/x.js` 设置了 `Corss-Origin-Resource-Policy: same-origin`，但是不能重定向到本地的 Js 文件。
  - 【https-http】用 XSwitch 不能将 https://serve-a/x.js 资源重定向到公网的 http://serve-b/x.js 上，报错为：`This request has been blocked; the content must be served over HTTPS.`。
  - 【https-https】若 https://serve-b/x.js 没有配置跨域的响应头部，XSwitch 可以将 https://serve-a/x.js 可以重定向到 https://serve-b/x.js
- 命令行启动浏览器并允许跨域
  - 【https-http】用 XSwitch 可以将 https://serve-a/x.js 资源重定向到本地的 http://127.0.0.1:9001/x.js 上



`Access-Control-Allow-Headers: 'Origin, X-Requested-With, Content-Type, Accept'`



> 正常浏览器测试场景

**(1).** nginx 没有配置跨域相关的 header

- 公网 139.xx 服务获取 http://127.0.0.1:123/demo.js （失败，报错"CORS"，用命令行启动浏览器可以解决）
- 公网 139.xx 服务获取 http://47.xx:8010/demo.js  **（成功）** 
- 127 服务获取公网 http://139.xx.xx/demo.js （成功）
- test.dev.host 服务获取 http://139.xx.xx/demo.js   test.dev.host 解析到127（成功）
- 总结
  - 本地127 或配置域名的 web 服务可以获取其他公网上的 Js 文件，公网不能获取本地 Js 文件，但另一位公网 Nginx 没有配置CORS时，从一个公网可以访问另一个公网的 Js 文件。
  - 一个公网访问跨域获取另一个公网服务商的图像


**(2).** nginx 配置跨域相关的 header

只配置 `Corss-Origin-Resource-Policy: same-origin` 没什么变化




> 解决方案

1. JSONP：Js 文件可以跨域访问。通过动态创建 script，再请求一个带参网址实现跨域通信，通过 `<script>` 标签，在 url 中指定 callback 回调函数，当响应到来时调用回调函数，数据就是传递给回调函数的实参。

```js
function handle(response){
  console.log(response);
}
let script = document.createElement('script');
script.src = 'http://xxx.com/?callback=handle';
document.body.insertBefore(script, docuent.body.firstChild);
```

缺点：只支持 GET请求

2. CORS：跨域资源共享(Cross-origin resource sharing)，服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带 cookie 请求，前后端都需要设置。
   CORS 支持所有类型的请求方法；

3. postMessage 跨域：可以跨域操作的window属性之一，配合 iframe。
4. 代理跨域：起一个代理服务器，实现数据的转发；
5. document.domain + iframe 跨域：两个页面都通过 JS 强制设置 document.domain 为基础主域，就实现了同域。
   只支持主域相同，子域不同；
6. location.hash + iframe 跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用 iframe 的 location.hash传值，相同域之间直接js访问来通信。
7. window.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。

> 参考

- [跨域，你需要知道的全在这里](https://juejin.im/entry/59feae9df265da43094488f6) 
- [跨域资源共享 CORS 详解 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2016/04/cors.html)  
- [浏览器同源策略-postMessage](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html) 
- [CORS 跨域发送 cookie](https://harttle.land/2016/12/28/cors-with-cookie.html#) 
  1. 客服端：withCredentials=true;
  2. 服务端：Access-Control-Allow-Credentials=true; Access-Control-Allow-Origin: 单一域名

```js
access-control-allow-credentials: true
access-control-allow-headers: Content-Type
access-control-allow-origin: https://127.0.0.1:8087
```

# [cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) 

# [Web Storage](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API) 

> Web 全局存储、通信

# [自定义事件](https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events) 

> postMessage  CustomEvent  initEvent

# 拖拽

- [使用原生 JavaScript 实现拖放功能 - 掘金](https://juejin.im/post/6844903940706795533) 
  [原生JS快速实现拖放实例效果与解析](https://mp.weixin.qq.com/s/4WLbV46MsDzlNWzzDep3Pw) 
  [HTML 拖放 API-| MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API) 
  [拖拽操作 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations) 

- 拖拽元素

  ```js
  function makeElMavable(el: HTMLElement) {
    function getStyleVal(xy: 'x' | 'y') {
      const s = xy === 'x' ? el.style.left : el.style.top;
      const v = parseInt(s.replace(/\D/, ''));
      return v || 0;
    }
    
    let startX = 0;
    let startY = 0;
    let touchStartX = 0;
    let touchStartY = 0;
    
    const docMoveListener = (evt: TouchEvent) => {
      const tch = evt.touches[0];
      const dx = tch.screenX - touchStartX;
      const dy = tch.screenY - touchStartY;
      el.style.left = Math.round(startX + dx) + 'px';
      el.style.top = Math.round(startY + dy) + 'px';
    };
    
    el.addEventListener('touchstart', (evt: TouchEvent) => {
      const tch = evt.touches[0];
      startX = getStyleVal('x');
      startY = getStyleVal('y');
      touchStartX = tch.screenX;
      touchStartY = tch.screenY;
      document.addEventListener('touchmove', docMoveListener);
    });
    el.addEventListener('touchmove', (evt) => {
      evt.preventDefault();
    });
    el.addEventListener('touchend', () => {
      document.removeEventListener('touchmove', docMoveListener);
    });
    el.addEventListener('touchcancel', () => {
      document.removeEventListener('touchmove', docMoveListener);
    });
  }
  ```



# 捕获异步错误

https://juejin.im/post/6844903830409183239#heading-4  

Promise 中 throw 的错误，无论是在构造函数中的同步代码还是在 then 回调中的异步代码都只能被 promise.catch 捕获，不能被外层的 `try-catch` 捕获。

reject 返回的错误也只能被 promise.catch 捕获。

总之：promise 会吞掉自身产生的错误，只能通过 promise.catch 捕获这些错误。

  ```js
  const promiseFetch = () => {
    return new Promise(reslove => {
      throw new Error('promise 同步');
      // reslove();
    });
  };
  
  function main() {
    try {
      promiseFetch().then(() => {
        // throw new Error("promise.then 异步"); // 只能被promise.catch 捕获
      }).catch(e => {
        console.debug('promise.catch e:', e);
      });
    } catch (e) {
      console.debug('try-catch e:', e);
    }
  }
  
  main();
  
  ```

### 利用Promise捕获异步错误  

  > 当异步代码发生错误时，通过 reject 抛出错误，然后用 promise.catch 捕获错误。

  ```js
  const p3 = () =>  new Promise((reslove, reject) => {
    setTimeout(() => {
      reject('async error');
    })
  });
  
  p3().catch(e => console.log(e));
  ```

# 搜索高亮

> [纯客户端页面关键字搜索高亮jQuery插件](https://www.zhangxinxu.com/wordpress/2010/06/%E7%BA%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E9%AB%98%E4%BA%AEjquery%E6%8F%92%E4%BB%B6/) 
>
> [单关键词、多关键词、多组多关键词](https://juejin.cn/post/6844903747944972295#apply) 

[IE 链接下载失效](https://stackoverflow.com/questions/46232980/click-giving-access-denied-in-ie11) 

# 移动端

## 设备检测

- 是否是移动端

```js
isTouch = "ontouchstart" in window || navigator.msMaxTouchPoints;

const touchSupported = () => {
  return !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);
}
```

[current-device](https://github.com/matthewhudson/current-device)  

[device-detector-js](https://github.com/etienne-martin/device-detector-js)  

[移动端检测方法](https://www.ruanyifeng.com/blog/2021/09/detecting-mobile-browser.html)  

# 链接

- [异步加载js脚本的方法](https://github.com/YvetteLau/Step-By-Step/issues/26) 

# [时间国际化-格式化](https://mp.weixin.qq.com/s/fepgCR4hikmMwIG3Fbb9gQ)  

# 可视化

- [数据可视化 拓扑图](https://antv.vision/zh/) 
